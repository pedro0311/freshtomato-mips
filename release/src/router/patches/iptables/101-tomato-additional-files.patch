--- iptables/extensions/.account-test
+++ iptables/extensions/.account-test
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if account is applied.
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_account.h ] && echo account
--- iptables/extensions/.BALANCE-test
+++ iptables/extensions/.BALANCE-test
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/net/ipv4/netfilter/ipt_BALANCE.c ] && echo BALANCE
--- iptables/extensions/.childlevel-test
+++ iptables/extensions/.childlevel-test
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_childlevel.h ] && echo childlevel
--- iptables/extensions/.connlimit-test
+++ iptables/extensions/.connlimit-test
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_connlimit.h ] && echo connlimit
--- iptables/extensions/.connrate-test
+++ iptables/extensions/.connrate-test
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_connrate.h ] && echo connrate
--- iptables/extensions/.dstlimit-test
+++ iptables/extensions/.dstlimit-test
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/net/ipv4/netfilter/ipt_dstlimit.c ] && echo dstlimit
--- iptables/extensions/.FTOS-test
+++ iptables/extensions/.FTOS-test
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_FTOS.h ] && echo FTOS
--- iptables/extensions/.fuzzy-test
+++ iptables/extensions/.fuzzy-test
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_fuzzy.h ] && echo fuzzy 
--- iptables/extensions/.fuzzy-test6
+++ iptables/extensions/.fuzzy-test6
@@ -0,0 +1,2 @@
+#!/bin/sh
+[ -f $KERNEL_DIR/net/ipv6/netfilter/ip6t_fuzzy.c -a -f $KERNEL_DIR/include/linux/netfilter_ipv6/ip6t_fuzzy.h ] && echo fuzzy
--- iptables/extensions/.IMQ-test
+++ iptables/extensions/.IMQ-test
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if IMQ target patch is applied.
+[ -f $KERNEL_DIR/net/ipv4/netfilter/ipt_IMQ.c ] && echo IMQ
--- iptables/extensions/.IMQ-test6
+++ iptables/extensions/.IMQ-test6
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if IMQ target patch is applied.
+[ -f $KERNEL_DIR/net/ipv6/netfilter/ip6t_IMQ.c ] && echo IMQ
--- iptables/extensions/.IPMARK-test
+++ iptables/extensions/.IPMARK-test
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if IPMARK patch is applied.
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_IPMARK.h ] && echo IPMARK
--- iptables/extensions/.ipp2p-test
+++ iptables/extensions/.ipp2p-test
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_ipp2p.h ] && echo ipp2p
--- iptables/extensions/.ipv4options-test
+++ iptables/extensions/.ipv4options-test
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if ipv4options is applied.
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_ipv4options.h ] && echo ipv4options
--- iptables/extensions/.IPV4OPTSSTRIP-test
+++ iptables/extensions/.IPV4OPTSSTRIP-test
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if IPV4OPTSSTRIP patch is applied.
+[ -f $KERNEL_DIR/net/ipv4/netfilter/ipt_IPV4OPTSSTRIP.c ] && echo IPV4OPTSSTRIP
--- iptables/extensions/.mport-test
+++ iptables/extensions/.mport-test
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/net/ipv4/netfilter/ipt_mport.c ] && echo mport
--- iptables/extensions/.NETLINK-test
+++ iptables/extensions/.NETLINK-test
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/net/ipv4/netfilter/ipt_NETLINK.c ] && echo NETLINK
--- iptables/extensions/.nth-test
+++ iptables/extensions/.nth-test
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if nth is applied.
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_nth.h ] && echo nth
--- iptables/extensions/.nth-test6
+++ iptables/extensions/.nth-test6
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if nth is applied.
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv6/ip6t_nth.h ] && echo nth
--- iptables/extensions/.osf-test
+++ iptables/extensions/.osf-test
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if osf is applied.
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_osf.h ] && echo osf
--- iptables/extensions/.psd-test
+++ iptables/extensions/.psd-test
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if psd is applied.
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_psd.h ] && echo psd
--- iptables/extensions/.random-test
+++ iptables/extensions/.random-test
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if random is applied.
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_random.h ] && echo random
--- iptables/extensions/.random-test6
+++ iptables/extensions/.random-test6
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if random is applied.
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv6/ip6t_random.h ] && echo random
--- iptables/extensions/.record-rpc-test
+++ iptables/extensions/.record-rpc-test
@@ -0,0 +1,3 @@
+#! /bin/sh
+# True if record rpc is applied.
+[ -f $KERNEL_DIR/net/ipv4/netfilter/ipt_record_rpc.c ] && echo record_rpc
--- iptables/extensions/.ROUTE-test
+++ iptables/extensions/.ROUTE-test
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/net/ipv4/netfilter/ipt_ROUTE.c ] && echo ROUTE
--- iptables/extensions/.ROUTE-test6
+++ iptables/extensions/.ROUTE-test6
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv6/ip6t_ROUTE.h ] && echo ROUTE
--- iptables/extensions/.TCPLAG-test
+++ iptables/extensions/.TCPLAG-test
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/net/ipv4/netfilter/ipt_TCPLAG.c ] && echo TCPLAG
--- iptables/extensions/.time-test
+++ iptables/extensions/.time-test
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if time is applied.
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_time.h ] && echo time
--- iptables/extensions/.u32-test
+++ iptables/extensions/.u32-test
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if u32 is applied.
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_u32.h ] && echo u32
--- iptables/extensions/libip6t_connbytes.c
+++ iptables/extensions/libip6t_connbytes.c
@@ -0,0 +1,204 @@
+/* Shared library add-on to iptables to add byte tracking support. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ip6tables.h>
+#include <linux/netfilter/nf_conntrack_common.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <linux/netfilter_ipv4/ipt_connbytes.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"connbytes v%s options:\n"
+" [!] --connbytes from:[to]\n"
+"     --connbytes-dir [original, reply, both]\n"
+"     --connbytes-mode [packets, bytes, avgpkt]\n"
+"\n", IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "connbytes", 1, 0, '1' },
+	{ "connbytes-dir", 1, 0, '2' },
+	{ "connbytes-mode", 1, 0, '3' },
+	{0}
+};
+
+static void
+parse_range(const char *arg, struct ipt_connbytes_info *si)
+{
+	char *colon,*p;
+
+	si->count.from = strtoul(arg,&colon,10);
+	if (*colon != ':') 
+		exit_error(PARAMETER_PROBLEM, "Bad range `%s'", arg);
+	si->count.to = strtoul(colon+1,&p,10);
+	if (p == colon+1) {
+		/* second number omited */
+		si->count.to = 0xffffffff;
+	}
+	if (si->count.from > si->count.to)
+		exit_error(PARAMETER_PROBLEM, "%llu should be less than %llu",
+			   si->count.from, si->count.to);
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ip6t_entry *entry,
+      unsigned int *nfcache,
+      struct ip6t_entry_match **match)
+{
+	struct ipt_connbytes_info *sinfo = (struct ipt_connbytes_info *)(*match)->data;
+	unsigned long i;
+
+	switch (c) {
+	case '1':
+		if (check_inverse(optarg, &invert, &optind, 0))
+			optind++;
+
+		parse_range(argv[optind-1], sinfo);
+		if (invert) {
+			i = sinfo->count.from;
+			sinfo->count.from = sinfo->count.to;
+			sinfo->count.to = i;
+		}
+		*flags |= 1;
+		break;
+	case '2':
+		if (!strcmp(optarg, "original"))
+			sinfo->direction = IPT_CONNBYTES_DIR_ORIGINAL;
+		else if (!strcmp(optarg, "reply"))
+			sinfo->direction = IPT_CONNBYTES_DIR_REPLY;
+		else if (!strcmp(optarg, "both"))
+			sinfo->direction = IPT_CONNBYTES_DIR_BOTH;
+		else
+			exit_error(PARAMETER_PROBLEM,
+				   "Unknown --connbytes-dir `%s'", optarg);
+
+		*flags |= 2;
+		break;
+	case '3':
+		if (!strcmp(optarg, "packets"))
+			sinfo->what = IPT_CONNBYTES_PKTS;
+		else if (!strcmp(optarg, "bytes"))
+			sinfo->what = IPT_CONNBYTES_BYTES;
+		else if (!strcmp(optarg, "avgpkt"))
+			sinfo->what = IPT_CONNBYTES_AVGPKT;
+		else
+			exit_error(PARAMETER_PROBLEM,
+				   "Unknown --connbytes-mode `%s'", optarg);
+		*flags |= 4;
+		break;
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+static void final_check(unsigned int flags)
+{
+	if (flags != 7)
+		exit_error(PARAMETER_PROBLEM, "You must specify `--connbytes'"
+			   "`--connbytes-dir' and `--connbytes-mode'");
+}
+
+static void print_mode(struct ipt_connbytes_info *sinfo)
+{
+	switch (sinfo->what) {
+		case IPT_CONNBYTES_PKTS:
+			fputs("packets ", stdout);
+			break;
+		case IPT_CONNBYTES_BYTES:
+			fputs("bytes ", stdout);
+			break;
+		case IPT_CONNBYTES_AVGPKT:
+			fputs("avgpkt ", stdout);
+			break;
+		default:
+			fputs("unknown ", stdout);
+			break;
+	}
+}
+
+static void print_direction(struct ipt_connbytes_info *sinfo)
+{
+	switch (sinfo->direction) {
+		case IPT_CONNBYTES_DIR_ORIGINAL:
+			fputs("original ", stdout);
+			break;
+		case IPT_CONNBYTES_DIR_REPLY:
+			fputs("reply ", stdout);
+			break;
+		case IPT_CONNBYTES_DIR_BOTH:
+			fputs("both ", stdout);
+			break;
+		default:
+			fputs("unknown ", stdout);
+			break;
+	}
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ip6t_ip6 *ip,
+      const struct ip6t_entry_match *match,
+      int numeric)
+{
+	struct ipt_connbytes_info *sinfo = (struct ipt_connbytes_info *)match->data;
+
+	if (sinfo->count.from > sinfo->count.to) 
+		printf("connbytes ! %llu:%llu ", sinfo->count.to,
+			sinfo->count.from);
+	else
+		printf("connbytes %llu:%llu ",sinfo->count.from,
+			sinfo->count.to);
+	print_mode(sinfo);
+
+	fputs("direction ", stdout);
+	print_direction(sinfo);
+}
+
+/* Saves the matchinfo in parsable form to stdout. */
+static void save(const struct ip6t_ip6 *ip, const struct ip6t_entry_match *match)
+{
+	struct ipt_connbytes_info *sinfo = (struct ipt_connbytes_info *)match->data;
+
+	if (sinfo->count.from > sinfo->count.to) 
+		printf("! --connbytes %llu:%llu ", sinfo->count.to,
+			sinfo->count.from);
+	else
+		printf("--connbytes %llu:%llu ", sinfo->count.from,
+			sinfo->count.to);
+
+	fputs("--connbytes-mode ", stdout);
+	print_mode(sinfo);
+
+	fputs("--connbytes-dir ", stdout);
+	print_direction(sinfo);
+}
+
+static struct ip6tables_match state = {
+	.next 		= NULL,
+	.name 		= "connbytes",
+	.version 	= IPTABLES_VERSION,
+	.size 		= IP6T_ALIGN(sizeof(struct ipt_connbytes_info)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct ipt_connbytes_info)),
+	.help		= &help,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save 		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_match6(&state);
+}
--- iptables/extensions/libip6t_connlimit.c
+++ iptables/extensions/libip6t_connlimit.c
@@ -0,0 +1,151 @@
+/* Shared library add-on to iptables to add connection limit support. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <getopt.h>
+#include <ip6tables.h>
+#include <linux/netfilter/xt_connlimit.h>
+
+/* Function which prints out usage message. */
+static void connlimit_help(void)
+{
+	printf(
+"connlimit v%s options:\n"
+"[!] --connlimit-above n        match if the number of existing "
+"                               connections is (not) above n\n"
+"    --connlimit-mask n         group hosts using mask\n"
+"\n", IPTABLES_VERSION);
+}
+
+static const struct option connlimit_opts[] = {
+	{"connlimit-above", 1, 0, '1'},
+	{"connlimit-mask",  1, 0, '2'},
+	{0},
+};
+
+static void connlimit_init(struct ip6t_entry_match *match, unsigned int *nfc)
+{
+	struct xt_connlimit_info *info = (void *)match->data;
+	info->v6_mask[0] =
+	info->v6_mask[1] =
+	info->v6_mask[2] =
+	info->v6_mask[3] = 0xFFFFFFFF;
+}
+
+static void prefix_to_netmask(u_int32_t *mask, unsigned int prefix_len)
+{
+	if (prefix_len == 0) {
+		mask[0] = mask[1] = mask[2] = mask[3] = 0;
+	} else if (prefix_len <= 32) {
+		mask[0] <<= 32 - prefix_len;
+		mask[1] = mask[2] = mask[3] = 0;
+	} else if (prefix_len <= 64) {
+		mask[1] <<= 32 - (prefix_len - 32);
+		mask[2] = mask[3] = 0;
+	} else if (prefix_len <= 96) {
+		mask[2] <<= 32 - (prefix_len - 64);
+		mask[3] = 0;
+	} else if (prefix_len <= 128) {
+		mask[3] <<= 32 - (prefix_len - 96);
+	}
+	mask[0] = htonl(mask[0]);
+	mask[1] = htonl(mask[1]);
+	mask[2] = htonl(mask[2]);
+	mask[3] = htonl(mask[3]);
+}
+
+static int connlimit_parse(int c, char **argv, int invert, unsigned int *flags,
+                           const struct ip6t_entry *entry,
+                           unsigned int *nfcache,
+                           struct ip6t_entry_match **match)
+{
+	struct xt_connlimit_info *info = (void *)(*match)->data;
+	char *err;
+	int i;
+
+	if (*flags & c)
+		exit_error(PARAMETER_PROBLEM,
+		           "--connlimit-above and/or --connlimit-mask may "
+			   "only be given once");
+
+	switch (c) {
+	case 1:
+		check_inverse(optarg, &invert, &optind, 0);
+		info->limit   = strtoul(argv[optind-1], NULL, 0);
+		info->inverse = invert;
+		break;
+	case 2:
+		i = strtoul(argv[optind-1], &err, 0);
+		if (i > 128 || *err != '\0')
+			exit_error(PARAMETER_PROBLEM,
+				"--connlimit-mask must be between 0 and 128");
+		prefix_to_netmask(info->v6_mask, i);
+		break;
+	default:
+		return 0;
+	}
+
+	*flags |= c;
+	return 1;
+}
+
+/* Final check */
+static void connlimit_check(unsigned int flags)
+{
+	if (!(flags & 1))
+		exit_error(PARAMETER_PROBLEM,
+		           "You must specify \"--connlimit-above\"");
+}
+
+static unsigned int count_bits(const u_int32_t *mask)
+{
+	unsigned int bits = 0, i;
+	u_int32_t tmp[4];
+
+	for (i = 0; i < 4; ++i)
+		for (tmp[i] = ~ntohl(mask[i]); tmp[i] != 0; tmp[i] >>= 1)
+			++bits;
+	return 128 - bits;
+}
+
+/* Prints out the matchinfo. */
+static void connlimit_print(const struct ip6t_ip6 *ip,
+                            const struct ip6t_entry_match *match, int numeric)
+{
+	const struct xt_connlimit_info *info = (const void *)match->data;
+
+	printf("#conn/%u %s %u ", count_bits(info->v6_mask),
+	       info->inverse ? "<=" : ">", info->limit);
+}
+
+/* Saves the matchinfo in parsable form to stdout. */
+static void connlimit_save(const struct ip6t_ip6 *ip,
+                           const struct ip6t_entry_match *match)
+{
+	const struct xt_connlimit_info *info = (const void *)match->data;
+
+	printf("%s--connlimit-above %u --connlimit-mask %u ",
+	       info->inverse ? "! " : "", info->limit,
+	       count_bits(info->v6_mask));
+}
+
+static struct ip6tables_match connlimit_reg = {
+	.name          = "connlimit",
+	.version       = IPTABLES_VERSION,
+	.size          = IP6T_ALIGN(sizeof(struct xt_connlimit_info)),
+	.userspacesize = offsetof(struct xt_connlimit_info, data),
+	.help          = connlimit_help,
+	.init          = connlimit_init,
+	.parse         = connlimit_parse,
+	.final_check   = connlimit_check,
+	.print         = connlimit_print,
+	.save          = connlimit_save,
+	.extra_opts    = connlimit_opts,
+};
+
+void _init(void)
+{
+	register_match6(&connlimit_reg);
+}
--- iptables/extensions/libip6t_dscp.c
+++ iptables/extensions/libip6t_dscp.c
@@ -0,0 +1,172 @@
+/* Shared library add-on to iptables for DSCP
+ *
+ * (C) 2002 by Harald Welte <laforge@gnumonks.org>
+ *
+ * This program is distributed under the terms of GNU GPL v2, 1991
+ *
+ * libipt_dscp.c borrowed heavily from libipt_tos.c
+ *
+ * --class support added by Iain Barnes
+ * 
+ * For a list of DSCP codepoints see 
+ * http://www.iana.org/assignments/dscp-registry
+ *
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <ip6tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <linux/netfilter/xt_dscp.h>
+
+/* This is evil, but it's my code - HW*/
+#include "libipt_dscp_helper.c"
+
+static void help(void) 
+{
+	printf(
+"DSCP match v%s options\n"
+"[!] --dscp value		Match DSCP codepoint with numerical value\n"
+"  		                This value can be in decimal (ex: 32)\n"
+"               		or in hex (ex: 0x20)\n"
+"[!] --dscp-class name		Match the DiffServ class. This value may\n"
+"				be any of the BE,EF, AFxx or CSx classes\n"
+"\n"
+"				These two options are mutually exclusive !\n"
+				, IPTABLES_VERSION
+);
+}
+
+static struct option opts[] = {
+	{ "dscp", 1, 0, 'F' },
+	{ "dscp-class", 1, 0, 'G' },
+	{ 0 }
+};
+
+static void
+parse_dscp(const char *s, struct xt_dscp_info *dinfo)
+{
+	unsigned int dscp;
+       
+	if (string_to_number(s, 0, 255, &dscp) == -1)
+		exit_error(PARAMETER_PROBLEM,
+			   "Invalid dscp `%s'\n", s);
+
+	if (dscp > XT_DSCP_MAX)
+		exit_error(PARAMETER_PROBLEM,
+			   "DSCP `%d` out of range\n", dscp);
+
+    	dinfo->dscp = (u_int8_t )dscp;
+    	return;
+}
+
+
+static void
+parse_class(const char *s, struct xt_dscp_info *dinfo)
+{
+	unsigned int dscp = class_to_dscp(s);
+
+	/* Assign the value */
+	dinfo->dscp = (u_int8_t)dscp;
+}
+
+
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ip6t_entry *entry,
+      unsigned int *nfcache,
+      struct ip6t_entry_match **match)
+{
+	struct xt_dscp_info *dinfo
+		= (struct xt_dscp_info *)(*match)->data;
+
+	switch (c) {
+	case 'F':
+		if (*flags)
+			exit_error(PARAMETER_PROBLEM,
+			           "DSCP match: Only use --dscp ONCE!");
+		check_inverse(optarg, &invert, &optind, 0);
+		parse_dscp(argv[optind-1], dinfo);
+		if (invert)
+			dinfo->invert = 1;
+		*flags = 1;
+		break;
+
+	case 'G':
+		if (*flags)
+			exit_error(PARAMETER_PROBLEM,
+					"DSCP match: Only use --dscp-class ONCE!");
+		check_inverse(optarg, &invert, &optind, 0);
+		parse_class(argv[optind - 1], dinfo);
+		if (invert)
+			dinfo->invert = 1;
+		*flags = 1;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+static void
+final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM,
+		           "DSCP match: Parameter --dscp is required");
+}
+
+static void
+print_dscp(u_int8_t dscp, int invert, int numeric)
+{
+	if (invert)
+		fputc('!', stdout);
+
+ 	printf("0x%02x ", dscp);
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ip6t_ip6 *ip,
+      const struct ip6t_entry_match *match,
+      int numeric)
+{
+	const struct xt_dscp_info *dinfo =
+		(const struct xt_dscp_info *)match->data;
+	printf("DSCP match ");
+	print_dscp(dinfo->dscp, dinfo->invert, numeric);
+}
+
+/* Saves the union ipt_matchinfo in parsable form to stdout. */
+static void
+save(const struct ip6t_ip6 *ip, const struct ip6t_entry_match *match)
+{
+	const struct xt_dscp_info *dinfo =
+		(const struct xt_dscp_info *)match->data;
+
+	printf("--dscp ");
+	print_dscp(dinfo->dscp, dinfo->invert, 1);
+}
+
+static struct ip6tables_match dscp = { 
+	.next 		= NULL,
+	.name 		= "dscp",
+	.version 	= IPTABLES_VERSION,
+	.size 		= IP6T_ALIGN(sizeof(struct xt_dscp_info)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct xt_dscp_info)),
+	.help		= &help,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_match6(&dscp);
+}
--- iptables/extensions/libip6t_fuzzy.c
+++ iptables/extensions/libip6t_fuzzy.c
@@ -0,0 +1,156 @@
+/*
+   Shared library add-on to iptables to add match support for the fuzzy match.
+
+   This file is distributed under the terms of the GNU General Public
+   License (GPL). Copies of the GPL can be obtained from:
+   ftp://prep.ai.mit.edu/pub/gnu/GPL
+
+2002-08-07 Hime Aguiar e Oliveira Jr. <hime@engineer.com> : Initial version.
+2003-04-08 Maciej Soltysiak <solt@dns.toxicfilms.tv> : IPv6 Port
+2003-06-09 Hime Aguiar e Oliveira Jr. <hime@engineer.com> : Bug corrections in
+the save function , thanks to information given by Jean-Francois Patenaude.
+
+*/
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <syslog.h>
+#include <getopt.h>
+#include <ip6tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <linux/netfilter_ipv6/ip6t_fuzzy.h>
+
+
+static void
+help(void)
+{
+	printf(
+"fuzzy v%s options:\n"
+"                      --lower-limit number (in packets per second)\n"
+"                      --upper-limit number\n"
+,IPTABLES_VERSION);
+};
+
+static struct option opts[] = {
+	{ .name = "lower-limit", .has_arg = 1, .flag = 0, .val = '1' },
+	{ .name = "upper-limit", .has_arg = 1, .flag = 0, .val = '2' },
+	{ .name = 0 }
+};
+
+/* Initialize data structures */
+static void
+init(struct ip6t_entry_match *m, unsigned int *nfcache)
+{
+	struct ip6t_fuzzy_info *presentinfo = (struct ip6t_fuzzy_info *)(m)->data;
+	/*
+	 * Default rates ( I'll improve this very soon with something based
+	 * on real statistics of the running machine ) .
+	*/
+
+	presentinfo->minimum_rate = 1000;
+	presentinfo->maximum_rate = 2000;
+}
+
+#define IP6T_FUZZY_OPT_MINIMUM	0x01
+#define IP6T_FUZZY_OPT_MAXIMUM	0x02
+
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ip6t_entry *entry,
+      unsigned int *nfcache,
+      struct ip6t_entry_match **match)
+{
+	struct ip6t_fuzzy_info *fuzzyinfo =
+		(struct ip6t_fuzzy_info *)(*match)->data;
+
+	u_int32_t num;
+
+	switch (c) {
+
+	case '1':
+
+	if (invert)
+	       	exit_error(PARAMETER_PROBLEM,"Can't specify ! --lower-limit");
+
+	if (*flags & IP6T_FUZZY_OPT_MINIMUM)
+       	      exit_error(PARAMETER_PROBLEM,"Can't specify --lower-limit twice");
+
+	if (string_to_number(optarg,1,MAXFUZZYRATE,&num) == -1 || num < 1)
+			exit_error(PARAMETER_PROBLEM,"BAD --lower-limit");
+
+		fuzzyinfo->minimum_rate = num ;
+
+		*flags |= IP6T_FUZZY_OPT_MINIMUM;
+
+		break;
+
+	case '2':
+
+	if (invert)
+		exit_error(PARAMETER_PROBLEM,"Can't specify ! --upper-limit");
+
+	if (*flags & IP6T_FUZZY_OPT_MAXIMUM)
+	   exit_error(PARAMETER_PROBLEM,"Can't specify --upper-limit twice");
+
+	if (string_to_number(optarg,1,MAXFUZZYRATE,&num) == -1 || num < 1)
+		exit_error(PARAMETER_PROBLEM,"BAD --upper-limit");
+
+		fuzzyinfo->maximum_rate = num;
+
+		*flags |= IP6T_FUZZY_OPT_MAXIMUM;
+
+		break ;
+
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+static void final_check(unsigned int flags)
+{
+}
+
+static void
+print(const struct ip6t_ip6 *ipv6,
+      const struct ip6t_entry_match *match,
+      int numeric)
+{
+	const struct ip6t_fuzzy_info *fuzzyinfo
+		= (const struct ip6t_fuzzy_info *)match->data;
+
+	printf(" fuzzy: lower limit = %u pps - upper limit = %u pps ",
+		fuzzyinfo->minimum_rate, fuzzyinfo->maximum_rate);
+}
+
+/* Saves the union ip6t_targinfo in parsable form to stdout. */
+static void
+save(const struct ip6t_ip6 *ipv6, const struct ip6t_entry_match *match)
+{
+	const struct ip6t_fuzzy_info *fuzzyinfo
+		= (const struct ip6t_fuzzy_info *)match->data;
+
+	printf("--lower-limit %u --upper-limit %u ",
+		fuzzyinfo->minimum_rate, fuzzyinfo->maximum_rate);
+}
+
+struct ip6tables_match fuzzy_match = {
+	.name          = "fuzzy",
+	.version       = IPTABLES_VERSION,
+	.size          = IP6T_ALIGN(sizeof(struct ip6t_fuzzy_info)),
+	.userspacesize = IP6T_ALIGN(sizeof(struct ip6t_fuzzy_info)),
+	.help          = &help,
+	.init          = &init,
+	.parse         = &parse,
+	.final_check   = &final_check,
+	.print         = &print,
+	.save          = &save,
+	.extra_opts    = opts
+};
+
+void _init(void)
+{
+	register_match6(&fuzzy_match);
+}
--- iptables/extensions/libip6t_fuzzy.man
+++ iptables/extensions/libip6t_fuzzy.man
@@ -0,0 +1,7 @@
+This module matches a rate limit based on a fuzzy logic controller [FLC]
+.TP
+.BI "--lower-limit " "number"
+Specifies the lower limit (in packets per second).
+.TP
+.BI "--upper-limit " "number"
+Specifies the upper limit (in packets per second).
--- iptables/extensions/libip6t_IMQ.c
+++ iptables/extensions/libip6t_IMQ.c
@@ -0,0 +1,101 @@
+/* Shared library add-on to iptables to add IMQ target support. */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <ip6tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <linux/netfilter_ipv6/ip6t_IMQ.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"IMQ target v%s options:\n"
+"  --todev <N>		enqueue to imq<N>, defaults to 0\n", 
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "todev", 1, 0, '1' },
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ip6t_entry_target *t, unsigned int *nfcache)
+{
+	struct ip6t_imq_info *mr = (struct ip6t_imq_info*)t->data;
+
+	mr->todev = 0;
+	*nfcache |= NFC_UNKNOWN;
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ip6t_entry *entry,
+      struct ip6t_entry_target **target)
+{
+	struct ip6t_imq_info *mr = (struct ip6t_imq_info*)(*target)->data;
+	
+	switch(c) {
+	case '1':
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --todev");
+		mr->todev=atoi(optarg);
+		break;
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+static void
+final_check(unsigned int flags)
+{
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ip6t_ip6 *ip,
+      const struct ip6t_entry_target *target,
+      int numeric)
+{
+	struct ip6t_imq_info *mr = (struct ip6t_imq_info*)target->data;
+
+	printf("IMQ: todev %u ", mr->todev);
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const struct ip6t_ip6 *ip, const struct ip6t_entry_target *target)
+{
+	struct ip6t_imq_info *mr = (struct ip6t_imq_info*)target->data;
+
+	printf("--todev %u", mr->todev);
+}
+
+static struct ip6tables_target imq = {
+	.next		= NULL,
+	.name		= "IMQ",
+	.version	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(struct ip6t_imq_info)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct ip6t_imq_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_target6(&imq);
+}
--- iptables/extensions/libip6t_iprange.c
+++ iptables/extensions/libip6t_iprange.c
@@ -0,0 +1,186 @@
+/* Shared library add-on to iptables to add IP range matching support. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <arpa/inet.h>
+
+#include <ip6tables.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <linux/netfilter/xt_iprange.h>
+
+enum {
+	F_SRCIP = 1 << 0,
+	F_DSTIP = 1 << 1,
+};
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"iprange match v%s options:\n"
+"[!] --src-range ip6-ip6      Match source IPv6 in the specified range\n"
+"[!] --dst-range ip6-ip6      Match destination IPv6 in the specified range\n"
+"\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "src-range", 1, 0, '1' },
+	{ "dst-range", 1, 0, '2' },
+	{0}
+};
+
+static struct in6_addr *numeric_to_ip6addr(const char *num)
+{
+	static struct in6_addr ap;
+	int err;
+
+	if ((err = inet_pton(AF_INET6, num, &ap)) == 1)
+		return &ap;
+	return NULL;
+}
+
+static const char *ip6addr_to_numeric(const struct in6_addr *addrp)
+{
+	/* 0000:0000:0000:0000:0000:000.000.000.000
+	 * 0000:0000:0000:0000:0000:0000:0000:0000 */
+	static char buf[50+1];
+	return inet_ntop(AF_INET6, addrp, buf, sizeof(buf));
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ip6t_entry *entry,
+      unsigned int *nfcache,
+      struct ip6t_entry_match **match)
+{
+	struct xt_iprange_mtinfo *info = (void *)(*match)->data;
+	const struct in6_addr *ia;
+	char *end;
+
+	switch (c) {
+	case '1': /* --src-range */
+		end = strchr(optarg, '-');
+		if (end == NULL)
+			exit_error(PARAMETER_PROBLEM, "iprange match: Bad IP range `%s'\n", optarg);
+		*end = '\0';
+		ia = numeric_to_ip6addr(optarg);
+		if (ia == NULL)
+			exit_error(PARAMETER_PROBLEM, "iprange match: Bad IP address `%s'\n", optarg);
+		memcpy(&info->src_min.in, ia, sizeof(*ia));
+		ia = numeric_to_ip6addr(end + 1);
+		if (ia == NULL)
+			exit_error(PARAMETER_PROBLEM, "iprange match: Bad IP address `%s'\n", end + 1);
+		memcpy(&info->src_max.in, ia, sizeof(*ia));
+		info->flags |= IPRANGE_SRC;
+		if (invert)
+			info->flags |= IPRANGE_SRC_INV;
+		*flags |= F_SRCIP;
+		return 1;
+
+	case '2': /* --dst-range */
+		end = strchr(optarg, '-');
+		if (end == NULL)
+			exit_error(PARAMETER_PROBLEM, "iprange match: Bad IP range `%s'\n", optarg);
+		*end = '\0';
+		ia = numeric_to_ip6addr(optarg);
+		if (ia == NULL)
+			exit_error(PARAMETER_PROBLEM, "iprange match: Bad IP address `%s'\n", optarg);
+		memcpy(&info->dst_min.in, ia, sizeof(*ia));
+		ia = numeric_to_ip6addr(end + 1);
+		if (ia == NULL)
+			exit_error(PARAMETER_PROBLEM, "iprange match: Bad IP address `%s'\n", end + 1);
+		memcpy(&info->dst_max.in, ia, sizeof(*ia));
+		info->flags |= IPRANGE_DST;
+		if (invert)
+			info->flags |= IPRANGE_DST_INV;
+		*flags |= F_DSTIP;
+		return 1;
+	}
+	return 0;
+}
+
+/* Final check; must have specified --src-range or --dst-range. */
+static void
+final_check(unsigned int flags)
+{
+	if (flags == 0)
+		exit_error(PARAMETER_PROBLEM,
+			   "iprange match: You must specify `--src-range' or `--dst-range'");
+}
+
+/* Prints out the info. */
+static void
+print(const struct ip6t_ip6 *ip,
+      const struct ip6t_entry_match *match,
+      int numeric)
+{
+	const struct xt_iprange_mtinfo *info = (const void *)match->data;
+
+	if (info->flags & IPRANGE_SRC) {
+		printf("source IP range ");
+		if (info->flags & IPRANGE_SRC_INV)
+			printf("! ");
+		/*
+		 * ipaddr_to_numeric() uses a static buffer, so cannot
+		 * combine the printf() calls.
+		 */
+		printf("%s", ip6addr_to_numeric(&info->src_min.in6));
+		printf("-%s ", ip6addr_to_numeric(&info->src_max.in6));
+	}
+	if (info->flags & IPRANGE_DST) {
+		printf("destination IP range ");
+		if (info->flags & IPRANGE_DST_INV)
+			printf("! ");
+		printf("%s", ip6addr_to_numeric(&info->dst_min.in6));
+		printf("-%s ", ip6addr_to_numeric(&info->dst_max.in6));
+	}
+}
+
+/* Saves the union ipt_info in parsable form to stdout. */
+static void
+save(const struct ip6t_ip6 *ip, const struct ip6t_entry_match *match)
+{
+#ifdef IPTABLES_SAVE
+	const struct xt_iprange_mtinfo *info = (const void *)match->data;
+
+	if (info->flags & IPRANGE_SRC) {
+		if (info->flags & IPRANGE_SRC_INV)
+			printf("! ");
+		printf("--src-range %s", ip6addr_to_numeric(&info->src_min.in6));
+		printf("-%s ", ip6addr_to_numeric(&info->src_max.in6));
+	}
+	if (info->flags & IPRANGE_DST) {
+		if (info->flags & IPRANGE_DST_INV)
+			printf("! ");
+		printf("--dst-range %s", ip6addr_to_numeric(&info->dst_min.in6));
+		printf("-%s ", ip6addr_to_numeric(&info->dst_max.in6));
+	}
+#endif
+}
+
+static struct ip6tables_match iprange = { 
+	.next		= NULL,
+	.name		= "iprange",
+	.revision	= 1,
+	.version	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(struct xt_iprange_mtinfo)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct xt_iprange_mtinfo)),
+	.help		= &help,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_match6(&iprange);
+}
--- iptables/extensions/libip6t_nth.c
+++ iptables/extensions/libip6t_nth.c
@@ -0,0 +1,229 @@
+/* 
+   Shared library add-on to iptables to add match support for every Nth packet
+   
+   This file is distributed under the terms of the GNU General Public
+   License (GPL). Copies of the GPL can be obtained from:
+   ftp://prep.ai.mit.edu/pub/gnu/GPL
+
+   2001-07-17 Fabrice MARIE <fabrice@netfilter.org> : initial development.
+   2001-09-20 Richard Wagner (rwagner@cloudnet.com)
+        * added support for multiple counters
+        * added support for matching on individual packets
+          in the counter cycle
+*/
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <syslog.h>
+#include <getopt.h>
+#include <ip6tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <linux/netfilter_ipv6/ip6t_nth.h>
+
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"nth v%s options:\n"
+"   --every     Nth              Match every Nth packet\n"
+"  [--counter]  num              Use counter 0-%u (default:0)\n"
+"  [--start]    num              Initialize the counter at the number 'num'\n"
+"                                instead of 0. Must be between 0 and Nth-1\n"
+"  [--packet]   num              Match on 'num' packet. Must be between 0\n"
+"                                and Nth-1.\n\n"
+"                                If --packet is used for a counter than\n"
+"                                there must be Nth number of --packet\n"
+"                                rules, covering all values between 0 and\n"
+"                                Nth-1 inclusively.\n",
+IPTABLES_VERSION, IP6T_NTH_NUM_COUNTERS-1);
+}
+
+static struct option opts[] = {
+	{ "every", 1, 0, '1' },
+	{ "start", 1, 0, '2' },
+        { "counter", 1, 0, '3' },
+        { "packet", 1, 0, '4' },
+	{ 0 }
+};
+
+#define IP6T_NTH_OPT_EVERY	0x01
+#define IP6T_NTH_OPT_NOT_EVERY	0x02
+#define IP6T_NTH_OPT_START	0x04
+#define IP6T_NTH_OPT_COUNTER     0x08
+#define IP6T_NTH_OPT_PACKET      0x10
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ip6t_entry *entry,
+      unsigned int *nfcache,
+      struct ip6t_entry_match **match)
+{
+	struct ip6t_nth_info *nthinfo = (struct ip6t_nth_info *)(*match)->data;
+	unsigned int num;
+
+	switch (c) {
+	case '1':
+		/* check for common mistakes... */
+		if ((!invert) && (*flags & IP6T_NTH_OPT_EVERY))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --every twice");
+		if (invert && (*flags & IP6T_NTH_OPT_NOT_EVERY))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --every twice");
+		if ((!invert) && (*flags & IP6T_NTH_OPT_NOT_EVERY))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --every with ! --every");
+		if (invert && (*flags & IP6T_NTH_OPT_EVERY))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --every with --every");
+
+		/* Remember, this function will interpret a leading 0 to be 
+		   Octal, a leading 0x to be hexdecimal... */
+                if (string_to_number(optarg, 2, 100, &num) == -1 || num < 2)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --every `%s', must be between 2 and 100", optarg);
+
+		/* assign the values */
+		nthinfo->every = num-1;
+		nthinfo->startat = 0;
+                nthinfo->packet = 0xFF;
+                if(!(*flags & IP6T_NTH_OPT_EVERY))
+                {
+                        nthinfo->counter = 0;
+                }
+		if (invert)
+		{
+			*flags |= IP6T_NTH_OPT_NOT_EVERY;
+			nthinfo->not = 1;
+		}
+		else
+		{
+			*flags |= IP6T_NTH_OPT_EVERY;
+			nthinfo->not = 0;
+		}
+		break;
+	case '2':
+		/* check for common mistakes... */
+		if (!((*flags & IP6T_NTH_OPT_EVERY) ||
+		      (*flags & IP6T_NTH_OPT_NOT_EVERY)))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --start before --every");
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify with ! --start");
+		if (*flags & IP6T_NTH_OPT_START)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --start twice");
+		if (string_to_number(optarg, 0, nthinfo->every, &num) == -1)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --start `%s', must between 0 and %u", optarg, nthinfo->every);
+		*flags |= IP6T_NTH_OPT_START;
+		nthinfo->startat = num;
+		break;
+        case '3':
+                /* check for common mistakes... */
+                if (invert)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify with ! --counter");
+                if (*flags & IP6T_NTH_OPT_COUNTER)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --counter twice");
+                if (string_to_number(optarg, 0, IP6T_NTH_NUM_COUNTERS-1, &num) == -1)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --counter `%s', must between 0 and %u", optarg, IP6T_NTH_NUM_COUNTERS-1);
+                /* assign the values */
+                *flags |= IP6T_NTH_OPT_COUNTER;
+                nthinfo->counter = num;
+                break;
+        case '4':
+                /* check for common mistakes... */
+                if (!((*flags & IP6T_NTH_OPT_EVERY) ||
+                      (*flags & IP6T_NTH_OPT_NOT_EVERY)))
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --packet before --every");
+                if ((*flags & IP6T_NTH_OPT_NOT_EVERY))
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --packet with ! --every");
+                if (invert)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify with ! --packet");
+                if (*flags & IP6T_NTH_OPT_PACKET)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --packet twice");
+                if (string_to_number(optarg, 0, nthinfo->every, &num) == -1)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --packet `%s', must between 0 and %u", optarg, nthinfo->every);
+                *flags |= IP6T_NTH_OPT_PACKET;
+                nthinfo->packet = num;
+                break;
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+/* Final check; nothing. */
+static void final_check(unsigned int flags)
+{
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ip6t_ip6 *ip,
+      const struct ip6t_entry_match *match,
+      int numeric)
+{
+	const struct ip6t_nth_info *nthinfo
+		= (const struct ip6t_nth_info *)match->data;
+
+	if (nthinfo->not == 1)
+		printf(" !");
+	printf("every %uth ", (nthinfo->every +1));
+	if (nthinfo->counter != 0) 
+		printf("counter #%u ", (nthinfo->counter));
+        if (nthinfo->packet != 0xFF)
+                printf("packet #%u ", nthinfo->packet);
+	if (nthinfo->startat != 0)
+		printf("start at %u ", nthinfo->startat);
+}
+
+/* Saves the union ip6t_targinfo in parsable form to stdout. */
+static void
+save(const struct ip6t_ip6 *ip, const struct ip6t_entry_match *match)
+{
+	const struct ip6t_nth_info *nthinfo
+		= (const struct ip6t_nth_info *)match->data;
+
+	if (nthinfo->not == 1)
+		printf("! ");
+	printf("--every %u ", (nthinfo->every +1));
+	printf("--counter %u ", (nthinfo->counter));
+	if (nthinfo->startat != 0)
+		printf("--start %u ", nthinfo->startat );
+        if (nthinfo->packet != 0xFF)
+                printf("--packet %u ", nthinfo->packet );
+}
+
+struct ip6tables_match nth = {
+	.name 		= "nth",
+	.version	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(struct ip6t_nth_info)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct ip6t_nth_info)),
+	.help		= &help,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts,
+};
+
+void _init(void)
+{
+	register_match6(&nth);
+}
--- iptables/extensions/libip6t_nth.man
+++ iptables/extensions/libip6t_nth.man
@@ -0,0 +1,14 @@
+This module matches every `n'th packet
+.TP
+.BI "--every " "value"
+Match every `value' packet
+.TP
+.BI "[" "--counter " "num" "]"
+Use internal counter number `num'.  Default is `0'.
+.TP
+.BI "[" "--start " "num" "]"
+Initialize the counter at the number `num' insetad of `0'.  Most between `0'
+and `value'-1.
+.TP
+.BI "[" "--packet " "num" "]"
+Match on `num' packet.  Most be between `0' and `value'-1.
--- iptables/extensions/libip6t_random.c
+++ iptables/extensions/libip6t_random.c
@@ -0,0 +1,150 @@
+/* 
+   Shared library add-on to iptables to add match support for random match.
+   
+   This file is distributed under the terms of the GNU General Public
+   License (GPL). Copies of the GPL can be obtained from:
+   ftp://prep.ai.mit.edu/pub/gnu/GPL
+
+   2001-10-14 Fabrice MARIE <fabrice@netfilter.org> : initial development.
+   2003-04-30 Maciej Soltysiak <solt@dns.toxicfilms.tv> : IPv6 port.
+*/
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <syslog.h>
+#include <getopt.h>
+#include <ip6tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <linux/netfilter_ipv6/ip6t_random.h>
+
+/**
+ * The kernel random routing returns numbers between 0 and 255.
+ * To ease the task of the user in choosing the probability
+ * of matching, we want him to be able to use percentages.
+ * Therefore we have to accept numbers in percentage here,
+ * turn them into number between 0 and 255 for the kernel module,
+ * and turn them back to percentages when we print/save
+ * the rule.
+ */
+
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"random v%s options:\n"
+"  [--average]     percent      The probability in percentage of the match\n"
+"                               If ommited, a probability of 50%% percent is set.\n"
+"                               Percentage must be within : 1 <= percent <= 99.\n\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "average", 1, 0, '1' },
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ip6t_entry_match *m, unsigned int *nfcache)
+{
+	struct ip6t_rand_info *randinfo = (struct ip6t_rand_info *)(m)->data;
+
+	/* We assign the average to be 50 which is our default value */
+	/* 50 * 2.55 = 128 */
+	randinfo->average = 128;
+}
+
+#define IP6T_RAND_OPT_AVERAGE	0x01
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ip6t_entry *entry,
+      unsigned int *nfcache,
+      struct ip6t_entry_match **match)
+{
+	struct ip6t_rand_info *randinfo = (struct ip6t_rand_info *)(*match)->data;
+	unsigned int num;
+
+	switch (c) {
+	case '1':
+		/* check for common mistakes... */
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --average");
+		if (*flags & IP6T_RAND_OPT_AVERAGE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --average twice");
+
+		/* Remember, this function will interpret a leading 0 to be 
+		   Octal, a leading 0x to be hexdecimal... */
+                if (string_to_number(optarg, 1, 99, &num) == -1 || num < 1)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --average `%s', must be between 1 and 99", optarg);
+
+		/* assign the values */
+		randinfo->average = (int)(num * 2.55);
+		*flags |= IP6T_RAND_OPT_AVERAGE;
+		break;
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+/* Final check; nothing. */
+static void final_check(unsigned int flags)
+{
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ip6t_ip6 *ip,
+      const struct ip6t_entry_match *match,
+      int numeric)
+{
+	const struct ip6t_rand_info *randinfo
+		= (const struct ip6t_rand_info *)match->data;
+	div_t result = div((randinfo->average*100), 255);
+	if (result.rem > 127)  /* round up... */
+		++result.quot;
+
+	printf(" random %u%% ", result.quot);
+}
+
+/* Saves the union ip6t_targinfo in parsable form to stdout. */
+static void
+save(const struct ip6t_ip6 *ip, const struct ip6t_entry_match *match)
+{
+	const struct ip6t_rand_info *randinfo
+		= (const struct ip6t_rand_info *)match->data;
+	div_t result = div((randinfo->average *100), 255);
+	if (result.rem > 127)  /* round up... */
+		++result.quot;
+
+	printf("--average %u ", result.quot);
+}
+
+struct ip6tables_match rand_match = {
+	.name		= "random",
+	.version	= IPTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(struct ip6t_rand_info)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct ip6t_rand_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts,
+};
+
+void _init(void)
+{
+	register_match6(&rand_match);
+}
--- iptables/extensions/libip6t_random.man
+++ iptables/extensions/libip6t_random.man
@@ -0,0 +1,4 @@
+This module randomly matches a certain percentage of all packets.
+.TP
+.BI "--average " "percent"
+Matches the given percentage.  If omitted, a probability of 50% is set. 
--- iptables/extensions/libip6t_recent.c
+++ iptables/extensions/libip6t_recent.c
@@ -0,0 +1,245 @@
+/* Shared library add-on to iptables to add recent matching support. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <ip6tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <linux/netfilter/xt_recent.h>
+
+#ifndef XTABLES_VERSION
+#define XTABLES_VERSION IPTABLES_VERSION
+#endif
+
+#ifdef IPT_LIB_DIR
+#define xtables_target ip6tables_target
+#define xtables_register_target register_target6
+#endif
+
+/* Need these in order to not fail when compiling against an older kernel. */
+#ifndef RECENT_NAME
+#define RECENT_NAME	"ip6t_recent"
+#endif /* RECENT_NAME */
+
+#ifndef RECENT_VER
+#define RECENT_VER	"unknown"
+#endif /* RECENT_VER */
+
+/* Options for this module */
+static struct option opts[] = {
+	{ .name = "set",      .has_arg = 0, .flag = 0, .val = 201 }, 
+	{ .name = "rcheck",   .has_arg = 0, .flag = 0, .val = 202 }, 
+	{ .name = "update",   .has_arg = 0, .flag = 0, .val = 203 },
+	{ .name = "seconds",  .has_arg = 1, .flag = 0, .val = 204 }, 
+	{ .name = "hitcount", .has_arg = 1, .flag = 0, .val = 205 },
+	{ .name = "remove",   .has_arg = 0, .flag = 0, .val = 206 },
+	{ .name = "rttl",     .has_arg = 0, .flag = 0, .val = 207 },
+	{ .name = "name",     .has_arg = 1, .flag = 0, .val = 208 },
+	{ .name = "rsource",  .has_arg = 0, .flag = 0, .val = 209 },
+	{ .name = "rdest",    .has_arg = 0, .flag = 0, .val = 210 },
+	{ .name = 0,          .has_arg = 0, .flag = 0, .val = 0   }
+};
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"recent v%s options:\n"
+"[!] --set                       Add source address to list, always matches.\n"
+"[!] --rcheck                    Match if source address in list.\n"
+"[!] --update                    Match if source address in list, also update last-seen time.\n"
+"[!] --remove                    Match if source address in list, also removes that address from list.\n"
+"    --seconds seconds           For check and update commands above.\n"
+"                                Specifies that the match will only occur if source address last seen within\n"
+"                                the last 'seconds' seconds.\n"
+"    --hitcount hits             For check and update commands above.\n"
+"                                Specifies that the match will only occur if source address seen hits times.\n"
+"                                May be used in conjunction with the seconds option.\n"
+"    --rttl                      For check and update commands above.\n"
+"                                Specifies that the match will only occur if the source address and the TTL\n"
+"                                match between this packet and the one which was set.\n"
+"                                Useful if you have problems with people spoofing their source address in order\n"
+"                                to DoS you via this module.\n"
+"    --name name                 Name of the recent list to be used.  DEFAULT used if none given.\n"
+"    --rsource                   Match/Save the source address of each packet in the recent list table (default).\n"
+"    --rdest                     Match/Save the destination address of each packet in the recent list table.\n"
+RECENT_NAME " " RECENT_VER ": Stephen Frost <sfrost@snowman.net>.  http://snowman.net/projects/ipt_recent/\n"
+,
+IPTABLES_VERSION);
+
+}
+  
+/* Initialize the match. */
+static void
+init(struct ip6t_entry_match *match, unsigned int *nfcache)
+{
+	struct xt_recent_mtinfo *info = (struct xt_recent_mtinfo *)(match)->data;
+
+
+	strncpy(info->name,"DEFAULT",XT_RECENT_NAME_LEN);
+	/* eventhough XT_RECENT_NAME_LEN is currently defined as 200,
+	 * better be safe, than sorry */
+	info->name[XT_RECENT_NAME_LEN-1] = '\0';
+	info->side = XT_RECENT_SOURCE;
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ip6t_entry *entry,
+      unsigned int *nfcache,
+      struct ip6t_entry_match **match)
+{
+	struct xt_recent_mtinfo *info = (struct xt_recent_mtinfo *)(*match)->data;
+	switch (c) {
+		case 201:
+			if (*flags) exit_error(PARAMETER_PROBLEM,
+					"recent: only one of `--set', `--rcheck' "
+					"`--update' or `--remove' may be set");
+			check_inverse(optarg, &invert, &optind, 0);
+			info->check_set |= XT_RECENT_SET;
+			if (invert) info->invert = 1;
+			*flags = 1;
+			break;
+			
+		case 202:
+			if (*flags) exit_error(PARAMETER_PROBLEM,
+					"recent: only one of `--set', `--rcheck' "
+					"`--update' or `--remove' may be set");
+			check_inverse(optarg, &invert, &optind, 0);
+			info->check_set |= XT_RECENT_CHECK;
+			if(invert) info->invert = 1;
+			*flags = 1;
+			break;
+
+		case 203:
+			if (*flags) exit_error(PARAMETER_PROBLEM,
+					"recent: only one of `--set', `--rcheck' "
+					"`--update' or `--remove' may be set");
+			check_inverse(optarg, &invert, &optind, 0);
+			info->check_set |= XT_RECENT_UPDATE;
+			if (invert) info->invert = 1;
+			*flags = 1;
+			break;
+
+		case 206:
+			if (*flags) exit_error(PARAMETER_PROBLEM,
+					"recent: only one of `--set', `--rcheck' "
+					"`--update' or `--remove' may be set");
+			check_inverse(optarg, &invert, &optind, 0);
+			info->check_set |= XT_RECENT_REMOVE;
+			if (invert) info->invert = 1;
+			*flags = 1;
+			break;
+
+		case 204:
+			info->seconds = atoi(optarg);
+			break;
+
+		case 205:
+			info->hit_count = atoi(optarg);
+			break;
+
+		case 207:
+			info->check_set |= XT_RECENT_TTL;
+			break;
+
+		case 208:
+			strncpy(info->name,optarg,XT_RECENT_NAME_LEN);
+			info->name[XT_RECENT_NAME_LEN-1] = '\0';
+			break;
+
+		case 209:
+			info->side = XT_RECENT_SOURCE;
+			break;
+
+		case 210:
+			info->side = XT_RECENT_DEST;
+			break;
+
+		default:
+			return 0;
+	}
+
+	return 1;
+}
+
+/* Final check; must have specified a specific option. */
+static void
+final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM,
+			"recent: you must specify one of `--set', `--rcheck' "
+			"`--update' or `--remove'");
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ip6t_ip6 *ip,
+      const struct ip6t_entry_match *match,
+      int numeric)
+{
+	struct xt_recent_mtinfo *info = (struct xt_recent_mtinfo *)match->data;
+
+	if (info->invert)
+		fputc('!', stdout);
+
+	printf("recent: ");
+	if(info->check_set & XT_RECENT_SET) printf("SET ");
+	if(info->check_set & XT_RECENT_CHECK) printf("CHECK ");
+	if(info->check_set & XT_RECENT_UPDATE) printf("UPDATE ");
+	if(info->check_set & XT_RECENT_REMOVE) printf("REMOVE ");
+	if(info->seconds) printf("seconds: %d ",info->seconds);
+	if(info->hit_count) printf("hit_count: %d ",info->hit_count);
+	if(info->check_set & XT_RECENT_TTL) printf("TTL-Match ");
+	if(info->name) printf("name: %s ",info->name);
+	if(info->side == XT_RECENT_SOURCE) printf("side: source ");
+	if(info->side == XT_RECENT_DEST) printf("side: dest");
+}
+
+/* Saves the union ip6t_matchinfo in parsable form to stdout. */
+static void
+save(const struct ip6t_ip6 *ip, const struct ip6t_entry_match *match)
+{
+	struct xt_recent_mtinfo *info = (struct xt_recent_mtinfo *)match->data;
+
+	if (info->invert)
+		printf("! ");
+
+	if(info->check_set & XT_RECENT_SET) printf("--set ");
+	if(info->check_set & XT_RECENT_CHECK) printf("--rcheck ");
+	if(info->check_set & XT_RECENT_UPDATE) printf("--update ");
+	if(info->check_set & XT_RECENT_REMOVE) printf("--remove ");
+	if(info->seconds) printf("--seconds %d ",info->seconds);
+	if(info->hit_count) printf("--hitcount %d ",info->hit_count);
+	if(info->check_set & XT_RECENT_TTL) printf("--rttl ");
+	if(info->name) printf("--name %s ",info->name);
+	if(info->side == XT_RECENT_SOURCE) printf("--rsource ");
+	if(info->side == XT_RECENT_DEST) printf("--rdest ");
+}
+
+/* Structure for iptables to use to communicate with module */
+static struct ip6tables_match recent = { 
+    .next          = NULL,
+    .name          = "recent",
+    .version       = XTABLES_VERSION,
+    .size          = IP6T_ALIGN(sizeof(struct xt_recent_mtinfo)),
+    .userspacesize = IP6T_ALIGN(sizeof(struct xt_recent_mtinfo)),
+    .help          = &help,
+    .init          = &init,
+    .parse         = &parse,
+    .final_check   = &final_check,
+    .print         = &print,
+    .save          = &save,
+    .extra_opts    = opts,
+};
+
+void _init(void)
+{
+	register_match6(&recent);
+}
--- iptables/extensions/libip6t_ROUTE.c
+++ iptables/extensions/libip6t_ROUTE.c
@@ -0,0 +1,264 @@
+/* Shared library add-on to iptables to add ROUTE v6 target support.
+ * Author : Cedric de Launois, <delaunois@info.ucl.ac.be>
+ * v 1.1 2004/11/23
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <net/if.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+
+#include <ip6tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <linux/netfilter_ipv6/ip6t_ROUTE.h>
+
+#ifndef XTABLES_VERSION
+#define XTABLES_VERSION IPTABLES_VERSION
+#endif
+
+/* compile IP6T_ROUTE_TEE support even if kernel headers are unpatched */
+#ifndef IP6T_ROUTE_TEE
+#define IP6T_ROUTE_TEE		0x02
+#endif
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"ROUTE target v%s options:\n"
+"    --oif   \tifname \t\tRoute packet through `ifname' network interface\n"
+"    --iif   \tifname \t\tChange packet's incoming interface to `ifname'\n"
+"    --gw    \tip     \t\tRoute packet via this gateway `ip'\n"
+"    --continue\t     \t\tRoute packet and continue traversing the\n"
+"            \t       \t\trules. Not valid with --iif or --tee.\n"
+"    --tee\t  \t\tDuplicate packet, route the duplicate,\n"
+"            \t       \t\tcontinue traversing with original packet.\n"
+"            \t       \t\tNot valid with --iif or --continue.\n"
+"\n",
+"1.11");
+}
+
+static struct option opts[] = {
+	{ "oif", 1, 0, '1' },
+	{ "iif", 1, 0, '2' },
+	{ "gw", 1, 0, '3' },
+	{ "continue", 0, 0, '4' },
+	{ "tee", 0, 0, '5' },
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+#ifdef _XTABLES_H
+init(struct xt_entry_target *t)
+#else
+init(struct ip6t_entry_target *t, unsigned int *nfcache)
+#endif
+{
+	struct ip6t_route_target_info *route_info = 
+		(struct ip6t_route_target_info*)t->data;
+
+	route_info->oif[0] = '\0';
+	route_info->iif[0] = '\0';
+	route_info->gw[0] = 0;
+	route_info->gw[1] = 0;
+	route_info->gw[2] = 0;
+	route_info->gw[3] = 0;
+	route_info->flags = 0;
+}
+
+
+#define IP6T_ROUTE_OPT_OIF      0x01
+#define IP6T_ROUTE_OPT_IIF      0x02
+#define IP6T_ROUTE_OPT_GW       0x04
+#define IP6T_ROUTE_OPT_CONTINUE 0x08
+#define IP6T_ROUTE_OPT_TEE      0x10
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+#ifdef _XTABLES_H
+      const void *entry, struct xt_entry_target **target)
+#else
+      const struct ip6t_entry *entry, struct ip6t_entry_target **target)
+#endif
+{
+	struct ip6t_route_target_info *route_info = 
+		(struct ip6t_route_target_info*)(*target)->data;
+
+	switch (c) {
+	case '1':
+		if (*flags & IP6T_ROUTE_OPT_OIF)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --oif twice");
+
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --oif");
+
+		if (strlen(optarg) > sizeof(route_info->oif) - 1)
+			exit_error(PARAMETER_PROBLEM,
+				   "Maximum interface name length %u",
+				   sizeof(route_info->oif) - 1);
+
+		strcpy(route_info->oif, optarg);
+		*flags |= IP6T_ROUTE_OPT_OIF;
+		break;
+
+	case '2':
+		exit_error(PARAMETER_PROBLEM,
+			   "--iif option not implemented");
+		break;
+
+	case '3':
+		if (*flags & IP6T_ROUTE_OPT_GW)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --gw twice");
+
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --gw");
+
+		if (!inet_pton(AF_INET6, optarg, (struct in6_addr*)&route_info->gw)) {
+			exit_error(PARAMETER_PROBLEM,
+				   "Invalid IPv6 address %s",
+				   optarg);
+		}
+
+		*flags |= IP6T_ROUTE_OPT_GW;
+		break;
+
+	case '4':
+		if (*flags & IP6T_ROUTE_OPT_CONTINUE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --continue twice");
+		if (*flags & IP6T_ROUTE_OPT_TEE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --continue AND --tee");
+
+		route_info->flags |= IP6T_ROUTE_CONTINUE;
+		*flags |= IP6T_ROUTE_OPT_CONTINUE;
+
+		break;
+
+	case '5':
+		if (*flags & IP6T_ROUTE_OPT_TEE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --tee twice");
+		if (*flags & IP6T_ROUTE_OPT_CONTINUE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --tee AND --continue");
+
+		route_info->flags |= IP6T_ROUTE_TEE;
+		*flags |= IP6T_ROUTE_OPT_TEE;
+
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+
+static void
+final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM,
+		           "ROUTE target: oif or gw option required");
+}
+
+
+/* Prints out the targinfo. */
+static void
+#ifdef _XTABLES_H
+print(const void *ip,
+      const struct xt_entry_target *target,
+#else
+print(const struct ip6t_ip6 *ip,
+      const struct ip6t_entry_target *target,
+#endif
+      int numeric)
+{
+	const struct ip6t_route_target_info *route_info
+		= (const struct ip6t_route_target_info *)target->data;
+
+	printf(" ROUTE");
+
+	if (route_info->oif[0])
+		printf("oif:%s ", route_info->oif);
+
+	if (route_info->gw[0] 
+	    || route_info->gw[1] 
+	    || route_info->gw[2] 
+	    || route_info->gw[3]) {
+		char address[INET6_ADDRSTRLEN];
+		printf(" gw:%s ", inet_ntop(AF_INET6, route_info->gw, address, INET6_ADDRSTRLEN));
+	}
+
+	if (route_info->flags & IP6T_ROUTE_CONTINUE)
+		printf(" continue");
+
+	if (route_info->flags & IP6T_ROUTE_TEE)
+		printf(" tee");
+
+}
+
+
+static void
+#ifdef _XTABLES_H
+save(const void *ip,
+     const struct xt_entry_target *target)
+#else
+save(const struct ip6t_ip6 *ip,
+     const struct ip6t_entry_target *target)
+#endif
+{
+	const struct ip6t_route_target_info *route_info
+		= (const struct ip6t_route_target_info *)target->data;
+
+	if (route_info->oif[0])
+		printf("--oif %s ", route_info->oif);
+
+	if (route_info->gw[0] 
+	    || route_info->gw[1] 
+	    || route_info->gw[2] 
+	    || route_info->gw[3]) {
+		char address[INET6_ADDRSTRLEN];
+		printf(" --gw %s ", inet_ntop(AF_INET6, route_info->gw, address, INET6_ADDRSTRLEN));
+	}
+
+	if (route_info->flags & IP6T_ROUTE_CONTINUE)
+		printf(" --continue");
+
+	if (route_info->flags & IP6T_ROUTE_TEE)
+		printf(" --tee");
+}
+
+
+static struct ip6tables_target route = { 
+	.name 		= "ROUTE",
+	.version	= XTABLES_VERSION,
+	.size		= IP6T_ALIGN(sizeof(struct ip6t_route_target_info)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct ip6t_route_target_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts,
+};
+
+void _init(void)
+{
+	register_target6(&route);
+}
--- iptables/extensions/libip6t_ROUTE.man
+++ iptables/extensions/libip6t_ROUTE.man
@@ -0,0 +1,15 @@
+This is used to explicitly override the core network stack's routing decision.
+.B mangle
+table.
+.TP
+.BI "--oif " "ifname"
+Route the packet through `ifname' network interface
+.TP
+.BI "--gw " "IPv6_address"
+Route the packet via this gateway
+.TP
+.BI "--continue "
+Behave like a non-terminating target and continue traversing the rules. Not valid in combination with `--tee'
+.TP
+.BI "--tee "
+Make a copy of the packet, and route that copy to the given destination. For the original, uncopied packet, behave like a non-terminating target and continue traversing the rules.  Not valid in combination with `--continue'
--- iptables/extensions/libip6t_string.c
+++ iptables/extensions/libip6t_string.c
@@ -0,0 +1,355 @@
+/* Shared library add-on to iptables to add string IPv6 matching support.
+ * 
+ * Copyright (C) 2000 Emmanuel Roger  <winfield@freegates.be>
+ *
+ * 2005-08-05 Pablo Neira Ayuso <pablo@eurodev.net>
+ * 	- reimplemented to use new string matching iptables match
+ * 	- add functionality to match packets by using window offsets
+ * 	- add functionality to select the string matching algorithm
+ *
+ * ChangeLog
+ *     29.12.2003: Michael Rash <mbr@cipherdyne.org>
+ *             Fixed iptables save/restore for ascii strings
+ *             that contain space chars, and hex strings that
+ *             contain embedded NULL chars.  Updated to print
+ *             strings in hex mode if any non-printable char
+ *             is contained within the string.
+ *
+ *     27.01.2001: Gianni Tedesco <gianni@ecsc.co.uk>
+ *             Changed --tos to --string in save(). Also
+ *             updated to work with slightly modified
+ *             ipt_string_info.
+ */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+#include <ip6tables.h>
+#include <stddef.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <linux/netfilter_ipv4/ipt_string.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"STRING match v%s options:\n"
+"--from                       Offset to start searching from\n"
+"--to                         Offset to stop searching\n"
+"--algo	                      Algorithm\n"
+"--string [!] string          Match a string in a packet\n"
+"--hex-string [!] string      Match a hex string in a packet\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "from", 1, 0, '1' },
+	{ "to", 1, 0, '2' },
+	{ "algo", 1, 0, '3' },
+	{ "string", 1, 0, '4' },
+	{ "hex-string", 1, 0, '5' },
+	{0}
+};
+
+static void
+init(struct ip6t_entry_match *m, unsigned int *nfcache)
+{
+	struct ipt_string_info *i = (struct ipt_string_info *) m->data;
+
+	if (i->to_offset == 0)
+		i->to_offset = (u_int16_t) ~0UL;
+}
+
+static void
+parse_string(const char *s, struct ipt_string_info *info)
+{	
+	if (strlen(s) <= IPT_STRING_MAX_PATTERN_SIZE) {
+		strncpy(info->pattern, s, IPT_STRING_MAX_PATTERN_SIZE);
+		info->patlen = strlen(s);
+		return;
+	}
+	exit_error(PARAMETER_PROBLEM, "STRING too long `%s'", s);
+}
+
+static void
+parse_algo(const char *s, struct ipt_string_info *info)
+{
+	if (strlen(s) <= IPT_STRING_MAX_ALGO_NAME_SIZE) {
+		strncpy(info->algo, s, IPT_STRING_MAX_ALGO_NAME_SIZE);
+		return;
+	}
+	exit_error(PARAMETER_PROBLEM, "ALGO too long `%s'", s);
+}
+
+static void
+parse_hex_string(const char *s, struct ipt_string_info *info)
+{
+	int i=0, slen, sindex=0, schar;
+	short hex_f = 0, literal_f = 0;
+	char hextmp[3];
+
+	slen = strlen(s);
+
+	if (slen == 0) {
+		exit_error(PARAMETER_PROBLEM,
+			"STRING must contain at least one char");
+	}
+
+	while (i < slen) {
+		if (s[i] == '\\' && !hex_f) {
+			literal_f = 1;
+		} else if (s[i] == '\\') {
+			exit_error(PARAMETER_PROBLEM,
+				"Cannot include literals in hex data");
+		} else if (s[i] == '|') {
+			if (hex_f)
+				hex_f = 0;
+			else {
+				hex_f = 1;
+				/* get past any initial whitespace just after the '|' */
+				while (s[i+1] == ' ')
+					i++;
+			}
+			if (i+1 >= slen)
+				break;
+			else
+				i++;  /* advance to the next character */
+		}
+
+		if (literal_f) {
+			if (i+1 >= slen) {
+				exit_error(PARAMETER_PROBLEM,
+					"Bad literal placement at end of string");
+			}
+			info->pattern[sindex] = s[i+1];
+			i += 2;  /* skip over literal char */
+			literal_f = 0;
+		} else if (hex_f) {
+			if (i+1 >= slen) {
+				exit_error(PARAMETER_PROBLEM,
+					"Odd number of hex digits");
+			}
+			if (i+2 >= slen) {
+				/* must end with a "|" */
+				exit_error(PARAMETER_PROBLEM, "Invalid hex block");
+			}
+			if (! isxdigit(s[i])) /* check for valid hex char */
+				exit_error(PARAMETER_PROBLEM, "Invalid hex char `%c'", s[i]);
+			if (! isxdigit(s[i+1])) /* check for valid hex char */
+				exit_error(PARAMETER_PROBLEM, "Invalid hex char `%c'", s[i+1]);
+			hextmp[0] = s[i];
+			hextmp[1] = s[i+1];
+			hextmp[2] = '\0';
+			if (! sscanf(hextmp, "%x", &schar))
+				exit_error(PARAMETER_PROBLEM,
+					"Invalid hex char `%c'", s[i]);
+			info->pattern[sindex] = (char) schar;
+			if (s[i+2] == ' ')
+				i += 3;  /* spaces included in the hex block */
+			else
+				i += 2;
+		} else {  /* the char is not part of hex data, so just copy */
+			info->pattern[sindex] = s[i];
+			i++;
+		}
+		if (sindex > IPT_STRING_MAX_PATTERN_SIZE)
+			exit_error(PARAMETER_PROBLEM, "STRING too long `%s'", s);
+		sindex++;
+	}
+	info->patlen = sindex;
+}
+
+#define STRING 0x1
+#define ALGO   0x2
+#define FROM   0x4
+#define TO     0x8
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ip6t_entry *entry,
+      unsigned int *nfcache,
+      struct ip6t_entry_match **match)
+{
+	struct ipt_string_info *stringinfo = (struct ipt_string_info *)(*match)->data;
+
+	switch (c) {
+	case '1':
+		if (*flags & FROM)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify multiple --from");
+		stringinfo->from_offset = atoi(optarg);
+		*flags |= FROM;
+		break;
+	case '2':
+		if (*flags & TO)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify multiple --to");
+		stringinfo->to_offset = atoi(optarg);
+		*flags |= TO;
+		break;
+	case '3':
+		if (*flags & ALGO)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify multiple --algo");
+		parse_algo(optarg, stringinfo);
+		*flags |= ALGO;
+		break;
+	case '4':
+		if (*flags & STRING)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify multiple --string");
+		check_inverse(optarg, &invert, &optind, 0);
+		parse_string(argv[optind-1], stringinfo);
+		if (invert)
+			stringinfo->invert = 1;
+		stringinfo->patlen=strlen((char *)&stringinfo->pattern);
+		*flags |= STRING;
+		break;
+
+	case '5':
+		if (*flags & STRING)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify multiple --hex-string");
+
+		check_inverse(optarg, &invert, &optind, 0);
+		parse_hex_string(argv[optind-1], stringinfo);  /* sets length */
+		if (invert)
+			stringinfo->invert = 1;
+		*flags |= STRING;
+		break;
+
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+
+/* Final check; must have specified --string. */
+static void
+final_check(unsigned int flags)
+{
+	if (!(flags & STRING))
+		exit_error(PARAMETER_PROBLEM,
+			   "STRING match: You must specify `--string' or "
+			   "`--hex-string'");
+	if (!(flags & ALGO))
+		exit_error(PARAMETER_PROBLEM,
+			   "STRING match: You must specify `--algo'");
+}
+
+/* Test to see if the string contains non-printable chars or quotes */
+static unsigned short int
+is_hex_string(const char *str, const unsigned short int len)
+{
+	unsigned int i;
+	for (i=0; i < len; i++)
+		if (! isprint(str[i]))
+			return 1;  /* string contains at least one non-printable char */
+	/* use hex output if the last char is a "\" */
+	if ((unsigned char) str[len-1] == 0x5c)
+		return 1;
+	return 0;
+}
+
+/* Print string with "|" chars included as one would pass to --hex-string */
+static void
+print_hex_string(const char *str, const unsigned short int len)
+{
+	unsigned int i;
+	/* start hex block */
+	printf("\"|");
+	for (i=0; i < len; i++) {
+		/* see if we need to prepend a zero */
+		if ((unsigned char) str[i] <= 0x0F)
+			printf("0%x", (unsigned char) str[i]);
+		else
+			printf("%x", (unsigned char) str[i]);
+	}
+	/* close hex block */
+	printf("|\" ");
+}
+
+static void
+print_string(const char *str, const unsigned short int len)
+{
+	unsigned int i;
+	printf("\"");
+	for (i=0; i < len; i++) {
+		if ((unsigned char) str[i] == 0x22)  /* escape any embedded quotes */
+			printf("%c", 0x5c);
+		printf("%c", (unsigned char) str[i]);
+	}
+	printf("\" ");  /* closing space and quote */
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ip6t_ip *ip,
+      const struct ip6t_entry_match *match,
+      int numeric)
+{
+	const struct ipt_string_info *info =
+	    (const struct ipt_string_info*) match->data;
+
+	if (is_hex_string(info->pattern, info->patlen)) {
+		printf("STRING match %s", (info->invert) ? "!" : "");
+		print_hex_string(info->pattern, info->patlen);
+	} else {
+		printf("STRING match %s", (info->invert) ? "!" : "");
+		print_string(info->pattern, info->patlen);
+	}
+	printf("ALGO name %s ", info->algo);
+	if (info->from_offset != 0)
+		printf("FROM %u ", info->from_offset);
+	if (info->to_offset != 0)
+		printf("TO %u ", info->to_offset);
+}
+
+
+/* Saves the union ipt_matchinfo in parseable form to stdout. */
+static void
+save(const struct ip6t_ip *ip, const struct ip6t_entry_match *match)
+{
+	const struct ipt_string_info *info =
+	    (const struct ipt_string_info*) match->data;
+
+	if (is_hex_string(info->pattern, info->patlen)) {
+		printf("--hex-string %s", (info->invert) ? "! ": "");
+		print_hex_string(info->pattern, info->patlen);
+	} else {
+		printf("--string %s", (info->invert) ? "! ": "");
+		print_string(info->pattern, info->patlen);
+	}
+	printf("--algo %s ", info->algo);
+	if (info->from_offset != 0)
+		printf("--from %u ", info->from_offset);
+	if (info->to_offset != 0)
+		printf("--to %u ", info->to_offset);
+}
+
+
+static struct ip6tables_match string = {
+    .name		= "string",
+    .version		= IPTABLES_VERSION,
+    .size		= IP6T_ALIGN(sizeof(struct ipt_string_info)),
+    .userspacesize	= offsetof(struct ipt_string_info, config),
+    .help		= help,
+    .init		= init,
+    .parse		= parse,
+    .final_check	= final_check,
+    .print		= print,
+    .save		= save,
+    .extra_opts		= opts
+};
+
+
+void _init(void)
+{
+	register_match6(&string);
+}
--- iptables/extensions/libip6t_TRACE.c
+++ iptables/extensions/libip6t_TRACE.c
@@ -0,0 +1,63 @@
+/* Shared library add-on to iptables to add TRACE target support. */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <ip6tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"TRACE target v%s takes no options\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ip6t_entry_target *t, unsigned int *nfcache)
+{
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ip6t_entry *entry,
+      struct ip6t_entry_target **target)
+{
+	return 0;
+}
+
+static void
+final_check(unsigned int flags)
+{
+}
+
+static
+struct ip6tables_target trace
+= {	.next = NULL,
+	.name = "TRACE",
+	.version = IPTABLES_VERSION,
+	.size = IP6T_ALIGN(0),
+	.userspacesize = IP6T_ALIGN(0),
+	.help = &help,
+	.init = &init,
+	.parse = &parse,
+	.final_check = &final_check,
+	.print = NULL, /* print */
+	.save = NULL, /* save */
+	.extra_opts = opts
+};
+
+void _init(void)
+{
+	register_target6(&trace);
+}
--- iptables/extensions/libip6t_TRACE.man
+++ iptables/extensions/libip6t_TRACE.man
@@ -0,0 +1,3 @@
+This target has no options.  It just turns on 
+.B packet tracing
+for all packets that match this rule.
--- iptables/extensions/libip6t_web.c
+++ iptables/extensions/libip6t_web.c
@@ -0,0 +1,215 @@
+/*
+
+	web (experimental)
+	HTTP IPv6 client match
+	Copyright (C) 2006 Jonathan Zarate
+
+	Licensed under GNU GPL v2 or later.
+
+*/
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <ip6tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <linux/netfilter_ipv4/ipt_web.h>
+
+
+#undef IPTABLES_SAVE
+
+
+static void help(void)
+{
+	printf(
+		"web match v0.01 (experimental)\n"
+		"Copyright (C) 2006 Jonathan Zarate\n"
+		"Options:\n"
+		"[!] --http (default)   find an HTTP GET/POST request\n"
+		"[!] --host <text ...>  find in host line\n"
+		"[!] --req <text ...>   find in request\n"
+		"[!] --path <text ...>  find in request path\n"
+		"[!] --query <text ...> find in request query\n"
+		"[!] --hore <text ...>  find in host or request line\n"
+		" <text> can be:\n"
+		"  text    contains\n"
+		"  ^text   begins with\n"
+		"  text$   ends with\n"
+		"  ^text$  exact match\n");
+}
+
+static void init(struct ip6t_entry_match *m, unsigned int *nfcache)
+{
+	*nfcache |= NFC_UNKNOWN;
+}
+
+static struct option opts[] = {
+	{ .name = "http",  .has_arg = 0, .flag = 0, .val = '1' },
+	{ .name = "host",  .has_arg = 1, .flag = 0, .val = '2' },
+	{ .name = "req",   .has_arg = 1, .flag = 0, .val = '3' },
+	{ .name = "path",  .has_arg = 1, .flag = 0, .val = '4' },
+	{ .name = "query", .has_arg = 1, .flag = 0, .val = '5' },
+	{ .name = "hore",  .has_arg = 1, .flag = 0, .val = '6' },
+	{ .name = 0 }
+};
+
+static int parse(int c, char **argv, int invert, unsigned int *flags,
+				 const struct ip6t_entry *entry, unsigned int *nfcache,
+				 struct ip6t_entry_match **match)
+{
+	const char *s;
+	char *e, *p;
+	int n;
+	struct ipt_web_info *info;
+
+	if ((c < '1') || (c > '6')) return 0;
+
+	if (*flags) exit_error(PARAMETER_PROBLEM, "Multiple modes are not supported");
+	*flags = 1;
+
+	info = (struct ipt_web_info *)(*match)->data;
+	switch (c) {
+	case '2':
+		info->mode = IPT_WEB_HOST;
+		break;
+	case '3':
+		info->mode = IPT_WEB_RURI;
+		break;
+	case '4':
+		info->mode = IPT_WEB_PATH;
+		break;
+	case '5':
+		info->mode = IPT_WEB_QUERY;
+		break;
+	case '6':
+		info->mode = IPT_WEB_HORE;
+		break;
+	default:	// IPT_WEB_HTTP
+		return 1;
+	}
+
+	if (entry->ipv6.proto != IPPROTO_TCP) {
+		exit_error(PARAMETER_PROBLEM, "web match requires -p tcp");
+	}
+
+	check_inverse(optarg, &invert, &optind, 0);
+	if (invert) info->invert = 1;
+
+	// convert arg to text\0text\0\0
+	s = argv[optind - 1];
+
+	if ((p = malloc(strlen(s) + 2)) == NULL) {
+		exit_error(PARAMETER_PROBLEM, "Not enough memory");
+	}
+
+	e = p;
+	while (*s) {
+		while ((*s == ' ') || (*s == '\n') || (*s == '\t')) ++s;
+		if (*s == 0) break;
+		while ((*s != 0) && (*s != ' ') && (*s != '\n') && (*s != '\t')) {
+			*e++ = *s++;
+		}
+		*e++ = 0;
+	}
+	n = (e - p);
+
+#if 0
+	*e = 0;
+	e = p;
+	while (*e) {
+		printf("[%s]\n", e);
+		e += strlen(e) + 1;
+	}
+#endif
+
+	if (n <= 1) {
+		exit_error(PARAMETER_PROBLEM, "Text is too short");
+	}
+	if (n >= IPT_WEB_MAXTEXT) {
+		exit_error(PARAMETER_PROBLEM, "Text is too long");
+	}
+	memcpy(info->text, p, n);
+	memset(info->text + n, 0, IPT_WEB_MAXTEXT - n);		// term, need to clear rest for ipt rule cmp
+	free(p);
+	return 1;
+}
+
+static void final_check(unsigned int flags)
+{
+}
+
+static void print_match(const struct ipt_web_info *info)
+{
+	const char *text;
+
+	if (info->invert) printf("! ");
+
+	switch (info->mode) {
+	case IPT_WEB_HOST:
+		printf("--host");
+		break;
+	case IPT_WEB_RURI:
+		printf("--req");
+		break;
+	case IPT_WEB_PATH:
+		printf("--path");
+		break;
+	case IPT_WEB_QUERY:
+		printf("--query");
+		break;
+	case IPT_WEB_HORE:
+		printf("--hore");
+		break;
+	default:
+		printf("--http");
+		return;
+	}
+
+	text = info->text;
+	printf(" \"");
+	while (*text) {
+		while (*text) {
+			if (*text == '"') printf("\\\"");
+				else putc(*text, stdout);
+			++text;
+		}
+		++text;
+		if (*text == 0) break;
+		putc(' ', stdout);
+	}
+	printf("\" ");
+}
+
+static void print(const struct ip6t_ip6 *ip, const struct ip6t_entry_match *match, int numeric)
+{
+	printf("web ");
+	print_match((const struct ipt_web_info *)match->data);
+}
+
+static void save(const struct ip6t_ip6 *ip, const struct ip6t_entry_match *match)
+{
+#ifdef IPTABLES_SAVE
+	print_match((const struct ipt_web_info *)match->data);
+#endif
+}
+
+static struct ip6tables_match web_match = {
+	.next 		= NULL,
+	.name          = "web",
+	.version       = IPTABLES_VERSION,
+	.size          = IP6T_ALIGN(sizeof(struct ipt_web_info)),
+	.userspacesize = IP6T_ALIGN(sizeof(struct ipt_web_info)),
+	.help          = &help,
+	.init          = &init,
+	.parse         = &parse,
+	.final_check   = &final_check,
+	.print         = &print,
+	.save          = &save,
+	.extra_opts    = opts
+};
+
+void _init(void)
+{
+	register_match6(&web_match);
+}
--- iptables/extensions/libip6t_webmon.c
+++ iptables/extensions/libip6t_webmon.c
@@ -0,0 +1,328 @@
+/*  webmon --	An iptables extension to match URLs in HTTP requests 
+ *  		This module can match using string match or regular expressions
+ *  		Originally designed for use with Gargoyle router firmware (gargoyle-router.com)
+ *
+ *
+ *  Copyright  2008-2010 by Eric Bishop <eric@gargoyle-router.com>
+ * 
+ *  This file is free software: you may copy, redistribute and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation, either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *  This file is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <arpa/inet.h>
+
+/*
+ * in iptables 1.4.0 and higher, iptables.h includes xtables.h, which
+ * we can use to check whether we need to deal with the new requirements
+ * in pre-processor directives below
+ */
+#include <ip6tables.h> 
+#include <linux/netfilter_ipv6/ip6_tables.h>
+
+#ifdef CONFIG_BCMWL6
+#include <linux/netfilter/xt_webmon.h>
+#define ipt_webmon_info		xt_webmon_info
+#else
+#include <linux/netfilter_ipv4/ipt_webmon.h>
+#endif
+
+#ifdef _XTABLES_H
+	#define iptables_match		xtables_match
+	#define ip6t_entry_match	xt_entry_match
+#endif
+
+/* 
+ * XTABLES_VERSION_CODE is only defined in versions 1.4.1 and later, which
+ * also require the use of xtables_register_match
+ * 
+ * Version 1.4.0 uses register_match like previous versions
+ */
+#ifdef XTABLES_VERSION_CODE 
+	#define register_match6          xtables_register_match
+#endif
+
+unsigned char* read_entire_file(FILE* in, unsigned long read_block_size, unsigned long *length);
+
+#define DEFAULT_MAX      300
+
+#define SEARCH_LOAD_FILE 100
+#define DOMAIN_LOAD_FILE 101
+#define CLEAR_SEARCH     102
+#define CLEAR_DOMAIN     103
+
+static char* domain_load_file = NULL;
+static char* search_load_file = NULL;
+static uint32_t global_max_domains  = DEFAULT_MAX;
+static uint32_t global_max_searches = DEFAULT_MAX;
+
+/* Function which prints out usage message. */
+static void help(void)
+{
+	printf(	"webmon options:\n");
+}
+
+static struct option opts[] = 
+{
+	{ .name = "max_domains",        .has_arg = 1, .flag = 0, .val = WEBMON_MAXDOMAIN },
+	{ .name = "max_searches",       .has_arg = 1, .flag = 0, .val = WEBMON_MAXSEARCH },
+	{ .name = "search_load_file",   .has_arg = 1, .flag = 0, .val = SEARCH_LOAD_FILE },
+	{ .name = "domain_load_file",   .has_arg = 1, .flag = 0, .val = DOMAIN_LOAD_FILE },
+	{ .name = "clear_search",       .has_arg = 0, .flag = 0, .val = CLEAR_SEARCH },
+	{ .name = "clear_domain",       .has_arg = 0, .flag = 0, .val = CLEAR_DOMAIN },
+
+	{ .name = 0 }
+};
+
+static void webmon_init(
+#ifdef _XTABLES_H
+	struct xt_entry_match *match
+#else
+	struct ip6t_entry_match *match, unsigned int *nfcache
+#endif
+	)
+{
+	struct ipt_webmon_info *info = (struct ipt_webmon_info *)match->data;
+	info->max_domains=DEFAULT_MAX;
+	info->max_searches=DEFAULT_MAX;
+	info->ref_count = NULL;
+}
+
+
+/* Function which parses command options; returns true if it ate an option */
+static int parse(	int c, 
+			char **argv,
+			int invert,
+			unsigned int *flags,
+#ifdef _XTABLES_H
+			const void *entry,
+#else
+			const struct ip6t_entry *entry,
+			unsigned int *nfcache,
+#endif			
+			struct ip6t_entry_match **match
+			)
+{
+	struct ipt_webmon_info *info = (struct ipt_webmon_info *)(*match)->data;
+	int valid_arg = 1;
+	long max;
+	switch (c)
+	{
+		case WEBMON_MAXSEARCH:
+			if( sscanf(argv[optind-1], "%ld", &max) == 0)
+			{
+				info->max_searches = DEFAULT_MAX ;
+				valid_arg = 0;
+			}
+			else
+			{
+				info->max_searches = (uint32_t)max;
+				global_max_searches = info->max_searches;
+			}
+			break;
+		case WEBMON_MAXDOMAIN:
+			if( sscanf(argv[optind-1], "%ld", &max) == 0)
+			{
+				info->max_domains = DEFAULT_MAX ;
+				valid_arg = 0;
+			}
+			else
+			{
+				info->max_domains = (uint32_t)max;
+				global_max_domains = info->max_domains;
+			}
+			break;
+		case SEARCH_LOAD_FILE:
+			search_load_file = strdup(optarg);
+			break;
+		case DOMAIN_LOAD_FILE:
+			domain_load_file = strdup(optarg);
+			break;
+		case CLEAR_SEARCH:
+			search_load_file = strdup("/dev/null");
+			break;
+		case CLEAR_DOMAIN:
+			domain_load_file = strdup("/dev/null");
+			break;
+		default:
+			valid_arg = 0;
+	}
+	return valid_arg;
+
+}
+
+
+	
+static void print_webmon_args(	struct ipt_webmon_info* info )
+{
+	printf("--max_domains %ld ", (unsigned long int)info->max_domains);
+	printf("--max_searches %ld ", (unsigned long int)info->max_searches);
+}
+
+
+static void do_load(char* file, uint32_t max, unsigned char type)
+{
+	if(file != NULL)
+	{
+		unsigned char* data = NULL;
+		unsigned long data_length = 0;
+		if(strcmp(file, "/dev/null") == 0)
+		{
+			data = (unsigned char*)malloc(10);
+			if(data != NULL)
+			{
+				uint32_t* maxp = (uint32_t*)(data+1);
+				data_length = 3+sizeof(uint32_t);
+				data[0] = type;
+				*maxp = max;
+				data[ sizeof(uint32_t)+1 ] = ' ';
+				data[ sizeof(uint32_t)+1 ] = '\0';
+			}
+		}
+		else
+		{
+			FILE* in = fopen(file, "r");
+			if(in != NULL)
+			{
+				char* file_data = read_entire_file(in, 4096, &data_length);
+				fclose(in);
+				if(file_data != NULL)
+				{
+					data_length = strlen(file_data) + sizeof(uint32_t)+2;
+					data = (unsigned char*)malloc(data_length);
+					if(data != NULL)
+					{
+						uint32_t* maxp = (uint32_t*)(data+1);
+						data[0] = type;
+						*maxp = max;
+						sprintf( (data+1+sizeof(uint32_t)),  "%s", file_data);
+					}
+					free(file_data);
+				}
+			}
+		}
+
+		if(data != NULL && data_length > 0)
+		{
+			int sockfd = -1;
+			sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
+			if(sockfd >= 0)
+			{
+				setsockopt(sockfd, IPPROTO_IP, WEBMON_SET, data, data_length);
+			}
+		}
+		if(data != NULL)
+		{
+			free(data);
+		}
+	}
+}
+
+
+static void final_check(unsigned int flags)
+{
+	do_load(domain_load_file, global_max_domains,  WEBMON_DOMAIN);
+	do_load(search_load_file, global_max_searches, WEBMON_SEARCH);
+}
+
+/* Prints out the matchinfo. */
+#ifdef _XTABLES_H
+static void print(const void *ip, const struct xt_entry_match *match, int numeric)
+#else	
+static void print(const struct ip6t_ip6 *ip, const struct ip6t_entry_match *match, int numeric)
+#endif
+{
+	printf("WEBMON ");
+	struct ipt_webmon_info *info = (struct ipt_webmon_info *)match->data;
+
+	print_webmon_args(info);
+}
+
+/* Saves the union ipt_matchinfo in parsable form to stdout. */
+#ifdef _XTABLES_H
+static void save(const void *ip, const struct xt_entry_match *match)
+#else
+static void save(const struct ip6t_ip6 *ip, const struct ip6t_entry_match *match)
+#endif
+{
+	struct ipt_webmon_info *info = (struct ipt_webmon_info *)match->data;
+	print_webmon_args(info);
+}
+
+static struct ip6tables_match webmon = 
+{ 
+	.next		= NULL,
+ 	.name		= "webmon",
+	#ifdef XTABLES_VERSION_CODE
+		.version = XTABLES_VERSION,
+		.family = PF_INET6,
+	#else
+		.version = IPTABLES_VERSION,
+	#endif
+	.size		= IP6T_ALIGN(sizeof(struct ipt_webmon_info)),
+	.userspacesize	= IP6T_ALIGN(sizeof(struct ipt_webmon_info)),
+	.help		= &help,
+	.init           = &webmon_init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_match6(&webmon);
+}
+
+
+unsigned char* read_entire_file(FILE* in, unsigned long read_block_size, unsigned long *length)
+{
+	int max_read_size = read_block_size;
+	unsigned char* read_string = (unsigned char*)malloc(max_read_size+1);
+	unsigned long bytes_read = 0;
+	int end_found = 0;
+	while(end_found == 0)
+	{
+		int nextch = '?';
+		while(nextch != EOF && bytes_read < max_read_size)
+		{
+			nextch = fgetc(in);
+			if(nextch != EOF)
+			{
+				read_string[bytes_read] = (unsigned char)nextch;
+				bytes_read++;
+			}
+		}
+		read_string[bytes_read] = '\0';
+		end_found = (nextch == EOF) ? 1 : 0;
+		if(end_found == 0)
+		{
+			unsigned char *new_str;
+			max_read_size = max_read_size + read_block_size;
+		       	new_str = (unsigned char*)malloc(max_read_size+1);
+			memcpy(new_str, read_string, bytes_read);
+			free(read_string);
+			read_string = new_str;
+		}
+	}
+	*length = bytes_read;
+	return read_string;
+}
+
--- iptables/extensions/libipt_account.c
+++ iptables/extensions/libipt_account.c
@@ -0,0 +1,353 @@
+/* Copyright (c) 2004-2006 Piotr 'QuakeR' Gasido <quaker@barbara.eu.org>
+ * accounting match helper (libipt_account.c)
+ *
+ * Version: 0.1.20
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#ifdef IPTABLES_VERSION
+#include <iptables.h>
+#elif defined XTABLES_VERSION
+#include <xtables.h>
+#else
+#error IPTABLES_VERSION nor XTABLES_VERSION not defined.
+#endif
+#include <string.h>
+#include <getopt.h>
+
+#include <linux/netfilter_ipv4/ipt_account.h>
+
+#ifndef HIPQUAD
+#define HIPQUAD(addr) \
+  ((unsigned char *)&addr)[3], \
+  ((unsigned char *)&addr)[2], \
+  ((unsigned char *)&addr)[1], \
+  ((unsigned char *)&addr)[0]
+#endif
+        
+static void help(void) {
+  printf(
+      "account v%s options:\n"
+      "--aaddr network/netmask\n"
+      " defines network/netmask for which make statistics.\n"
+      "--aname name\n"
+      " defines name of list where statistics will be kept. If no is\n"
+      " specified DEFAULT will be used.\n"
+      "--ashort\n"
+      "       table will colect only short statistics (only total counters\n"
+      "       without splitting it into protocols.\n"
+  , 
+#ifdef IPTABLES_VERSION
+  IPTABLES_VERSION
+#else
+  XTABLES_VERSION
+#endif
+  );
+};
+
+static struct option opts[] = {
+  { .name = "aaddr",  .has_arg = 1, .flag = NULL, .val = 201 },
+  { .name = "aname",  .has_arg = 1, .flag = NULL, .val = 202 },
+  { .name = "ashort", .has_arg = 0, .flag = NULL, .val = 203 },
+  { .name = 0, .has_arg = 0, .flag = 0, .val = 0 }
+};
+
+/* Helper functions for parse_network */
+int parseip(const char *parameter, u_int32_t *ip) {
+  
+  char buffer[16], *bufferptr, *dot;
+  unsigned int i, shift, part;
+
+  if (strlen(parameter) > 15)
+    return 0;
+
+  strncpy(buffer, parameter, 15);
+  buffer[15] = 0;
+
+  bufferptr = buffer;
+
+  for (i = 0, shift = 24, *ip = 0; i < 3; i++, shift -= 8) {
+    /* no dot */
+    if ((dot = strchr(bufferptr, '.')) == NULL)
+      return 0;
+    /* not a number */
+    if ((part = strtol(bufferptr, (char**)NULL, 10)) < 0) 
+      return 0; 
+    /* to big number */
+    if (part > 255)
+      return 0;
+    *ip |= part << shift;   
+    bufferptr = dot + 1;
+  }
+  /* not a number */
+  if ((part = strtol(bufferptr, (char**)NULL, 10)) < 0) 
+    return 0;
+  /* to big number */
+  if (part > 255)
+    return 0;
+  *ip |= part;
+  return 1;
+}
+
+static void parsenetwork(const char *parameter, u_int32_t *network) {
+  if (!parseip(parameter, network))
+#ifdef XTABLES_VERSION
+    xtables_error(PARAMETER_PROBLEM, "account: wrong ip in network");
+#else
+    exit_error(PARAMETER_PROBLEM, "account: wrong ip in network");
+#endif
+}
+
+static void parsenetmaskasbits(const char *parameter, u_int32_t *netmask) {
+  
+  u_int32_t bits;
+  
+  if ((bits = strtol(parameter, (char **)NULL, 10)) < 0 || bits > 32)
+#ifdef XTABLES_VERSION
+    xtables_error(PARAMETER_PROBLEM, "account: wrong netmask");
+#else
+    exit_error(PARAMETER_PROBLEM, "account: wrong netmask");
+#endif
+
+  *netmask = 0xffffffff << (32 - bits);
+}
+
+static void parsenetmaskasip(const char *parameter, u_int32_t *netmask) {
+  if (!parseip(parameter, netmask))
+#ifdef XTABLES_VERSION
+    xtables_error(PARAMETER_PROBLEM, "account: wrong ip in netmask");
+#else
+    exit_error(PARAMETER_PROBLEM, "account: wrong ip in netmask");
+#endif
+}
+
+static void parsenetmask(const char *parameter, u_int32_t *netmask) 
+{
+  if (strchr(parameter, '.') != NULL)
+    parsenetmaskasip(parameter, netmask);
+  else
+    parsenetmaskasbits(parameter, netmask);
+}
+
+static void parsenetworkandnetmask(const char *parameter, u_int32_t *network, u_int32_t *netmask) 
+{
+  
+  char buffer[32], *slash;
+
+  if (strlen(parameter) > 31)
+    /* text is to long, even for 255.255.255.255/255.255.255.255 */
+#ifdef XTABLES_VERSION
+    xtables_error(PARAMETER_PROBLEM, "account: wrong network/netmask");
+#else
+    exit_error(PARAMETER_PROBLEM, "account: wrong network/netmask");
+#endif
+
+  strncpy(buffer, parameter, 31);
+  buffer[31] = 0;
+
+  /* check whether netmask is given */
+  if ((slash = strchr(buffer, '/')) != NULL) {
+    parsenetmask(slash + 1, netmask);
+    *slash = 0;
+  } else
+    *netmask = 0xffffffff;
+  parsenetwork(buffer, network);
+
+  if ((*network & *netmask) != *network)
+#ifdef XTABLES_VERSION
+    xtables_error(PARAMETER_PROBLEM, "account: wrong network/netmask");
+#else
+    exit_error(PARAMETER_PROBLEM, "account: wrong network/netmask");
+#endif
+}
+
+
+/* Function gets network & netmask from argument after --aaddr */
+static void parse_network(const char *parameter, struct t_ipt_account_info *info) {
+
+  parsenetworkandnetmask(parameter, &info->network, &info->netmask);
+  
+}
+
+/* validate netmask */
+inline int valid_netmask(u_int32_t netmask) {
+  while (netmask & 0x80000000)
+    netmask <<= 1;
+  if (netmask != 0)
+    return 0;
+        return 1;
+}
+
+/* validate network/netmask pair */
+inline int valid_network_and_netmask(struct t_ipt_account_info *info) {
+  if (!valid_netmask(info->netmask))
+    return 0;
+  if ((info->network & info->netmask) != info->network)
+    return 0;
+  return 1;
+}
+
+
+
+/* Function initializes match */
+#ifdef XTABLES_VERSION
+static void init(struct xt_entry_match *match)
+#else
+static void init(struct ipt_entry_match *match, 
+     unsigned int *nfcache)
+#endif  
+{
+  struct t_ipt_account_info *info = (struct t_ipt_account_info *)(match)->data;
+
+
+	/* set default table name to DEFAULT */
+	strncpy(info->name, "DEFAULT", IPT_ACCOUNT_NAME_LEN);
+	info->shortlisting = 0;
+	info->table = NULL;
+	
+}
+
+/* Function parses match's arguments */
+static int parse(int c, char **argv, 
+		  int invert, 
+		  unsigned int *flags,
+                  const struct ipt_entry *entry,
+                  unsigned int *nfcache,
+                  struct ipt_entry_match **match) {
+	
+	struct t_ipt_account_info *info = (struct t_ipt_account_info *)(*match)->data;
+
+	switch (c) {
+		
+		/* --aaddr */
+		case 201:
+			parse_network(optarg, info);
+			if (!valid_network_and_netmask(info))
+				exit_error(PARAMETER_PROBLEM, "account: wrong network/netmask");
+			*flags = 1;
+			break;
+			
+		/* --aname */
+		case 202:
+			if (strlen(optarg) < IPT_ACCOUNT_NAME_LEN) {
+				strncpy(info->name, optarg, IPT_ACCOUNT_NAME_LEN);
+				info->name[IPT_ACCOUNT_NAME_LEN] = '\0';
+			}	else
+				exit_error(PARAMETER_PROBLEM, "account: Too long table name");
+			break;	
+		/* --ashort */
+		case 203:
+			info->shortlisting = 1;
+			break;
+		default:
+			return 0;
+	}
+	return 1;
+}
+
+/* Final check whether network/netmask was specified */
+static void final_check(unsigned int flags) {
+  if (!flags)
+#ifdef XTABLES_VERSION    
+    xtables_error(PARAMETER_PROBLEM, "account: You need specify '--aaddr' parameter");
+#else
+    exit_error(PARAMETER_PROBLEM, "account: You need specify '--aaddr' parameter");
+#endif
+}
+
+/* Function used for printing rule with account match for iptables -L */
+static void print(
+#ifdef XTABLES_VERSION    
+    const void *ip, 
+    const struct xt_entry_match *match,
+#else
+    const struct ipt_ip *ip,
+    const struct ipt_entry_match *match,
+#endif
+    int numeric) {
+  
+  struct t_ipt_account_info *info = (struct t_ipt_account_info *)match->data;
+  
+  printf("account: ");
+  printf("network/netmask: ");
+  printf("%u.%u.%u.%u/%u.%u.%u.%u ",
+      HIPQUAD(info->network),
+      HIPQUAD(info->netmask)
+        );
+  
+  printf("name: %s ", info->name);
+  if (info->shortlisting)
+    printf("short-listing ");
+}
+
+/* Function used for saving rule containing account match */
+static void save(
+#ifdef XTABLES_VERSION
+    const void *ip,
+    const struct xt_entry_match *match
+#else
+    const struct ipt_ip *ip, 
+    const struct ipt_entry_match *match
+#endif
+) {
+
+  struct t_ipt_account_info *info = (struct t_ipt_account_info *)match->data;
+  
+  printf(" --aaddr ");
+  printf("%u.%u.%u.%u/%u.%u.%u.%u ",
+       HIPQUAD(info->network),
+       HIPQUAD(info->netmask)
+         );
+  
+  printf("--aname %s", info->name);
+  if (info->shortlisting)
+    printf("--ashort ");
+}
+
+#ifdef XTABLES_VERSION
+static struct xtables_match account = {
+  .name = "account",
+  .version = XTABLES_VERSION,
+  .family = PF_INET,
+  .size = XT_ALIGN(sizeof(struct t_ipt_account_info)),
+  .userspacesize = XT_ALIGN(sizeof(struct t_ipt_account_info)),
+  .help = help,
+  .init = init,
+  .parse = parse,
+  .final_check = final_check,
+  .print = print,
+  .save = save,
+  .extra_opts = opts
+};
+#else
+static struct iptables_match account = {
+  .next = NULL,
+  .name = "account",
+  .version = IPTABLES_VERSION,
+  .size = IPT_ALIGN(sizeof(struct t_ipt_account_info)),
+  .userspacesize = IPT_ALIGN(sizeof(struct t_ipt_account_info)),
+  .help = &help,
+  .init = &init,
+  .parse = &parse,
+  .final_check = &final_check,
+  .print = &print,
+  .save = &save,
+  .extra_opts = opts
+};
+#endif
+
+/* Function which registers match */
+void _init(void)
+{
+#ifdef XTABLES_VERSION
+  xtables_register_match(&account);
+#else
+  register_match(&account);
+#endif
+}
+  
--- iptables/extensions/libipt_account.man
+++ iptables/extensions/libipt_account.man
@@ -0,0 +1,47 @@
+Account traffic for all hosts in defined network/netmask.
+
+Features:
+
+- long (one counter per protocol TCP/UDP/IMCP/Other) and short statistics
+
+- one iptables rule for all hosts in network/netmask
+
+- loading/saving counters (by reading/writting to procfs entries)
+
+.TP
+.BI "--aaddr " "network/netmask"
+defines network/netmask for which make statistics.
+.TP
+.BI "--aname " "name"
+defines name of list where statistics will be kept. If no is
+specified DEFAULT will be used.
+.TP
+.B "--ashort"
+table will colect only short statistics (only total counters
+without splitting it into protocols.
+.P
+Example usage:
+
+account traffic for/to 192.168.0.0/24 network into table mynetwork:
+
+# iptables -A FORWARD -m account --aname mynetwork --aaddr 192.168.0.0/24
+
+account traffic for/to WWW serwer for 192.168.0.0/24 network into table mywwwserver:
+
+# iptables -A INPUT -p tcp --dport 80
+  -m account --aname mywwwserver --aaddr 192.168.0.0/24 --ashort
+
+# iptables -A OUTPUT -p tcp --sport 80
+  -m account --aname mywwwserver --aaddr 192.168.0.0/24 --ashort
+
+read counters:
+
+# cat /proc/net/ipt_account/mynetwork
+# cat /proc/net/ipt_account/mywwwserver
+
+set counters:
+
+# echo "ip = 192.168.0.1 packets_src = 0" > /proc/net/ipt_account/mywwserver
+
+Webpage:
+  http://www.barbara.eu.org/~quaker/ipt_account/
--- iptables/extensions/libipt_autofw.c
+++ iptables/extensions/libipt_autofw.c
@@ -0,0 +1,192 @@
+/*
+ * Automatic port forwarding target. When this target is entered, a
+ * related connection to a port in the reply direction will be
+ * expected. This connection may be mapped to a different port.
+ *
+ * Copyright 2005, Broadcom Corporation
+ * All Rights Reserved.
+ * 
+ * THIS SOFTWARE IS OFFERED "AS IS", AND BROADCOM GRANTS NO WARRANTIES OF ANY
+ * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. BROADCOM
+ * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A SPECIFIC PURPOSE OR NONINFRINGEMENT CONCERNING THIS SOFTWARE.
+ *
+ * $Id: libipt_autofw.c,v 1.1.1.7 2005/03/07 07:31:14 kanki Exp $
+ */
+
+/* Shared library add-on to iptables to add masquerade support. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ip_nat_rule.h>
+#include <linux/netfilter_ipv4/ip_autofw.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"autofw v%s options:\n"
+" --related-proto proto\n"
+"				Related protocol\n"
+" --related-dport port[-port]\n"
+"				Related destination port range\n"
+" --related-to port[-port]\n"
+"				Port range to map related destination port range to.\n\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "related-proto", 1, 0, '1' },
+	{ "related-dport", 1, 0, '2' },
+	{ "related-to", 1, 0, '3' },
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ipt_entry_target *t, unsigned int *nfcache)
+{
+	/* Can't cache this */
+	*nfcache |= NFC_UNKNOWN;
+}
+
+/* Parses ports */
+static void
+parse_ports(const char *arg, u_int16_t *ports)
+{
+	const char *dash;
+	int port;
+
+	port = atoi(arg);
+	if (port == 0 || port > 65535)
+		exit_error(PARAMETER_PROBLEM, "Port `%s' not valid\n", arg);
+
+	dash = strchr(arg, '-');
+	if (!dash)
+		ports[0] = ports[1] = htons(port);
+	else {
+		int maxport;
+
+		maxport = atoi(dash + 1);
+		if (maxport == 0 || maxport > 65535)
+			exit_error(PARAMETER_PROBLEM,
+				   "Port `%s' not valid\n", dash+1);
+		if (maxport < port)
+			/* People are stupid. */
+			exit_error(PARAMETER_PROBLEM,
+				   "Port range `%s' funky\n", arg);
+		ports[0] = htons(port);
+		ports[1] = htons(maxport);
+	}
+}
+
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      struct ipt_entry_target **target)
+{
+	struct ip_autofw_info *info = (struct ip_autofw_info *)(*target)->data;
+
+	switch (c) {
+	case '1':
+		if (!strcasecmp(optarg, "tcp"))
+			info->proto = IPPROTO_TCP;
+		else if (!strcasecmp(optarg, "udp"))
+			info->proto = IPPROTO_UDP;
+		else
+			exit_error(PARAMETER_PROBLEM,
+				   "unknown protocol `%s' specified", optarg);
+		return 1;
+
+	case '2':
+		if (check_inverse(optarg, &invert, &optind, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --related-dport");
+
+		parse_ports(optarg, info->dport);
+		return 1;
+
+	case '3':
+		if (check_inverse(optarg, &invert, &optind, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --related-to");
+
+		parse_ports(optarg, info->to);
+		*flags |= IP_NAT_RANGE_PROTO_SPECIFIED;
+		return 1;
+
+	default:
+		return 0;
+	}
+}
+
+/* Final check; don't care. */
+static void final_check(unsigned int flags)
+{
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_target *target,
+      int numeric)
+{
+	struct ip_autofw_info *info = (struct ip_autofw_info *)target->data;
+
+	printf("autofw ");
+	if (info->proto == IPPROTO_TCP)
+		printf("tcp ");
+	else if (info->proto == IPPROTO_UDP)
+		printf("udp ");
+	printf("dpt:%hu", ntohs(info->dport[0]));
+	if (ntohs(info->dport[1]) > ntohs(info->dport[0]))
+		printf("-%hu", ntohs(info->dport[1]));
+	printf(" ");
+	printf("to:%hu", ntohs(info->to[0]));
+	if (ntohs(info->to[1]) > ntohs(info->to[0]))
+		printf("-%hu", ntohs(info->to[1]));
+	printf(" ");
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_target *target)
+{
+	struct ip_autofw_info *info = (struct ip_autofw_info *)target->data;
+
+	printf("--related-proto ");
+	if (info->proto == IPPROTO_TCP)
+		printf("tcp ");
+	else if (info->proto == IPPROTO_UDP)
+		printf("udp ");
+	printf("--related-dport %hu-%hu ", ntohs(info->dport[0]), ntohs(info->dport[1]));
+	printf("--related-to %hu-%hu ", ntohs(info->to[0]), ntohs(info->to[1]));
+}
+
+struct iptables_target autofw
+= { NULL,
+    "autofw",
+    IPTABLES_VERSION,
+    IPT_ALIGN(sizeof(struct ip_autofw_info)),
+    IPT_ALIGN(sizeof(struct ip_autofw_info)),
+    &help,
+    &init,
+    &parse,
+    &final_check,
+    &print,
+    &save,
+    opts
+};
+
+void _init(void)
+{
+	register_target(&autofw);
+}
--- iptables/extensions/libipt_BALANCE.c
+++ iptables/extensions/libipt_BALANCE.c
@@ -0,0 +1,150 @@
+/* Shared library add-on to iptables to add simple load-balance support. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ip_nat_rule.h>
+
+#define BREAKUP_IP(x) (x)>>24, ((x)>>16) & 0xFF, ((x)>>8) & 0xFF, (x) & 0xFF
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"BALANCE v%s options:\n"
+" --to-destination <ipaddr>-<ipaddr>\n"
+"				Addresses to map destination to.\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "to-destination", 1, 0, '1' },
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ipt_entry_target *t, unsigned int *nfcache)
+{
+	struct ip_nat_multi_range *mr = (struct ip_nat_multi_range *)t->data;
+
+	/* Actually, it's 0, but it's ignored at the moment. */
+	mr->rangesize = 1;
+
+}
+
+/* Parses range of IPs */
+static void
+parse_to(char *arg, struct ip_nat_range *range)
+{
+	char *dash;
+	struct in_addr *ip;
+
+	range->flags |= IP_NAT_RANGE_MAP_IPS;
+	dash = strchr(arg, '-');
+	if (dash)
+		*dash = '\0';
+	else
+		exit_error(PARAMETER_PROBLEM, "Bad IP range `%s'\n", arg);
+
+	ip = dotted_to_addr(arg);
+	if (!ip)
+		exit_error(PARAMETER_PROBLEM, "Bad IP address `%s'\n",
+			   arg);
+	range->min_ip = ip->s_addr;
+	ip = dotted_to_addr(dash+1);
+	if (!ip)
+		exit_error(PARAMETER_PROBLEM, "Bad IP address `%s'\n",
+			   dash+1);
+	range->max_ip = ip->s_addr;
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      struct ipt_entry_target **target)
+{
+	struct ip_nat_multi_range *mr
+		= (struct ip_nat_multi_range *)(*target)->data;
+
+	switch (c) {
+	case '1':
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --to-destination");
+
+		parse_to(optarg, &mr->range[0]);
+		*flags = 1;
+		return 1;
+
+	default:
+		return 0;
+	}
+}
+
+/* Final check; need --to-dest. */
+static void final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM,
+			   "BALANCE needs --to-destination");
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_target *target,
+      int numeric)
+{
+	struct ip_nat_multi_range *mr
+		= (struct ip_nat_multi_range *)target->data;
+	struct ip_nat_range *r = &mr->range[0];
+	struct in_addr a;
+
+	a.s_addr = r->min_ip;
+
+	printf("balance %s", addr_to_dotted(&a));
+	a.s_addr = r->max_ip;
+	printf("-%s ", addr_to_dotted(&a));
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_target *target)
+{
+	struct ip_nat_multi_range *mr
+		= (struct ip_nat_multi_range *)target->data;
+	struct ip_nat_range *r = &mr->range[0];
+	struct in_addr a;
+
+	a.s_addr = r->min_ip;
+	printf("--to-destination %s", addr_to_dotted(&a));
+	a.s_addr = r->max_ip;
+	printf("-%s ", addr_to_dotted(&a));
+}
+
+static struct iptables_target balance = { 
+	.next		= NULL,
+	.name		= "BALANCE",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ip_nat_multi_range)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_target(&balance);
+}
--- iptables/extensions/libipt_BALANCE.man
+++ iptables/extensions/libipt_BALANCE.man
@@ -0,0 +1,4 @@
+This allows you to DNAT connections in a round-robin way over a given range of destination addresses.
+.TP
+.BI "--to-destination " "ipaddr-ipaddr"
+Address range to round-robin over.
--- iptables/extensions/libipt_bcount.c
+++ iptables/extensions/libipt_bcount.c
@@ -0,0 +1,125 @@
+/*
+
+	bcount match (experimental)
+	Copyright (C) 2006 Jonathan Zarate
+
+	Licensed under GNU GPL v2 or later.
+	
+*/
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_bcount.h>
+
+
+#undef IPTABLES_SAVE
+
+
+static void help(void)
+{
+	printf(
+		"bcount match v0.00\n"
+		"[!] --range min:max (upper range of 0x0FFFFFFF or more means unlimited)\n"
+	);
+}
+
+static void init(struct ipt_entry_match *match, unsigned int *nfcache)
+{
+	struct ipt_bcount_match *info = (struct ipt_bcount_match *)match->data;
+	info->min = 0xFFFFFFFF;
+	info->max = 0x0FFFFFFF;
+	*nfcache |= NFC_UNKNOWN;
+}
+
+static struct option opts[] = {
+	{ .name = "range",	.has_arg = 1, .flag = 0, .val = '1' },
+	{ .name = NULL }
+};
+
+static int parse(int c, char **argv, int invert, unsigned int *flags,
+				 const struct ipt_entry *entry, unsigned int *nfcache,
+				 struct ipt_entry_match **match)
+{
+	char *p;
+	struct ipt_bcount_match *info;
+
+	if (c != '1') return 0;
+
+	info = (struct ipt_bcount_match *)(*match)->data;
+	
+	*flags = 1;
+	check_inverse(optarg, &invert, &optind, 0);
+	if (invert) info->invert = 1;
+
+	info->min = strtoul(argv[optind - 1], &p, 0);
+	if (*p == '+') {
+		++p;
+	}
+	else if ((*p == '-') || (*p == ':')) {
+		++p;
+		if ((*p == 0) || (strcmp(p, "max") == 0)) {
+			info->max = 0x0FFFFFFF;
+		}
+		else {
+			info->max = strtoul(p, &p, 0);
+			if (info->max > 0x0FFFFFFF) info->max = 0x0FFFFFFF;
+		}
+	}
+
+	if ((*p != 0) || (info->min > info->max))
+		exit_error(PARAMETER_PROBLEM, "Invalid range");
+	return 1;
+}
+
+static void final_check(unsigned int flags)
+{
+	if (!flags) {
+		exit_error(PARAMETER_PROBLEM, "Invalid range");
+	}
+}
+
+static void print_match(const struct ipt_bcount_match *info)
+{
+	if (info->min != 0xFFFFFFFF) {
+		if (info->invert) printf("! ");
+		printf("--range %u", info->min);
+		if (info->max == 0x0FFFFFFF) printf("+ ");
+			else printf(":%u ", info->max);
+	}
+}
+
+static void print(const struct ipt_ip *ip, const struct ipt_entry_match *match, int numeric)
+{
+	printf("bcount ");
+	print_match((const struct ipt_bcount_match *)match->data);
+}
+
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+#ifdef IPTABLES_SAVE
+	print_match((const struct ipt_bcount_match *)match->data);
+#endif
+}
+
+
+static struct iptables_match bcount_match = {
+	.name          = "bcount",
+	.version       = IPTABLES_VERSION,
+	.size          = IPT_ALIGN(sizeof(struct ipt_bcount_match)),
+	.userspacesize = IPT_ALIGN(sizeof(struct ipt_bcount_match)),
+	.help          = &help,
+	.init          = &init,
+	.parse         = &parse,
+	.final_check   = &final_check,
+	.print         = &print,
+	.save          = &save,
+	.extra_opts    = opts
+};
+
+void _init(void)
+{
+	register_match(&bcount_match);
+}
--- iptables/extensions/libipt_BCOUNT.c
+++ iptables/extensions/libipt_BCOUNT.c
@@ -0,0 +1,56 @@
+/*
+
+	BCOUNT target (experimental)
+	Copyright (C) 2006 Jonathan Zarate
+
+	Licensed under GNU GPL v2 or later.
+
+*/
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_BCOUNT.h>
+
+static void help(void)
+{
+	printf("BCOUNT target (experimental) v0.01\nCopyright (C) 2006 Jonathan Zarate\n");
+}
+
+static void init(struct ipt_entry_target *t, unsigned int *nfcache)
+{
+}
+
+static struct option opts[] = { { 0 } };
+
+static int parse(int c, char **argv, int invert, unsigned int *flags,
+				 const struct ipt_entry *entry, struct ipt_entry_target **target)
+{
+	return 0;
+}
+
+static void final_check(unsigned int flags)
+{
+}
+
+static struct iptables_target BCOUNT_target
+= {	.next = NULL,
+	.name = "BCOUNT",
+	.version = IPTABLES_VERSION,
+	.size = IPT_ALIGN(sizeof(struct ipt_BCOUNT_target)),
+	.userspacesize = IPT_ALIGN(sizeof(struct ipt_BCOUNT_target)),
+	.help = &help,
+	.init = &init,
+	.parse = &parse,
+	.final_check = &final_check,
+	.print = NULL,
+	.save = NULL,
+	.extra_opts = opts
+};
+
+void _init(void)
+{
+	register_target(&BCOUNT_target);
+}
--- iptables/extensions/libipt_childlevel.c
+++ iptables/extensions/libipt_childlevel.c
@@ -0,0 +1,115 @@
+/* 
+   Shared library add-on to iptables to add layer 7 matching support. 
+
+   http://l7-filter.sf.net
+  
+   By Matthew Strait <quadong@users.sf.net>, Dec 2003.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version
+   2 of the License, or (at your option) any later version.
+   http://www.gnu.org/licenses/gpl.txt
+*/
+
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+#include <dirent.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_childlevel.h>
+
+/* Function which prints out usage message. */
+static void help(void)
+{
+	printf(
+	"CHILDLEVEL match v%s options:\n"
+	"--level <n>  : Match childlevel n (0 == master)\n",
+	IPTABLES_VERSION);
+	fputc('\n', stdout);
+}
+
+static struct option opts[] = {
+	{ .name = "level", .has_arg = 1, .flag = 0, .val = '1' },
+	{ .name = 0 }
+};
+
+/* Function which parses command options; returns true if it ate an option */
+static int parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry, unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_childlevel_info *childlevelinfo = 
+		(struct ipt_childlevel_info *)(*match)->data;
+
+	switch (c) {
+	case '1':
+		check_inverse(optarg, &invert, &optind, 0);
+		childlevelinfo->childlevel = atoi(argv[optind-1]);
+		if (invert)
+			childlevelinfo->invert = 1;
+		*flags = 1;
+		break;
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+/* Final check; must have specified --level. */
+static void final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM,
+			   "CHILDLEVEL match: You must specify `--level'");
+}
+
+static void print_protocol(int n, int invert, int numeric)
+{
+	fputs("childlevel ", stdout);
+	if (invert) fputc('!', stdout);
+	printf("%d ", n);
+}
+
+/* Prints out the matchinfo. */
+static void print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	printf("CHILDLEVEL ");
+
+	print_protocol(((struct ipt_childlevel_info *)match->data)->childlevel,
+		  ((struct ipt_childlevel_info *)match->data)->invert, numeric);
+}
+/* Saves the union ipt_matchinfo in parsable form to stdout. */
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+        const struct ipt_childlevel_info *info =
+            (const struct ipt_childlevel_info*) match->data;
+
+        printf("--childlevel %s%d ", (info->invert) ? "! ": "", info->childlevel);
+}
+
+static struct iptables_match childlevel = { 
+	.name		= "childlevel",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_childlevel_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_childlevel_info)),
+	.help		= &help,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_match(&childlevel);
+}
--- iptables/extensions/libipt_childlevel.man
+++ iptables/extensions/libipt_childlevel.man
@@ -0,0 +1,5 @@
+This is an experimental module.  It matches on whether the 
+packet is part of a master connection or one of its children (or grandchildren,
+etc).  For instance, most packets are level 0.  FTP data transfer is level 1.
+.TP
+.BR "--childlevel " "[!] \fIlevel\fP"
--- iptables/extensions/libipt_connlimit.c
+++ iptables/extensions/libipt_connlimit.c
@@ -0,0 +1,136 @@
+/* Shared library add-on to iptables to add connection limit support. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_conntrack.h>
+#include <linux/netfilter_ipv4/ipt_connlimit.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"connlimit v%s options:\n"
+"[!] --connlimit-above n		match if the number of existing tcp connections is (not) above n\n"
+" --connlimit-mask n		group hosts using mask\n"
+"\n", IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "connlimit-above", 1, 0, '1' },
+	{ "connlimit-mask",  1, 0, '2' },
+	{0}
+};
+
+static void connlimit_init(struct ipt_entry_match *match, unsigned int *nfc)
+{
+	struct ipt_connlimit_info *info = (void *)match->data;
+	info->mask = htonl(0xFFFFFFFF);
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_connlimit_info *info = (struct ipt_connlimit_info*)(*match)->data;
+	char *err;
+	int i;
+
+	if (*flags & c)
+		exit_error(PARAMETER_PROBLEM,
+		           "--connlimit-above and/or --connlimit-mask may "
+			   "only be given once");
+
+	switch (c) {
+	case '1':
+		check_inverse(optarg, &invert, &optind, 0);
+		info->limit = strtoul(argv[optind-1], NULL, 0);
+		info->inverse = invert;
+		break;
+
+	case '2':
+		i = strtoul(argv[optind-1], &err, 0);
+		if (i > 32 || *err != '\0')
+			exit_error(PARAMETER_PROBLEM,
+				"--connlimit-mask must be between 0 and 32");
+		if (i == 0)
+			info->mask = 0;
+		else
+			info->mask = htonl(0xFFFFFFFF << (32 - i));
+		break;
+
+	default:
+		return 0;
+	}
+
+	*flags |= c;
+	return 1;
+}
+
+/* Final check */
+static void final_check(unsigned int flags)
+{
+	if (!(flags & 1))
+		exit_error(PARAMETER_PROBLEM,
+		           "You must specify \"--connlimit-above\"");
+}
+
+static int
+count_bits(u_int32_t mask)
+{
+	unsigned int bits = 0;
+
+	for (mask = ~ntohl(mask); mask != 0; mask >>= 1)
+		++bits;
+
+	return 32 - bits;
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	struct ipt_connlimit_info *info = (struct ipt_connlimit_info*)match->data;
+
+	printf("#conn/%d %s %d ", count_bits(info->mask),
+	       info->inverse ? "<=" : ">", info->limit);
+}
+
+/* Saves the matchinfo in parsable form to stdout. */
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	struct ipt_connlimit_info *info = (struct ipt_connlimit_info*)match->data;
+
+	printf("%s--connlimit-above %u --connlimit-mask %u ",
+	       info->inverse ? "! " : "", info->limit,
+	       count_bits(info->mask));
+}
+
+static struct iptables_match connlimit = {
+	.name		= "connlimit",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_connlimit_info)),
+	.userspacesize 	= offsetof(struct ipt_connlimit_info,data),
+	.help		= help,
+	.init		= connlimit_init,
+	.parse 		= parse,
+	.final_check	= final_check,
+	.print		= print,
+	.save		= save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_match(&connlimit);
+}
--- iptables/extensions/libipt_connlimit.man
+++ iptables/extensions/libipt_connlimit.man
@@ -0,0 +1,21 @@
+Allows you to restrict the number of parallel TCP connections to a
+server per client IP address (or address block).
+.TP
+[\fB!\fR] \fB--connlimit-above \fIn\fR
+match if the number of existing tcp connections is (not) above n
+.TP
+.BI "--connlimit-mask " "bits"
+group hosts using mask
+.P
+Examples:
+.TP
+# allow 2 telnet connections per client host
+iptables -A INPUT -p tcp --syn --dport 23 -m connlimit --connlimit-above 2 -j REJECT
+.TP
+# you can also match the other way around:
+iptables -A INPUT -p tcp --syn --dport 23 -m connlimit ! --connlimit-above 2 -j ACCEPT
+.TP
+# limit the nr of parallel http requests to 16 per class C sized \
+network (24 bit netmask)
+iptables -p tcp --syn --dport 80 -m connlimit --connlimit-above 16
+--connlimit-mask 24 -j REJECT
--- iptables/extensions/libipt_dstlimit.c
+++ iptables/extensions/libipt_dstlimit.c
@@ -0,0 +1,340 @@
+/* iptables match extension for limiting packets per destination
+ *
+ * (C) 2003 by Harald Welte <laforge@netfilter.org>
+ *
+ * Development of this code was funded by Astaro AG, http://www.astaro.com/
+ *
+ * Based on ipt_limit.c by
+ * Jrme de Vivie   <devivie@info.enserb.u-bordeaux.fr>
+ * Herv Eychenne    <rv@wallfire.org>
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <stddef.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_dstlimit.h>
+
+#define IPT_DSTLIMIT_BURST	5
+
+/* miliseconds */
+#define IPT_DSTLIMIT_GCINTERVAL	1000
+#define IPT_DSTLIMIT_EXPIRE	10000
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"dstlimit v%s options:\n"
+"--dstlimit <avg>		max average match rate\n"
+"                                [Packets per second unless followed by \n"
+"                                /sec /minute /hour /day postfixes]\n"
+"--dstlimit-mode <mode>		mode\n"
+"					dstip\n"
+"					dstip-dstport\n"
+"					srcip-dstip\n"
+"					srcip-dstip-dstport\n"
+"--dstlimit-name <name>		name for /proc/net/ipt_dstlimit/\n"
+"[--dstlimit-burst <num>]	number to match in a burst, default %u\n"
+"[--dstlimit-htable-size <num>]	number of hashtable buckets\n"
+"[--dstlimit-htable-max <num>]	number of hashtable entries\n"
+"[--dstlimit-htable-gcinterval]	interval between garbage collection runs\n"
+"[--dstlimit-htable-expire]	after which time are idle entries expired?\n"
+"\n", IPTABLES_VERSION, IPT_DSTLIMIT_BURST);
+}
+
+static struct option opts[] = {
+	{ "dstlimit", 1, 0, '%' },
+	{ "dstlimit-burst", 1, 0, '$' },
+	{ "dstlimit-htable-size", 1, 0, '&' },
+	{ "dstlimit-htable-max", 1, 0, '*' },
+	{ "dstlimit-htable-gcinterval", 1, 0, '(' },
+	{ "dstlimit-htable-expire", 1, 0, ')' },
+	{ "dstlimit-mode", 1, 0, '_' },
+	{ "dstlimit-name", 1, 0, '"' },
+	{ 0 }
+};
+
+static
+int parse_rate(const char *rate, u_int32_t *val)
+{
+	const char *delim;
+	u_int32_t r;
+	u_int32_t mult = 1;  /* Seconds by default. */
+
+	delim = strchr(rate, '/');
+	if (delim) {
+		if (strlen(delim+1) == 0)
+			return 0;
+
+		if (strncasecmp(delim+1, "second", strlen(delim+1)) == 0)
+			mult = 1;
+		else if (strncasecmp(delim+1, "minute", strlen(delim+1)) == 0)
+			mult = 60;
+		else if (strncasecmp(delim+1, "hour", strlen(delim+1)) == 0)
+			mult = 60*60;
+		else if (strncasecmp(delim+1, "day", strlen(delim+1)) == 0)
+			mult = 24*60*60;
+		else
+			return 0;
+	}
+	r = atoi(rate);
+	if (!r)
+		return 0;
+
+	/* This would get mapped to infinite (1/day is minimum they
+           can specify, so we're ok at that end). */
+	if (r / mult > IPT_DSTLIMIT_SCALE)
+		exit_error(PARAMETER_PROBLEM, "Rate too fast `%s'\n", rate);
+
+	*val = IPT_DSTLIMIT_SCALE * mult / r;
+	return 1;
+}
+
+/* Initialize the match. */
+static void
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	struct ipt_dstlimit_info *r = (struct ipt_dstlimit_info *)m->data;
+
+	r->cfg.burst = IPT_DSTLIMIT_BURST;
+	r->cfg.gc_interval = IPT_DSTLIMIT_GCINTERVAL;
+	r->cfg.expire = IPT_DSTLIMIT_EXPIRE;
+
+}
+
+#define PARAM_LIMIT		0x00000001
+#define PARAM_BURST		0x00000002
+#define PARAM_MODE		0x00000004
+#define PARAM_NAME		0x00000008
+#define PARAM_SIZE		0x00000010
+#define PARAM_MAX		0x00000020
+#define PARAM_GCINTERVAL	0x00000040
+#define PARAM_EXPIRE		0x00000080
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_dstlimit_info *r = 
+			(struct ipt_dstlimit_info *)(*match)->data;
+	unsigned int num;
+
+	switch(c) {
+	case '%':
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
+		if (!parse_rate(optarg, &r->cfg.avg))
+			exit_error(PARAMETER_PROBLEM,
+				   "bad rate `%s'", optarg);
+		*flags |= PARAM_LIMIT;
+		break;
+
+	case '$':
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
+		if (string_to_number(optarg, 0, 10000, &num) == -1)
+			exit_error(PARAMETER_PROBLEM,
+				   "bad --dstlimit-burst `%s'", optarg);
+		r->cfg.burst = num;
+		*flags |= PARAM_BURST;
+		break;
+	case '&':
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
+		if (string_to_number(optarg, 0, 0xffffffff, &num) == -1)
+			exit_error(PARAMETER_PROBLEM,
+				"bad --dstlimit-htable-size: `%s'", optarg);
+		r->cfg.size = num;
+		*flags |= PARAM_SIZE;
+		break;
+	case '*':
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
+		if (string_to_number(optarg, 0, 0xffffffff, &num) == -1)
+			exit_error(PARAMETER_PROBLEM,
+				"bad --dstlimit-htable-max: `%s'", optarg);
+		r->cfg.max = num;
+		*flags |= PARAM_MAX;
+		break;
+	case '(':
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
+		if (string_to_number(optarg, 0, 0xffffffff, &num) == -1)
+			exit_error(PARAMETER_PROBLEM,
+				"bad --dstlimit-htable-gcinterval: `%s'", 
+				optarg);
+		/* FIXME: not HZ dependent!! */
+		r->cfg.gc_interval = num;
+		*flags |= PARAM_GCINTERVAL;
+		break;
+	case ')':
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
+		if (string_to_number(optarg, 0, 0xffffffff, &num) == -1)
+			exit_error(PARAMETER_PROBLEM,
+				"bad --dstlimit-htable-expire: `%s'", optarg);
+		/* FIXME: not HZ dependent */
+		r->cfg.expire = num;
+		*flags |= PARAM_EXPIRE;
+		break;
+	case '_':
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
+		if (!strcmp(optarg, "dstip"))
+			r->cfg.mode = IPT_DSTLIMIT_HASH_DIP;
+		else if (!strcmp(optarg, "dstip-destport") ||
+			 !strcmp(optarg, "dstip-dstport"))
+			r->cfg.mode = IPT_DSTLIMIT_HASH_DIP|IPT_DSTLIMIT_HASH_DPT;
+		else if (!strcmp(optarg, "srcip-dstip"))
+			r->cfg.mode = IPT_DSTLIMIT_HASH_SIP|IPT_DSTLIMIT_HASH_DIP;
+		else if (!strcmp(optarg, "srcip-dstip-destport") ||
+			 !strcmp(optarg, "srcip-dstip-dstport"))
+			r->cfg.mode = IPT_DSTLIMIT_HASH_SIP|IPT_DSTLIMIT_HASH_DIP|IPT_DSTLIMIT_HASH_DPT;
+		else
+			exit_error(PARAMETER_PROBLEM, 
+				"bad --dstlimit-mode: `%s'\n", optarg);
+		*flags |= PARAM_MODE;
+		break;
+	case '"':
+		if (check_inverse(argv[optind-1], &invert, &optind, 0)) break;
+		if (strlen(optarg) == 0)
+			exit_error(PARAMETER_PROBLEM, "Zero-length name?");
+		strncpy(r->name, optarg, sizeof(r->name));
+		*flags |= PARAM_NAME;
+		break;
+	default:
+		return 0;
+	}
+
+	if (invert)
+		exit_error(PARAMETER_PROBLEM,
+			   "dstlimit does not support invert");
+
+	return 1;
+}
+
+/* Final check; nothing. */
+static void final_check(unsigned int flags)
+{
+	if (!(flags & PARAM_LIMIT))
+		exit_error(PARAMETER_PROBLEM,
+				"You have to specify --dstlimit");
+	if (!(flags & PARAM_MODE))
+		exit_error(PARAMETER_PROBLEM,
+				"You have to specify --dstlimit-mode");
+	if (!(flags & PARAM_NAME))
+		exit_error(PARAMETER_PROBLEM,
+				"You have to specify --dstlimit-name");
+}
+
+static struct rates
+{
+	const char *name;
+	u_int32_t mult;
+} rates[] = { { "day", IPT_DSTLIMIT_SCALE*24*60*60 },
+	      { "hour", IPT_DSTLIMIT_SCALE*60*60 },
+	      { "min", IPT_DSTLIMIT_SCALE*60 },
+	      { "sec", IPT_DSTLIMIT_SCALE } };
+
+static void print_rate(u_int32_t period)
+{
+	unsigned int i;
+
+	for (i = 1; i < sizeof(rates)/sizeof(struct rates); i++) {
+		if (period > rates[i].mult
+            || rates[i].mult/period < rates[i].mult%period)
+			break;
+	}
+
+	printf("%u/%s ", rates[i-1].mult / period, rates[i-1].name);
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	struct ipt_dstlimit_info *r = 
+		(struct ipt_dstlimit_info *)match->data;
+	printf("limit: avg "); print_rate(r->cfg.avg);
+	printf("burst %u ", r->cfg.burst);
+	switch (r->cfg.mode) {
+		case (IPT_DSTLIMIT_HASH_DIP):
+			printf("mode dstip ");
+			break;
+		case (IPT_DSTLIMIT_HASH_DIP|IPT_DSTLIMIT_HASH_DPT):
+			printf("mode dstip-dstport ");
+			break;
+		case (IPT_DSTLIMIT_HASH_SIP|IPT_DSTLIMIT_HASH_DIP):
+			printf("mode srcip-dstip ");
+			break;
+		case (IPT_DSTLIMIT_HASH_SIP|IPT_DSTLIMIT_HASH_DIP|IPT_DSTLIMIT_HASH_DPT):
+			printf("mode srcip-dstip-dstport ");
+			break;
+	}
+	if (r->cfg.size)
+		printf("htable-size %u ", r->cfg.size);
+	if (r->cfg.max)
+		printf("htable-max %u ", r->cfg.max);
+	if (r->cfg.gc_interval != IPT_DSTLIMIT_GCINTERVAL)
+		printf("htable-gcinterval %u ", r->cfg.gc_interval);
+	if (r->cfg.expire != IPT_DSTLIMIT_EXPIRE)
+		printf("htable-expire %u ", r->cfg.expire);
+}
+
+/* FIXME: Make minimalist: only print rate if not default --RR */
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	struct ipt_dstlimit_info *r = 
+		(struct ipt_dstlimit_info *)match->data;
+
+	printf("--dstlimit "); print_rate(r->cfg.avg);
+	if (r->cfg.burst != IPT_DSTLIMIT_BURST)
+		printf("--dstlimit-burst %u ", r->cfg.burst);
+	switch (r->cfg.mode) {
+		case (IPT_DSTLIMIT_HASH_DIP):
+			printf("--mode dstip ");
+			break;
+		case (IPT_DSTLIMIT_HASH_DIP|IPT_DSTLIMIT_HASH_DPT):
+			printf("--mode dstip-dstport ");
+			break;
+		case (IPT_DSTLIMIT_HASH_SIP|IPT_DSTLIMIT_HASH_DIP):
+			printf("--mode srcip-dstip ");
+			break;
+		case (IPT_DSTLIMIT_HASH_SIP|IPT_DSTLIMIT_HASH_DIP|IPT_DSTLIMIT_HASH_DPT):
+			printf("--mode srcip-dstip-dstport ");
+			break;
+	}
+	if (r->cfg.size)
+		printf("--dstlimit-htable-size %u ", r->cfg.size);
+	if (r->cfg.max)
+		printf("--dstlimit-htable-max %u ", r->cfg.max);
+	if (r->cfg.gc_interval != IPT_DSTLIMIT_GCINTERVAL)
+		printf("--dstlimit-htable-gcinterval %u", r->cfg.gc_interval);
+	if (r->cfg.expire != IPT_DSTLIMIT_EXPIRE)
+		printf("--dstlimit-htable-expire %u ", r->cfg.expire);
+}
+
+static struct iptables_match dstlimit = { 
+	.next		= NULL,
+	.name 		= "dstlimit",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_dstlimit_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_dstlimit_info)),
+	//offsetof(struct ipt_dstlimit_info, prev),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print 		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_match(&dstlimit);
+}
--- iptables/extensions/libipt_dstlimit.man
+++ iptables/extensions/libipt_dstlimit.man
@@ -0,0 +1,37 @@
+This module allows you to limit the packet per second (pps) rate on a per
+destination IP or per destination port base.  As opposed to the `limit' match,
+every destination ip / destination port has it's own limit.
+.TP
+THIS MODULE IS DEPRECATED AND HAS BEEN REPLACED BY ``hashlimit''
+.TP
+.BI "--dstlimit " "avg"
+Maximum average match rate (packets per second unless followed by /sec /minute /hour /day postfixes).
+.TP
+.BI "--dstlimit-mode " "mode"
+The limiting hashmode.  Is the specified limit per
+.B dstip, dstip-dstport
+tuple, 
+.B srcip-dstip
+tuple, or per
+.B srcipdstip-dstport
+tuple.
+.TP
+.BI "--dstlimit-name " "name"
+Name for /proc/net/ipt_dstlimit/* file entry
+.TP
+.BI "[" "--dstlimit-burst " "burst" "]"
+Number of packets to match in a burst.  Default: 5
+.TP
+.BI "[" "--dstlimit-htable-size " "size" "]"
+Number of buckets in the hashtable
+.TP
+.BI "[" "--dstlimit-htable-max " "max" "]"
+Maximum number of entries in the hashtable
+.TP
+.BI "[" "--dstlimit-htable-gcinterval " "interval" "]"
+Interval between garbage collection runs of the hashtable (in miliseconds).
+Default is 1000 (1 second).
+.TP
+.BI "[" "--dstlimit-htable-expire " "time"
+After which time are idle entries expired from hashtable (in miliseconds)?
+Default is 10000 (10 seconds).
--- iptables/extensions/libipt_exp.c
+++ iptables/extensions/libipt_exp.c
@@ -0,0 +1,84 @@
+/*
+
+	Experimental Netfilter Crap
+	Copyright (C) 2006 Jonathan Zarate
+
+*/
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_exp.h>
+
+
+static void help(void)
+{
+	printf(
+		"exp match v0.00 options:\n"
+		"  how should I know?!\n");
+}
+
+static void init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	*nfcache |= NFC_UNKNOWN;
+}
+
+static struct option opts[] = {
+	{ .name = "foo",  .has_arg = 0, .flag = 0, .val = '1' },
+	{ .name = 0 }
+};
+
+static int parse(int c, char **argv, int invert, unsigned int *flags,
+				 const struct ipt_entry *entry, unsigned int *nfcache,
+				 struct ipt_entry_match **match)
+{
+	struct ipt_exp_info *info;
+
+	if ((c < '1') || (c > '1')) return 0;
+
+	// reserved
+	
+	info = (struct ipt_exp_info *)(*match)->data;
+	switch (c) {
+	case '1':
+		info->dummy = 1;	// blah
+		break;
+	}
+	return 1;
+}
+
+static void final_check(unsigned int flags)
+{
+}
+
+static void print(const struct ipt_ip *ip, const struct ipt_entry_match *match, int numeric)
+{
+	printf("exp ");
+}
+
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+}
+
+
+static struct iptables_match exp_match = {
+	.name          = "exp",
+	.version       = IPTABLES_VERSION,
+	.size          = IPT_ALIGN(sizeof(struct ipt_exp_info)),
+	.userspacesize = IPT_ALIGN(sizeof(struct ipt_exp_info)),
+	.help          = &help,
+	.init          = &init,
+	.parse         = &parse,
+	.final_check   = &final_check,
+	.print         = &print,
+	.save          = &save,
+	.extra_opts    = opts
+};
+
+void _init(void)
+{
+	register_match(&exp_match);
+}
--- iptables/extensions/libipt_FTOS.c
+++ iptables/extensions/libipt_FTOS.c
@@ -0,0 +1,133 @@
+/* Shared library add-on to iptables for FTOS
+ *
+ * (C) 2000 by Matthew G. Marsh <mgm@paktronix.com>
+ *
+ * This program is distributed under the terms of GNU GPL v2, 1991
+ *
+ * libipt_FTOS.c borrowed heavily from libipt_TOS.c  11/09/2000
+ *
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_FTOS.h>
+
+struct finfo {
+ 	struct ipt_entry_target t;
+	u_int8_t ftos;
+};
+
+static void init(struct ipt_entry_target *t, unsigned int *nfcache) 
+{
+}
+
+static void help(void) 
+{
+	printf(
+"FTOS target options\n"
+"  --set-ftos value		Set TOS field in packet header to value\n"
+"  		                This value can be in decimal (ex: 32)\n"
+"               		or in hex (ex: 0x20)\n"
+);
+}
+
+static struct option opts[] = {
+	{ "set-ftos", 1, 0, 'F' },
+	{ 0 }
+};
+
+static void
+parse_ftos(const unsigned char *s, struct ipt_FTOS_info *finfo)
+{
+	unsigned int ftos;
+       
+	if (string_to_number(s, 0, 255, &ftos) == -1)
+		exit_error(PARAMETER_PROBLEM,
+			   "Invalid ftos `%s'\n", s);
+    	finfo->ftos = (u_int8_t )ftos;
+    	return;
+}
+
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      struct ipt_entry_target **target)
+{
+	struct ipt_FTOS_info *finfo
+		= (struct ipt_FTOS_info *)(*target)->data;
+
+	switch (c) {
+	case 'F':
+		if (*flags)
+			exit_error(PARAMETER_PROBLEM,
+			           "FTOS target: Only use --set-ftos ONCE!");
+		parse_ftos(optarg, finfo);
+		*flags = 1;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+static void
+final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM,
+		           "FTOS target: Parameter --set-ftos is required");
+}
+
+static void
+print_ftos(u_int8_t ftos, int numeric)
+{
+ 	printf("0x%02x ", ftos);
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_target *target,
+      int numeric)
+{
+	const struct ipt_FTOS_info *finfo =
+		(const struct ipt_FTOS_info *)target->data;
+	printf("TOS set ");
+	print_ftos(finfo->ftos, numeric);
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_target *target)
+{
+	const struct ipt_FTOS_info *finfo =
+		(const struct ipt_FTOS_info *)target->data;
+
+	printf("--set-ftos 0x%02x ", finfo->ftos);
+}
+
+static struct iptables_target ftos = {
+	.next		= NULL,
+	.name		= "FTOS",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_FTOS_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_FTOS_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_target(&ftos);
+}
--- iptables/extensions/libipt_fuzzy.c
+++ iptables/extensions/libipt_fuzzy.c
@@ -0,0 +1,158 @@
+/* 
+   Shared library add-on to iptables to add match support for the fuzzy match.
+   
+   This file is distributed under the terms of the GNU General Public
+   License (GPL). Copies of the GPL can be obtained from:
+   ftp://prep.ai.mit.edu/pub/gnu/GPL
+
+2002-08-07 Hime Aguiar e Oliveira Jr. <hime@engineer.com> : Initial version.
+2003-06-09 Hime Aguiar e Oliveira Jr. <hime@engineer.com> : Bug corrections in
+the save function , thanks to information given by Jean-Francois Patenaude .
+
+*/
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <syslog.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_fuzzy.h>
+
+
+static void
+help(void)
+{
+	printf(
+"fuzzy v%s options:\n"
+"                      --lower-limit number (in packets per second)\n"
+"                      --upper-limit number\n"
+,IPTABLES_VERSION);
+};
+
+static struct option opts[] = {
+	{ "lower-limit", 1 , 0 , '1' } ,
+	{ "upper-limit", 1 , 0 , '2' } ,
+	{ 0 }
+};
+
+/* Initialize data structures */
+static void
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	struct ipt_fuzzy_info *presentinfo = (struct ipt_fuzzy_info *)(m)->data;
+
+	/*
+	 * Default rates ( I'll improve this very soon with something based 
+	 * on real statistics of the running machine ) .
+	*/
+
+	presentinfo->minimum_rate = 1000;
+	presentinfo->maximum_rate = 2000;
+}
+
+#define IPT_FUZZY_OPT_MINIMUM	0x01
+#define IPT_FUZZY_OPT_MAXIMUM	0x02
+
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+
+struct ipt_fuzzy_info *fuzzyinfo = (struct ipt_fuzzy_info *)(*match)->data;
+
+	u_int32_t num;
+
+	switch (c) {
+
+	case '1':
+		
+	if (invert)
+	       	exit_error(PARAMETER_PROBLEM,"Can't specify ! --lower-limit");
+
+	if (*flags & IPT_FUZZY_OPT_MINIMUM)
+       	      exit_error(PARAMETER_PROBLEM,"Can't specify --lower-limit twice");
+	
+	if (string_to_number(optarg,1,MAXFUZZYRATE,&num) == -1 || num < 1)
+			exit_error(PARAMETER_PROBLEM,"BAD --lower-limit");
+
+		fuzzyinfo->minimum_rate = num ;
+
+		*flags |= IPT_FUZZY_OPT_MINIMUM;
+		
+		break;
+
+	case '2':
+
+	if (invert)
+		exit_error(PARAMETER_PROBLEM,"Can't specify ! --upper-limit");
+
+	if (*flags & IPT_FUZZY_OPT_MAXIMUM)
+	   exit_error(PARAMETER_PROBLEM,"Can't specify --upper-limit twice");
+
+	if (string_to_number(optarg,1,MAXFUZZYRATE,&num) == -1 || num < 1)
+		exit_error(PARAMETER_PROBLEM,"BAD --upper-limit");
+
+		fuzzyinfo->maximum_rate = num ;
+
+		*flags |= IPT_FUZZY_OPT_MAXIMUM;
+
+		break ;
+
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+static void final_check(unsigned int flags)
+{
+}
+
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	const struct ipt_fuzzy_info *fuzzyinfo
+		= (const struct ipt_fuzzy_info *)match->data;
+
+	printf(" fuzzy: lower limit = %u pps - upper limit = %u pps ",fuzzyinfo->minimum_rate,fuzzyinfo->maximum_rate);
+
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	const struct ipt_fuzzy_info *fuzzyinfo
+		= (const struct ipt_fuzzy_info *)match->data;
+
+	printf("--lower-limit %u ",fuzzyinfo->minimum_rate);
+	printf("--upper-limit %u ",fuzzyinfo->maximum_rate);
+
+}
+
+static struct iptables_match fuzzy_match = { 
+	.next 		= NULL,
+	.name		= "fuzzy",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_fuzzy_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_fuzzy_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_match(&fuzzy_match);
+}
--- iptables/extensions/libipt_fuzzy.man
+++ iptables/extensions/libipt_fuzzy.man
@@ -0,0 +1,7 @@
+This module matches a rate limit based on a fuzzy logic controller [FLC]
+.TP
+.BI "--lower-limit " "number"
+Specifies the lower limit (in packets per second).
+.TP
+.BI "--upper-limit " "number"
+Specifies the upper limit (in packets per second).
--- iptables/extensions/libipt_geoip.c
+++ iptables/extensions/libipt_geoip.c
@@ -0,0 +1,338 @@
+/* Shared library add-on to iptables to add geoip match support.
+ 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * Copyright (c) 2004 Cookinglinux
+ 
+ * For comments, bugs or suggestions, please contact
+ * Samuel Jean       <sjean at cookinglinux.org>
+ * Nicolas Bouliane  <nib at cookinglinux.org>
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+#include <stddef.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_geoip.h>
+
+static void help(void)
+{
+   printf (
+            "GeoIP v%s options:\n"
+            "        [!]   --src-cc, --source-country country[,country,country,...]\n"
+            "                                                     Match packet coming from (one of)\n"
+            "                                                     the specified country(ies)\n"
+            "\n"
+            "        [!]   --dst-cc, --destination-country country[,country,country,...]\n"
+            "                                                     Match packet going to (one of)\n"
+            "                                                     the specified country(ies)\n"
+            "\n"
+            "           NOTE: The country is inputed by its ISO3166 code.\n"
+            "\n"
+            "\n", IPTABLES_VERSION
+         );
+}
+
+static struct option opts[] = {
+   {  "dst-cc",  1, 0, '2'  }, /* Alias for --destination-country */
+   {  "destination-country",   1, 0, '2'  },
+   {  "src-cc",  1, 0, '1'  }, /* Alias for --source-country */
+   {  "source-country",  1, 0, '1'  },
+   {  0  }
+};
+
+static void 
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+}
+
+/* NOT IMPLEMENTED YET
+static void geoip_free(struct geoip_info *oldmem)
+{
+}
+*/
+
+struct geoip_index {
+   u_int16_t cc;
+   u_int32_t offset;
+} __attribute__ ((packed));
+
+struct geoip_subnet *
+get_country_subnets(u_int16_t cc, u_int32_t *count)
+{
+   FILE *ixfd, *dbfd;
+   struct geoip_subnet *subnets;
+   struct geoip_index *index;
+   struct stat buf;
+  
+   size_t idxsz;
+   u_int16_t i;
+   
+   u_int16_t db_cc = 0;
+   u_int16_t db_nsubnets = 0;
+
+   if ((ixfd = fopen("/var/geoip/geoipdb.idx", "r")) == NULL) {
+         perror("/var/geoip/geoipdb.idx");
+         exit_error(OTHER_PROBLEM,
+               "geoip match: cannot open geoip's database index file");               
+   }
+   
+   stat("/var/geoip/geoipdb.idx", &buf);
+   idxsz = buf.st_size/sizeof(struct geoip_index);
+   index = (struct geoip_index *)malloc(buf.st_size);
+
+   fread(index, buf.st_size, 1, ixfd);
+
+   for (i = 0; i < idxsz; i++)
+      if (cc == index[i].cc)
+         break;
+   
+   if (cc != index[i].cc)
+      exit_error(OTHER_PROBLEM,
+            "geoip match: sorry, '%c%c' isn't in the database\n", COUNTRY(cc));
+
+   fclose(ixfd);
+
+   if ((dbfd = fopen("/var/geoip/geoipdb.bin", "r")) == NULL) {
+      perror("/var/geoip/geoipdb.bin");
+      exit_error(OTHER_PROBLEM,
+            "geoip match: cannot open geoip's database file");
+   }
+
+   fseek(dbfd, index[i].offset, SEEK_SET);
+   fread(&db_cc, sizeof(u_int16_t), 1, dbfd);
+
+   if (db_cc != cc)
+      exit_error(OTHER_PROBLEM,
+            "geoip match: this shouldn't happened, the database might be corrupted, or there's a bug.\n"
+            "you should contact maintainers");
+            
+   fread(&db_nsubnets, sizeof(u_int16_t), 1, dbfd);
+
+   subnets = (struct geoip_subnet*)malloc(db_nsubnets * sizeof(struct geoip_subnet));
+
+   if (!subnets)
+      exit_error(OTHER_PROBLEM,
+            "geoip match: insufficient memory available");
+   
+   fread(subnets, db_nsubnets * sizeof(struct geoip_subnet), 1, dbfd);
+   
+   fclose(dbfd);
+   free(index);
+   *count = db_nsubnets;
+   return subnets;
+}
+ 
+static struct geoip_info *
+load_geoip_cc(u_int16_t cc)
+{
+   static struct geoip_info *ginfo;
+   ginfo = malloc(sizeof(struct geoip_info));
+
+   if (!ginfo)
+      return NULL;
+   
+   ginfo->subnets = get_country_subnets(cc, &ginfo->count);
+   ginfo->cc = cc;
+   
+   return ginfo;
+}
+
+static u_int16_t
+check_geoip_cc(char *cc, u_int16_t cc_used[], u_int8_t count)
+{
+   u_int8_t i;
+   u_int16_t cc_int16;
+
+   if (strlen(cc) != 2) /* Country must be 2 chars long according
+                                        to the ISO3166 standard */
+    exit_error(PARAMETER_PROBLEM,
+         "geoip match: invalid country code '%s'", cc);
+
+   // Verification will fail if chars aren't uppercased.
+   // Make sure they are..
+   for (i = 0; i < 2; i++)
+      if (isalnum(cc[i]) != 0)
+         cc[i] = toupper(cc[i]);
+      else
+         exit_error(PARAMETER_PROBLEM,
+               "geoip match:  invalid country code '%s'", cc);
+
+   /* Convert chars into a single 16 bit integer.
+    * FIXME:   This assumes that a country code is
+    *          exactly 2 chars long. If this is
+    *          going to change someday, this whole
+    *          match will need to be rewritten, anyway.
+    *                                  - SJ  */
+   cc_int16 = (cc[0]<<8) + cc[1];
+
+   // Check for presence of value in cc_used
+   for (i = 0; i < count; i++)
+      if (cc_int16 == cc_used[i])
+         return 0; // Present, skip it!
+   
+   return cc_int16;
+}
+
+/* Based on libipt_multiport.c parsing code. */ 
+static u_int8_t
+parse_geoip_cc(const char *ccstr, u_int16_t *cc, struct geoip_info **mem)
+{
+   char *buffer, *cp, *next;
+   u_int8_t i, count = 0;
+   u_int16_t cctmp;
+
+   buffer = strdup(ccstr);
+   if (!buffer) exit_error(OTHER_PROBLEM,
+         "geoip match: insufficient memory available");
+
+   for (cp = buffer, i = 0; cp && i < IPT_GEOIP_MAX; cp = next, i++)
+   {
+      next = strchr(cp, ',');
+      if (next) *next++ = '\0';
+      
+      if ((cctmp = check_geoip_cc(cp, cc, count)) != 0) {
+         if ((mem[count++] = load_geoip_cc(cctmp)) == NULL)
+            exit_error(OTHER_PROBLEM,
+                  "geoip match: insufficient memory available");
+         cc[count-1] = cctmp;
+         }
+   }
+   
+   if (cp) exit_error(PARAMETER_PROBLEM,
+         "geoip match: too many countries specified");
+   free(buffer);
+
+   if (count == 0) exit_error(PARAMETER_PROBLEM,
+         "geoip match: don't know what happened");
+   
+   return count;
+}
+
+static int 
+parse(int c, char **argv, int invert, unsigned int *flags,
+                 const struct ipt_entry *entry,
+                 unsigned int *nfcache,
+                 struct ipt_entry_match **match)
+{
+   struct ipt_geoip_info *info
+      = (struct ipt_geoip_info *)(*match)->data;
+  
+    switch(c) {
+      case '1':
+         // Ensure that IPT_GEOIP_SRC *OR* IPT_GEOIP_DST haven't been used yet.
+         if (*flags & (IPT_GEOIP_SRC | IPT_GEOIP_DST))
+            exit_error(PARAMETER_PROBLEM,
+                  "geoip match: only use --source-country *OR* --destination-country once!");
+ 
+         *flags |= IPT_GEOIP_SRC;
+         *nfcache |= NFC_IP_SRC;
+         break;
+         
+      case '2':
+         // Ensure that IPT_GEOIP_SRC *OR* IPT_GEOIP_DST haven't been used yet.
+         if (*flags & (IPT_GEOIP_SRC | IPT_GEOIP_DST))
+            exit_error(PARAMETER_PROBLEM,
+                  "geoip match: only use --source-country *OR* --destination-country once!");
+ 
+         *flags |= IPT_GEOIP_DST;
+         *nfcache |= NFC_IP_DST;
+         break;
+      
+      default:
+         return 0;
+    }
+    
+    if (invert)
+       *flags |= IPT_GEOIP_INV;
+   
+    info->count = parse_geoip_cc(argv[optind-1], info->cc, info->mem);
+    info->flags = *flags;
+    info->refcount = NULL;
+    //info->fini = &geoip_free;
+
+    return 1;
+}
+
+static void 
+final_check(unsigned int flags)
+{
+   if (!flags)
+      exit_error(PARAMETER_PROBLEM,
+            "geoip match: missing arguments");
+}
+
+static void 
+print(const struct ipt_ip *ip,
+                  const struct ipt_entry_match *match,
+                  int numeric)
+{
+   const struct ipt_geoip_info *info
+      = (const struct ipt_geoip_info *)match->data;
+   
+   u_int8_t i;
+   
+   if (info->flags & IPT_GEOIP_SRC)
+      printf("Source ");
+   else printf("Destination ");
+   
+   if (info->count > 1)
+      printf("countries: ");
+   else printf("country: ");
+   
+   if (info->flags & IPT_GEOIP_INV)
+      printf("! ");
+      
+   for (i = 0; i < info->count; i++)
+       printf("%s%c%c", i ? "," : "", COUNTRY(info->cc[i]));
+   printf(" ");
+}
+
+static void 
+save(const struct ipt_ip *ip,
+                 const struct ipt_entry_match *match)
+{
+   const struct ipt_geoip_info *info
+      = (const struct ipt_geoip_info *)match->data;
+   u_int8_t i;
+
+   if (info->flags & IPT_GEOIP_INV)
+      printf("! ");
+ 
+   if (info->flags & IPT_GEOIP_SRC)
+      printf("--source-country ");
+   else printf("--destination-country ");
+      
+   for (i = 0; i < info->count; i++)
+      printf("%s%c%c", i ? "," : "", COUNTRY(info->cc[i]));
+   printf(" ");
+}
+
+static struct iptables_match geoip = {
+    .name            = "geoip",
+    .version         = IPTABLES_VERSION,
+    .size            = IPT_ALIGN(sizeof(struct ipt_geoip_info)),
+    .userspacesize   = offsetof(struct ipt_geoip_info, mem),
+    .help            = &help,
+    .init            = &init,
+    .parse           = &parse,
+    .final_check     = &final_check,
+    .print           = &print,
+    .save            = &save,
+    .extra_opts      = opts
+};
+
+void _init(void)
+{
+   register_match(&geoip);
+}
--- iptables/extensions/libipt_geoip.man
+++ iptables/extensions/libipt_geoip.man
@@ -0,0 +1,15 @@
+Match a packet by its source or destination country.
+.TP
+[\fB!\fR] \fB--src-cc\fR, \fB--source-country \fIcountry\fR[\fB,\fIcountry\fB,\fIcountry\fB,\fI...\fR]
+Match packet coming from (one of) the specified country(ies)
+.TP
+[\fB!\fR] \fB--dst-cc\fR, \fB--destination-country \fIcountry\fR[\fB,\fIcountry\fB,\fIcountry\fB,\fI...\fR]
+Match packet going to (one of) the specified country(ies)
+.TP
+NOTE:
+The country is inputed by its ISO3166 code.
+.P
+The only extra files you need is a binary db (geoipdb.bin) & its index file (geoipdb.idx).
+Both files are generated from a countries & subnets database with the csv2bin tool,
+available at www.cookinglinux.org/geoip/. Both files MUST also be moved in /var/geoip/
+as the shared library is statically looking for that pathname (ex.: /var/geoip/geoipdb.bin).
--- iptables/extensions/libipt_IMQ.c
+++ iptables/extensions/libipt_IMQ.c
@@ -0,0 +1,101 @@
+/* Shared library add-on to iptables to add IMQ target support. */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_IMQ.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"IMQ target v%s options:\n"
+"  --todev <N>		enqueue to imq<N>, defaults to 0\n", 
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "todev", 1, 0, '1' },
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ipt_entry_target *t, unsigned int *nfcache)
+{
+	struct ipt_imq_info *mr = (struct ipt_imq_info*)t->data;
+
+	mr->todev = 0;
+	*nfcache |= NFC_UNKNOWN;
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      struct ipt_entry_target **target)
+{
+	struct ipt_imq_info *mr = (struct ipt_imq_info*)(*target)->data;
+	
+	switch(c) {
+	case '1':
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --todev");
+		mr->todev=atoi(optarg);
+		break;
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+static void
+final_check(unsigned int flags)
+{
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_target *target,
+      int numeric)
+{
+	struct ipt_imq_info *mr = (struct ipt_imq_info*)target->data;
+
+	printf("IMQ: todev %u ", mr->todev);
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_target *target)
+{
+	struct ipt_imq_info *mr = (struct ipt_imq_info*)target->data;
+
+	printf("--todev %u", mr->todev);
+}
+
+static struct iptables_target imq = {
+	.next		= NULL,
+	.name		= "IMQ",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_imq_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_imq_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_target(&imq);
+}
--- iptables/extensions/libipt_IPMARK.c
+++ iptables/extensions/libipt_IPMARK.c
@@ -0,0 +1,168 @@
+/* Shared library add-on to iptables to add IPMARK target support.
+ * (C) 2003 by Grzegorz Janoszka <Grzegorz.Janoszka@pro.onet.pl>
+ *
+ * based on original MARK target
+ * 
+ * This program is distributed under the terms of GNU GPL
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_IPMARK.h>
+
+#define IPT_ADDR_USED        1
+#define IPT_AND_MASK_USED    2
+#define IPT_OR_MASK_USED     4
+
+struct ipmarkinfo {
+	struct ipt_entry_target t;
+	struct ipt_ipmark_target_info ipmark;
+};
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"IPMARK target v%s options:\n"
+"  --addr src/dst         use source or destination ip address\n"
+"  --and-mask value       logical AND ip address with this value becomes MARK\n"
+"  --or-mask value        logical OR ip address with this value becomes MARK\n"
+"\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "addr", 1, 0, '1' },
+	{ "and-mask", 1, 0, '2' },
+	{ "or-mask", 1, 0, '3' },
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ipt_entry_target *t, unsigned int *nfcache)
+{
+	struct ipt_ipmark_target_info *ipmarkinfo =
+		(struct ipt_ipmark_target_info *)t->data;
+
+	ipmarkinfo->andmask=0xffffffff;
+	ipmarkinfo->ormask=0;
+
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      struct ipt_entry_target **target)
+{
+	struct ipt_ipmark_target_info *ipmarkinfo
+		= (struct ipt_ipmark_target_info *)(*target)->data;
+
+	switch (c) {
+		char *end;
+	case '1':
+		if(!strcmp(optarg, "src")) ipmarkinfo->addr=IPT_IPMARK_SRC;
+		  else if(!strcmp(optarg, "dst")) ipmarkinfo->addr=IPT_IPMARK_DST;
+		    else exit_error(PARAMETER_PROBLEM, "Bad addr value `%s' - should be `src' or `dst'", optarg);
+		if (*flags & IPT_ADDR_USED)
+			exit_error(PARAMETER_PROBLEM,
+			           "IPMARK target: Can't specify --addr twice");
+		*flags |= IPT_ADDR_USED;
+		break;
+	
+	case '2':
+		ipmarkinfo->andmask = strtoul(optarg, &end, 0);
+		if (*end != '\0' || end == optarg)
+			exit_error(PARAMETER_PROBLEM, "Bad and-mask value `%s'", optarg);
+		if (*flags & IPT_AND_MASK_USED)
+			exit_error(PARAMETER_PROBLEM,
+			           "IPMARK target: Can't specify --and-mask twice");
+		*flags |= IPT_AND_MASK_USED;
+		break;
+	case '3':
+		ipmarkinfo->ormask = strtoul(optarg, &end, 0);
+		if (*end != '\0' || end == optarg)
+			exit_error(PARAMETER_PROBLEM, "Bad or-mask value `%s'", optarg);
+		if (*flags & IPT_OR_MASK_USED)
+			exit_error(PARAMETER_PROBLEM,
+			           "IPMARK target: Can't specify --or-mask twice");
+		*flags |= IPT_OR_MASK_USED;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+static void
+final_check(unsigned int flags)
+{
+	if (!(flags & IPT_ADDR_USED))
+		exit_error(PARAMETER_PROBLEM,
+		           "IPMARK target: Parameter --addr is required");
+	if (!(flags & (IPT_AND_MASK_USED | IPT_OR_MASK_USED)))
+		exit_error(PARAMETER_PROBLEM,
+		           "IPMARK target: Parameter --and-mask or --or-mask is required");
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_target *target,
+      int numeric)
+{
+	const struct ipt_ipmark_target_info *ipmarkinfo =
+		(const struct ipt_ipmark_target_info *)target->data;
+
+	if(ipmarkinfo->addr == IPT_IPMARK_SRC)
+	  printf("IPMARK src");
+	else
+	  printf("IPMARK dst");
+	printf(" ip and 0x%lx or 0x%lx", ipmarkinfo->andmask, ipmarkinfo->ormask);
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_target *target)
+{
+	const struct ipt_ipmark_target_info *ipmarkinfo =
+		(const struct ipt_ipmark_target_info *)target->data;
+
+	if(ipmarkinfo->addr == IPT_IPMARK_SRC)
+	  printf("--addr=src ");
+	else
+	  printf("--addr=dst ");
+	if(ipmarkinfo->andmask != 0xffffffff)
+	  printf("--and-mask 0x%lx ", ipmarkinfo->andmask);
+	if(ipmarkinfo->ormask != 0)
+	  printf("--or-mask 0x%lx ", ipmarkinfo->ormask);
+}
+
+static struct iptables_target ipmark = { 
+	.next		= NULL,
+	.name		= "IPMARK",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_ipmark_target_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_ipmark_target_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_target(&ipmark);
+}
--- iptables/extensions/libipt_IPMARK.man
+++ iptables/extensions/libipt_IPMARK.man
@@ -0,0 +1,45 @@
+Allows you to mark a received packet basing on its IP address. This
+can replace many mangle/mark entries with only one, if you use
+firewall based classifier.
+
+This target is to be used inside the mangle table, in the PREROUTING,
+POSTROUTING or FORWARD hooks.
+.TP
+.BI "--addr " "src/dst"
+Use source or destination IP address.
+.TP
+.BI "--and-mask " "mask"
+Perform bitwise `and' on the IP address and this mask.
+.TP
+.BI "--or-mask " "mask"
+Perform bitwise `or' on the IP address and this mask.
+.P
+The order of IP address bytes is reversed to meet "human order of bytes":
+192.168.0.1 is 0xc0a80001. At first the `and' operation is performed, then
+`or'.
+
+Examples:
+
+We create a queue for each user, the queue number is adequate
+to the IP address of the user, e.g.: all packets going to/from 192.168.5.2
+are directed to 1:0502 queue, 192.168.5.12 -> 1:050c etc.
+
+We have one classifier rule:
+.IP
+tc filter add dev eth3 parent 1:0 protocol ip fw
+.P
+Earlier we had many rules just like below:
+.IP
+iptables -t mangle -A POSTROUTING -o eth3 -d 192.168.5.2 -j MARK
+--set-mark 0x10502
+.IP
+iptables -t mangle -A POSTROUTING -o eth3 -d 192.168.5.3 -j MARK
+--set-mark 0x10503
+.P
+Using IPMARK target we can replace all the mangle/mark rules with only one:
+.IP
+iptables -t mangle -A POSTROUTING -o eth3 -j IPMARK --addr=dst
+--and-mask=0xffff --or-mask=0x10000
+.P
+On the routers with hundreds of users there should be significant load
+decrease (e.g. twice).
--- iptables/extensions/libipt_ipp2p_K24.c
+++ iptables/extensions/libipt_ipp2p_K24.c
@@ -0,0 +1,424 @@
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+
+#include <iptables.h>
+
+#include <linux/netfilter_ipv4/ipt_ipp2p.h>
+
+#ifndef XTABLES_VERSION
+#define XTABLES_VERSION IPTABLES_VERSION
+#endif
+
+#ifdef IPT_LIB_DIR
+#define xtables_match iptables_match
+#define xtables_register_match register_match
+#endif
+
+static void
+help(void)
+{
+    printf(
+    "IPP2P v%s options:\n"
+    " --ipp2p	Grab all known p2p packets\n"
+    " --edk		[TCP&UDP]	All known eDonkey/eMule/Overnet packets\n"
+    " --dc		[TCP] 		All known Direct Connect packets\n"
+    " --kazaa	[TCP&UDP] 	All known KaZaA packets\n"
+    " --gnu		[TCP&UDP]	All known Gnutella packets\n"
+    " --bit		[TCP&UDP]	All known BitTorrent packets\n"
+    " --apple	[TCP] 		All known AppleJuice packets\n"
+    " --winmx	[TCP] 		All known WinMX\n"
+    " --soul		[TCP] 		All known SoulSeek\n"
+    " --ares		[TCP] 		All known Ares\n\n"
+    " EXPERIMENTAL protocols (please send feedback to: ipp2p@ipp2p.org) :\n"
+    " --mute		[TCP]		All known Mute packets\n"
+    " --waste	[TCP]		All known Waste packets\n"
+    " --xdcc		[TCP]		All known XDCC packets (only xdcc login)\n\n"
+    " DEBUG SUPPPORT, use only if you know why\n"
+    " --debug		Generate kernel debug output, THIS WILL SLOW DOWN THE FILTER\n"
+    "\nNote that the follwing options will have the same meaning:\n"
+    " '--ipp2p' is equal to '--edk --dc --kazaa --gnu --bit --apple --winmx --soul --ares'\n"
+    "\nIPP2P was intended for TCP only. Due to increasing usage of UDP we needed to change this.\n"
+    "You can now use -p udp to search UDP packets only or without -p switch to search UDP and TCP packets.\n"
+    "\nSee README included with this package for more details or visit http://www.ipp2p.org\n"
+    "\nExamples:\n"
+    " iptables -A FORWARD -m ipp2p --ipp2p -j MARK --set-mark 0x01\n"
+    " iptables -A FORWARD -p udp -m ipp2p --kazaa --bit -j DROP\n"
+    " iptables -A FORWARD -p tcp -m ipp2p --edk --soul -j DROP\n\n"
+    , IPP2P_VERSION);
+}
+
+static struct option opts[] = {
+        { "ipp2p", 0, 0, '1' },
+        { "edk", 0, 0, '2' },	
+	{ "dc", 0, 0, '7' },
+	{ "gnu", 0, 0, '9' },
+	{ "kazaa", 0, 0, 'a' },
+	{ "bit", 0, 0, 'b' },
+	{ "apple", 0, 0, 'c' },	
+	{ "soul", 0, 0, 'd' },	
+	{ "winmx", 0, 0, 'e' },	
+	{ "ares", 0, 0, 'f' },
+	{ "mute", 0, 0, 'g' },
+	{ "waste", 0, 0, 'h' },
+	{ "xdcc", 0, 0, 'i' },
+	{ "debug", 0, 0, 'j' },
+        {0}
+};
+
+
+static void
+#ifdef _XTABLES_H
+init(struct xt_entry_match *m)
+#else
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+#endif
+{
+    struct ipt_p2p_info *info = (struct ipt_p2p_info *)m->data;
+
+#ifndef _XTABLES_H
+    *nfcache |= NFC_UNKNOWN;
+#endif
+
+    /*init the module with default values*/
+    info->cmd = 0;
+    info->debug = 0;
+
+}
+
+
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+#ifdef _XTABLES_H
+      const void *entry, struct xt_entry_match **match)
+#else
+      const struct ipt_entry *entry, unsigned int *nfcache, struct ipt_entry_match **match)
+#endif
+{
+    struct ipt_p2p_info *info = (struct ipt_p2p_info *)(*match)->data;
+    
+    switch (c) {
+	case '1':		/*cmd: ipp2p*/
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified once!");
+
+/*	    if ((*flags & SHORT_HAND_DATA) == SHORT_HAND_DATA)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p-data' may only be "
+				"specified alone!");
+*/
+
+	    if ((*flags) != 0)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+	    *flags += SHORT_HAND_IPP2P;
+	    info->cmd = *flags;
+	    break;
+	    
+	case '2':		/*cmd: edk*/
+	    if ((*flags & IPP2P_EDK) == IPP2P_EDK)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--edk' may only be "
+				"specified once");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+/*	    if ((*flags & SHORT_HAND_DATA) == SHORT_HAND_DATA)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p-data' may only be "
+				"specified alone!");*/
+            if ((*flags & IPP2P_DATA_EDK) == IPP2P_DATA_EDK)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: use `--edk' OR `--edk-data' but not both of them!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+	    *flags += IPP2P_EDK;
+	    info->cmd = *flags;	    
+	    break;
+
+
+	case '7':		/*cmd: dc*/
+            if ((*flags & IPP2P_DC) == IPP2P_DC)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--dc' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+/*	    if ((*flags & SHORT_HAND_DATA) == SHORT_HAND_DATA)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p-data' may only be "
+				"specified alone!");*/
+            if ((*flags & IPP2P_DATA_DC) == IPP2P_DATA_DC)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: use `--dc' OR `--dc-data' but not both of them!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_DC;
+	    info->cmd = *flags;
+	    break;
+
+
+	case '9':		/*cmd: gnu*/
+            if ((*flags & IPP2P_GNU) == IPP2P_GNU)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--gnu' may only be "
+                                "specified once!");
+/*	    if ((*flags & SHORT_HAND_DATA) == SHORT_HAND_DATA)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p-data' may only be "
+				"specified alone!");*/
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+            if ((*flags & IPP2P_DATA_GNU) == IPP2P_DATA_GNU)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: use `--gnu' OR `--gnu-data' but not both of them!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_GNU;
+	    info->cmd = *flags;
+	    break;
+
+	case 'a':		/*cmd: kazaa*/
+            if ((*flags & IPP2P_KAZAA) == IPP2P_KAZAA)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--kazaa' may only be "
+                                "specified once!");
+/*	    if ((*flags & SHORT_HAND_DATA) == SHORT_HAND_DATA)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p-data' may only be "
+				"specified alone!");*/
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+            if ((*flags & IPP2P_DATA_KAZAA) == IPP2P_DATA_KAZAA)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: use `--kazaa' OR `--kazaa-data' but not both of them!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_KAZAA;
+	    info->cmd = *flags;
+	    break;																											
+
+	case 'b':		/*cmd: bit*/
+            if ((*flags & IPP2P_BIT) == IPP2P_BIT)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--bit' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_BIT;
+	    info->cmd = *flags;
+	    break;																											
+
+	case 'c':		/*cmd: apple*/
+            if ((*flags & IPP2P_APPLE) == IPP2P_APPLE)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--apple' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_APPLE;
+	    info->cmd = *flags;
+	    break;																											
+
+
+	case 'd':		/*cmd: soul*/
+            if ((*flags & IPP2P_SOUL) == IPP2P_SOUL)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--soul' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_SOUL;
+	    info->cmd = *flags;
+	    break;																											
+
+
+	case 'e':		/*cmd: winmx*/
+            if ((*flags & IPP2P_WINMX) == IPP2P_WINMX)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--winmx' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_WINMX;
+	    info->cmd = *flags;
+	    break;																											
+
+	case 'f':		/*cmd: ares*/
+            if ((*flags & IPP2P_ARES) == IPP2P_ARES)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--ares' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_ARES;
+	    info->cmd = *flags;
+	    break;																											
+	
+	case 'g':		/*cmd: mute*/
+            if ((*flags & IPP2P_MUTE) == IPP2P_MUTE)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--mute' may only be "
+                                "specified once!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_MUTE;
+	    info->cmd = *flags;
+	    break;																											
+	case 'h':		/*cmd: waste*/
+            if ((*flags & IPP2P_WASTE) == IPP2P_WASTE)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--waste' may only be "
+                                "specified once!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_WASTE;
+	    info->cmd = *flags;
+	    break;																											
+	case 'i':		/*cmd: xdcc*/
+            if ((*flags & IPP2P_XDCC) == IPP2P_XDCC)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--ares' may only be "
+                                "specified once!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_XDCC;
+	    info->cmd = *flags;
+	    break;																											
+
+	case 'j':		/*cmd: debug*/
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+	    info->debug = 1;
+	    break;																											
+
+	default:
+//            exit_error(PARAMETER_PROBLEM,
+//	    "\nipp2p-parameter problem: for ipp2p usage type: iptables -m ipp2p --help\n");
+	    return 0;
+    }
+    return 1;
+}
+
+
+static void
+final_check(unsigned int flags)
+{
+    if (!flags)
+            exit_error(PARAMETER_PROBLEM,
+	    "\nipp2p-parameter problem: for ipp2p usage type: iptables -m ipp2p --help\n");
+}
+
+static void
+#ifdef _XTABLES_H
+print(const void *ip,
+      const struct xt_entry_match *match,
+#else
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+#endif
+	int numeric)
+{
+    struct ipt_p2p_info *info = (struct ipt_p2p_info *)match->data;
+    
+    printf("ipp2p v%s", IPP2P_VERSION);
+    if ((info->cmd & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P) printf(" --ipp2p");
+//    if ((info->cmd & SHORT_HAND_DATA) == SHORT_HAND_DATA) printf(" --ipp2p-data");
+    if ((info->cmd & IPP2P_KAZAA) == IPP2P_KAZAA) printf(" --kazaa");
+//    if ((info->cmd & IPP2P_DATA_KAZAA) == IPP2P_DATA_KAZAA) printf(" --kazaa-data");
+//    if ((info->cmd & IPP2P_DATA_GNU) == IPP2P_DATA_GNU) printf(" --gnu-data");
+    if ((info->cmd & IPP2P_GNU) == IPP2P_GNU) printf(" --gnu");
+    if ((info->cmd & IPP2P_EDK) == IPP2P_EDK) printf(" --edk");
+//    if ((info->cmd & IPP2P_DATA_EDK) == IPP2P_DATA_EDK) printf(" --edk-data");
+//    if ((info->cmd & IPP2P_DATA_DC) == IPP2P_DATA_DC) printf(" --dc-data");
+    if ((info->cmd & IPP2P_DC) == IPP2P_DC) printf(" --dc");
+    if ((info->cmd & IPP2P_BIT) == IPP2P_BIT) printf(" --bit");
+    if ((info->cmd & IPP2P_APPLE) == IPP2P_APPLE) printf(" --apple");
+    if ((info->cmd & IPP2P_SOUL) == IPP2P_SOUL) printf(" --soul");
+    if ((info->cmd & IPP2P_WINMX) == IPP2P_WINMX) printf(" --winmx");
+    if ((info->cmd & IPP2P_ARES) == IPP2P_ARES) printf(" --ares");
+    if ((info->cmd & IPP2P_MUTE) == IPP2P_MUTE) printf(" --mute");
+    if ((info->cmd & IPP2P_WASTE) == IPP2P_WASTE) printf(" --waste");
+    if ((info->cmd & IPP2P_XDCC) == IPP2P_XDCC) printf(" --xdcc");
+    if (info->debug != 0) printf(" --debug");
+    printf(" ");
+}
+
+static void
+#ifdef _XTABLES_H
+save(const void *ip,
+     const struct xt_entry_match *match)
+#else
+save(const struct ipt_ip *ip,
+     const struct ipt_entry_match *match)
+#endif
+{
+    struct ipt_p2p_info *info = (struct ipt_p2p_info *)match->data;
+    
+    if ((info->cmd & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P) printf("--ipp2p ");
+//    if ((info->cmd & SHORT_HAND_DATA) == SHORT_HAND_DATA) printf("--ipp2p-data ");
+    if ((info->cmd & IPP2P_KAZAA) == IPP2P_KAZAA) printf("--kazaa ");
+//    if ((info->cmd & IPP2P_DATA_KAZAA) == IPP2P_DATA_KAZAA) printf("--kazaa-data ");
+//    if ((info->cmd & IPP2P_DATA_GNU) == IPP2P_DATA_GNU) printf("--gnu-data ");
+    if ((info->cmd & IPP2P_GNU) == IPP2P_GNU) printf("--gnu ");
+    if ((info->cmd & IPP2P_EDK) == IPP2P_EDK) printf("--edk ");
+//    if ((info->cmd & IPP2P_DATA_EDK) == IPP2P_DATA_EDK) printf("--edk-data ");
+//    if ((info->cmd & IPP2P_DATA_DC) == IPP2P_DATA_DC) printf("--dc-data ");
+    if ((info->cmd & IPP2P_DC) == IPP2P_DC) printf("--dc ");
+    if ((info->cmd & IPP2P_BIT) == IPP2P_BIT) printf("--bit ");
+    if ((info->cmd & IPP2P_APPLE) == IPP2P_APPLE) printf("--apple ");
+    if ((info->cmd & IPP2P_SOUL) == IPP2P_SOUL) printf("--soul ");
+    if ((info->cmd & IPP2P_WINMX) == IPP2P_WINMX) printf("--winmx ");
+    if ((info->cmd & IPP2P_ARES) == IPP2P_ARES) printf("--ares ");
+    if ((info->cmd & IPP2P_MUTE) == IPP2P_MUTE) printf(" --mute");
+    if ((info->cmd & IPP2P_WASTE) == IPP2P_WASTE) printf(" --waste");
+    if ((info->cmd & IPP2P_XDCC) == IPP2P_XDCC) printf(" --xdcc");
+    if (info->debug != 0) printf("--debug ");
+}
+
+		
+static 
+struct xtables_match ipp2p= 
+{ 
+    .next           = NULL,
+    .name           = "ipp2p",
+    .version        = XTABLES_VERSION,
+    .size           = IPT_ALIGN(sizeof(struct ipt_p2p_info)),
+    .userspacesize  = IPT_ALIGN(sizeof(struct ipt_p2p_info)),
+    .help           = &help,
+    .init           = &init,
+    .parse          = &parse,
+    .final_check    = &final_check,
+    .print          = &print,
+    .save           = &save,
+    .extra_opts     = opts
+};
+					    
+
+
+void _init(void)
+{
+    xtables_register_match(&ipp2p);
+}
+
--- iptables/extensions/libipt_ipp2p_K26.c
+++ iptables/extensions/libipt_ipp2p_K26.c
@@ -0,0 +1,389 @@
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+
+#include <iptables.h>
+
+#include <linux/netfilter_ipv4/ipt_ipp2p.h>
+
+static void
+help(void)
+{
+    printf(
+    "IPP2P v%s options:\n"
+    " --ipp2p\tGrab all known p2p packets\n"
+    " --edk\t\t[TCP&UDP]\tAll known eDonkey/eMule/Overnet packets\n"
+    " --dc\t\t[TCP]\t\tAll known Direct Connect packets\n"
+    " --kazaa\t[TCP&UDP]\tAll known KaZaA packets\n"
+    " --gnu\t\t[TCP&UDP]\tAll known Gnutella packets\n"
+    " --bit\t\t[TCP&UDP]\tAll known BitTorrent packets\n"
+    " --apple\t[TCP]\t\tAll known AppleJuice packets\n"
+    " --winmx\t[TCP]\t\tAll known WinMX\n"
+    " --soul\t\t[TCP]\t\tAll known SoulSeek\n"
+    " --ares\t\t[TCP]\t\tAll known Ares\n"
+    " --pp\t\t[TCP&UDP]\tAll known PPLive/PPStream/UUSee/QQLive packets (Please send feedback to: liulei@syiae.edu.cn)\n"
+    " --xunlei\t[TCP]\t\tAll known xunlei/QQCyclone packets\n"
+    " EXPERIMENTAL protocols (please send feedback to: ipp2p@ipp2p.org) :\n"
+    " --mute\t\t[TCP]\t\tAll known Mute packets\n"
+    " --waste\t[TCP]\t\tAll known Waste packets\n"
+    " --xdcc\t\t[TCP]\t\tAll known XDCC packets (only xdcc login)\n\n"
+    " DEBUG SUPPPORT, use only if you know why\n"
+    " --debug\t\tGenerate kernel debug output, THIS WILL SLOW DOWN THE FILTER\n"
+    "\nNote that the follwing options will have the same meaning:\n"
+    " '--ipp2p' is equal to '--edk --dc --kazaa --gnu --bit --apple --winmx --soul --ares --pp'\n"
+    "\nIPP2P was intended for TCP only. Due to increasing usage of UDP we needed to change this.\n"
+    "You can now use -p udp to search UDP packets only or without -p switch to search UDP and TCP packets.\n"
+    "\nSee README included with this package for more details or visit http://www.ipp2p.org\n"
+    "\nExamples:\n"
+    " iptables -A FORWARD -m ipp2p --ipp2p -j MARK --set-mark 0x01\n"
+    " iptables -A FORWARD -p udp -m ipp2p --kazaa --bit -j DROP\n"
+    " iptables -A FORWARD -p tcp -m ipp2p --edk --soul -j DROP\n\n"
+    , IPP2P_VERSION);
+}
+
+static struct option opts[] = {
+        { "ipp2p", 0, 0, '1' },
+        { "edk", 0, 0, '2' },
+        { "pp", 0, 0, '3' },
+	{ "xunlei", 0, 0, '4'},
+	{ "dc", 0, 0, '7' },
+	{ "gnu", 0, 0, '9' },
+	{ "kazaa", 0, 0, 'a' },
+	{ "bit", 0, 0, 'b' },
+	{ "apple", 0, 0, 'c' },
+	{ "soul", 0, 0, 'd' },
+	{ "winmx", 0, 0, 'e' },
+	{ "ares", 0, 0, 'f' },
+	{ "mute", 0, 0, 'g' },
+	{ "waste", 0, 0, 'h' },
+	{ "xdcc", 0, 0, 'i' },
+	{ "debug", 0, 0, 'j' },
+        {0}
+};
+
+
+
+static void
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+    struct ipt_p2p_info *info = (struct ipt_p2p_info *)m->data;
+
+    *nfcache |= NFC_UNKNOWN;
+
+    /*init the module with default values*/
+    info->cmd = 0;
+    info->debug = 0;
+
+}
+
+
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+	const struct ipt_entry *entry,
+	unsigned int *nfcache,
+	struct ipt_entry_match **match)
+{
+    struct ipt_p2p_info *info = (struct ipt_p2p_info *)(*match)->data;
+
+    switch (c) {
+	case '1':		/*cmd: ipp2p*/
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified once!");
+	    if ((*flags) != 0)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+	    *flags += SHORT_HAND_IPP2P;
+	    info->cmd = *flags;
+	    break;
+
+	case '2':		/*cmd: edk*/
+	    if ((*flags & IPP2P_EDK) == IPP2P_EDK)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--edk' may only be "
+				"specified once");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+	    *flags += IPP2P_EDK;
+	    info->cmd = *flags;
+	    break;
+
+	case '3':		/*cmd: pp*/
+            if ((*flags & IPP2P_PP) == IPP2P_PP)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--pp' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_PP;
+	    info->cmd = *flags;
+	    break;
+
+	case '4':
+	    if ((*flags & IPP2P_XUNLEI) == IPP2P_XUNLEI)
+	    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--xunlei' may only be "
+				"specified once!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+	    *flags += IPP2P_XUNLEI;
+	    info->cmd = *flags;
+	    break;
+
+	case '7':		/*cmd: dc*/
+            if ((*flags & IPP2P_DC) == IPP2P_DC)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--dc' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_DC;
+	    info->cmd = *flags;
+	    break;
+
+
+	case '9':		/*cmd: gnu*/
+            if ((*flags & IPP2P_GNU) == IPP2P_GNU)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--gnu' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_GNU;
+	    info->cmd = *flags;
+	    break;
+
+	case 'a':		/*cmd: kazaa*/
+            if ((*flags & IPP2P_KAZAA) == IPP2P_KAZAA)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--kazaa' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_KAZAA;
+	    info->cmd = *flags;
+	    break;
+
+	case 'b':		/*cmd: bit*/
+            if ((*flags & IPP2P_BIT) == IPP2P_BIT)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--bit' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_BIT;
+	    info->cmd = *flags;
+	    break;
+
+	case 'c':		/*cmd: apple*/
+            if ((*flags & IPP2P_APPLE) == IPP2P_APPLE)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--apple' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_APPLE;
+	    info->cmd = *flags;
+	    break;
+
+
+	case 'd':		/*cmd: soul*/
+            if ((*flags & IPP2P_SOUL) == IPP2P_SOUL)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--soul' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_SOUL;
+	    info->cmd = *flags;
+	    break;
+
+
+	case 'e':		/*cmd: winmx*/
+            if ((*flags & IPP2P_WINMX) == IPP2P_WINMX)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--winmx' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_WINMX;
+	    info->cmd = *flags;
+	    break;
+
+	case 'f':		/*cmd: ares*/
+            if ((*flags & IPP2P_ARES) == IPP2P_ARES)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--ares' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_ARES;
+	    info->cmd = *flags;
+	    break;
+
+	case 'g':		/*cmd: mute*/
+            if ((*flags & IPP2P_MUTE) == IPP2P_MUTE)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--mute' may only be "
+                                "specified once!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_MUTE;
+	    info->cmd = *flags;
+	    break;
+	case 'h':		/*cmd: waste*/
+            if ((*flags & IPP2P_WASTE) == IPP2P_WASTE)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--waste' may only be "
+                                "specified once!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_WASTE;
+	    info->cmd = *flags;
+	    break;
+	case 'i':		/*cmd: xdcc*/
+            if ((*flags & IPP2P_XDCC) == IPP2P_XDCC)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--xdcc' may only be "
+                                "specified once!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_XDCC;
+	    info->cmd = *flags;
+	    break;
+
+	case 'j':		/*cmd: debug*/
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+	    info->debug = 1;
+	    break;
+
+	default:
+//            exit_error(PARAMETER_PROBLEM,
+//	    "\nipp2p-parameter problem: for ipp2p usage type: iptables -m ipp2p --help\n");
+	    return 0;
+    }
+    return 1;
+}
+
+
+static void
+final_check(unsigned int flags)
+{
+    if (!flags)
+            exit_error(PARAMETER_PROBLEM,
+	    "\nipp2p-parameter problem: for ipp2p usage type: iptables -m ipp2p --help\n");
+}
+
+
+
+static void
+print(const struct ipt_ip *ip,
+        const struct ipt_entry_match *match,
+	int numeric)
+{
+    struct ipt_p2p_info *info = (struct ipt_p2p_info *)match->data;
+
+    printf("ipp2p v%s", IPP2P_VERSION);
+    if ((info->cmd & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P) printf(" --ipp2p");
+    if ((info->cmd & IPP2P_KAZAA) == IPP2P_KAZAA) printf(" --kazaa");
+    if ((info->cmd & IPP2P_GNU) == IPP2P_GNU) printf(" --gnu");
+    if ((info->cmd & IPP2P_EDK) == IPP2P_EDK) printf(" --edk");
+    if ((info->cmd & IPP2P_DC) == IPP2P_DC) printf(" --dc");
+    if ((info->cmd & IPP2P_BIT) == IPP2P_BIT) printf(" --bit");
+    if ((info->cmd & IPP2P_PP) == IPP2P_PP) printf(" --pp");
+    if ((info->cmd & IPP2P_XUNLEI) == IPP2P_XUNLEI) printf(" --xunlei");
+    if ((info->cmd & IPP2P_APPLE) == IPP2P_APPLE) printf(" --apple");
+    if ((info->cmd & IPP2P_SOUL) == IPP2P_SOUL) printf(" --soul");
+    if ((info->cmd & IPP2P_WINMX) == IPP2P_WINMX) printf(" --winmx");
+    if ((info->cmd & IPP2P_ARES) == IPP2P_ARES) printf(" --ares");
+    if ((info->cmd & IPP2P_MUTE) == IPP2P_MUTE) printf(" --mute");
+    if ((info->cmd & IPP2P_WASTE) == IPP2P_WASTE) printf(" --waste");
+    if ((info->cmd & IPP2P_XDCC) == IPP2P_XDCC) printf(" --xdcc");
+    if (info->debug != 0) printf(" --debug");
+    printf(" ");
+}
+
+
+
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+    struct ipt_p2p_info *info = (struct ipt_p2p_info *)match->data;
+
+    if ((info->cmd & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P) printf("--ipp2p ");
+    if ((info->cmd & IPP2P_KAZAA) == IPP2P_KAZAA) printf("--kazaa ");
+    if ((info->cmd & IPP2P_GNU) == IPP2P_GNU) printf("--gnu ");
+    if ((info->cmd & IPP2P_EDK) == IPP2P_EDK) printf("--edk ");
+    if ((info->cmd & IPP2P_DC) == IPP2P_DC) printf("--dc ");
+    if ((info->cmd & IPP2P_BIT) == IPP2P_BIT) printf("--bit ");
+    if ((info->cmd & IPP2P_PP) == IPP2P_PP) printf("--pp ");
+    if ((info->cmd & IPP2P_XUNLEI) == IPP2P_XUNLEI) printf("--xunlei ");
+    if ((info->cmd & IPP2P_APPLE) == IPP2P_APPLE) printf("--apple ");
+    if ((info->cmd & IPP2P_SOUL) == IPP2P_SOUL) printf("--soul ");
+    if ((info->cmd & IPP2P_WINMX) == IPP2P_WINMX) printf("--winmx ");
+    if ((info->cmd & IPP2P_ARES) == IPP2P_ARES) printf("--ares ");
+    if ((info->cmd & IPP2P_MUTE) == IPP2P_MUTE) printf("--mute ");
+    if ((info->cmd & IPP2P_WASTE) == IPP2P_WASTE) printf("--waste ");
+    if ((info->cmd & IPP2P_XDCC) == IPP2P_XDCC) printf("--xdcc ");
+    if (info->debug != 0) printf("--debug ");
+}
+
+
+
+
+static
+struct iptables_match ipp2p=
+{
+    .next           = NULL,
+    .name           = "ipp2p",
+    .version        = IPTABLES_VERSION,
+    .size           = IPT_ALIGN(sizeof(struct ipt_p2p_info)),
+    .userspacesize  = IPT_ALIGN(sizeof(struct ipt_p2p_info)),
+    .help           = &help,
+    .init           = &init,
+    .parse          = &parse,
+    .final_check    = &final_check,
+    .print          = &print,
+    .save           = &save,
+    .extra_opts     = opts
+};
+
+
+
+void _init(void)
+{
+    register_match(&ipp2p);
+}
+
--- iptables/extensions/libipt_ipp2p.man
+++ iptables/extensions/libipt_ipp2p.man
@@ -0,0 +1,43 @@
+This module matches certain packets in P2P flows. It is not
+designed to match all packets belonging to a P2P connection - 
+use IPP2P together with CONNMARK for this purpose. Also visit
+http://www.ipp2p.org for detailed information.
+
+Use it together with -p tcp or -p udp to search these protocols
+only or without -p switch to search packets of both protocols.
+
+IPP2P provides the following options:
+.TP
+.B "--edk "
+Matches as many eDonkey/eMule packets as possible.
+.TP
+.B "--kazaa "
+Matches as many KaZaA packets as possible.
+.TP
+.B "--gnu "
+Matches as many Gnutella packets as possible.
+.TP
+.B "--dc "
+Matches as many Direct Connect packets as possible.
+.TP
+.B "--bit "
+Matches BitTorrent packets.
+.TP
+.B "--apple "
+Matches AppleJuice packets.
+.TP
+.B "--soul "
+Matches some SoulSeek packets. Considered as beta, use careful!
+.TP
+.B "--winmx "
+Matches some WinMX packets. Considered as beta, use careful!
+.TP
+.B "--ares "
+Matches Ares and AresLite packets. Use together with -j DROP only.
+.TP
+.B "--ipp2p "
+Short hand for: --edk --kazaa --gnu --dc
+.TP
+.B "--debug "
+Prints some information about each hit into kernel logfile. May 
+produce huge logfiles so beware!
--- iptables/extensions/libipt_ipv4options.c
+++ iptables/extensions/libipt_ipv4options.c
@@ -0,0 +1,333 @@
+/* Shared library add-on to iptables to add ipv4 options matching support. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_ipv4options.h>
+
+#ifndef XTABLES_VERSION
+#define XTABLES_VERSION IPTABLES_VERSION
+#endif
+
+#ifdef IPT_LIB_DIR
+#define xtables_target iptables_target
+#define xtables_register_target register_target
+#endif
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"ipv4options v%s options:\n"
+"      --ssrr    (match strict source routing flag)\n"
+"      --lsrr    (match loose  source routing flag)\n"
+"      --no-srr  (match packets with no source routing)\n\n"
+"  [!] --rr      (match record route flag)\n\n"
+"  [!] --ts      (match timestamp flag)\n\n"
+"  [!] --ra      (match router-alert option)\n\n"
+"  [!] --any-opt (match any option or no option at all if used with '!')\n",
+XTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "ssrr", 0, 0, '1' },
+	{ "lsrr", 0, 0, '2' },
+	{ "no-srr", 0, 0, '3'},
+	{ "rr", 0, 0, '4'},
+	{ "ts", 0, 0, '5'},
+	{ "ra", 0, 0, '6'},
+	{ "any-opt", 0, 0, '7'},
+	{0}
+};
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+#ifdef _XTABLES_H
+      const void *entry, struct xt_entry_match **match)
+#else
+      const struct ipt_entry *entry, unsigned int *nfcache, struct ipt_entry_match **match)
+#endif
+{
+	struct ipt_ipv4options_info *info = (struct ipt_ipv4options_info *)(*match)->data;
+
+	switch (c)
+	{
+		/* strict-source-routing */
+	case '1':
+		if (invert) 
+			exit_error(PARAMETER_PROBLEM,
+				   "ipv4options: unexpected `!' with --ssrr");
+		if (*flags & IPT_IPV4OPTION_MATCH_SSRR)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --ssrr twice");
+		if (*flags & IPT_IPV4OPTION_MATCH_LSRR)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --ssrr with --lsrr");
+		if (*flags & IPT_IPV4OPTION_DONT_MATCH_SRR)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --ssrr with --no-srr");
+
+		info->options |= IPT_IPV4OPTION_MATCH_SSRR;
+		*flags |= IPT_IPV4OPTION_MATCH_SSRR;
+		break;
+
+		/* loose-source-routing */
+	case '2':
+		if (invert) 
+			exit_error(PARAMETER_PROBLEM,
+				   "ipv4options: unexpected `!' with --lsrr");
+		if (*flags & IPT_IPV4OPTION_MATCH_SSRR)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --lsrr twice");
+		if (*flags & IPT_IPV4OPTION_MATCH_LSRR)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --lsrr with --ssrr");
+		if (*flags & IPT_IPV4OPTION_DONT_MATCH_SRR)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --lsrr with --no-srr");
+		info->options |= IPT_IPV4OPTION_MATCH_LSRR;
+		*flags |= IPT_IPV4OPTION_MATCH_LSRR;
+		break;
+
+		/* no-source-routing */
+	case '3':
+		if (invert) 
+			exit_error(PARAMETER_PROBLEM,
+					   "ipv4options: unexpected `!' with --no-srr");
+		if (*flags & IPT_IPV4OPTION_DONT_MATCH_SRR)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --no-srr twice");
+		if (*flags & IPT_IPV4OPTION_MATCH_SSRR)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --no-srr with --ssrr");
+		if (*flags & IPT_IPV4OPTION_MATCH_LSRR)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --no-srr with --lsrr");
+		info->options |= IPT_IPV4OPTION_DONT_MATCH_SRR;
+		*flags |= IPT_IPV4OPTION_DONT_MATCH_SRR;
+		break;
+
+		/* record-route */
+	case '4':
+		if ((!invert) && (*flags & IPT_IPV4OPTION_MATCH_RR))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --rr twice");	
+		if (invert && (*flags & IPT_IPV4OPTION_DONT_MATCH_RR))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --rr twice");
+		if ((!invert) && (*flags & IPT_IPV4OPTION_DONT_MATCH_RR))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --rr with ! --rr");
+		if (invert && (*flags & IPT_IPV4OPTION_MATCH_RR))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --rr with --rr");
+		if (invert) {
+			info->options |= IPT_IPV4OPTION_DONT_MATCH_RR;
+			*flags |= IPT_IPV4OPTION_DONT_MATCH_RR;
+		}
+		else {
+			info->options |= IPT_IPV4OPTION_MATCH_RR;
+			*flags |= IPT_IPV4OPTION_MATCH_RR;
+		}
+		break;
+
+		/* timestamp */
+	case '5':
+		if ((!invert) && (*flags & IPT_IPV4OPTION_MATCH_TIMESTAMP))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --ts twice");	
+		if (invert && (*flags & IPT_IPV4OPTION_DONT_MATCH_TIMESTAMP))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --ts twice");
+		if ((!invert) && (*flags & IPT_IPV4OPTION_DONT_MATCH_TIMESTAMP))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --ts with ! --ts");
+		if (invert && (*flags & IPT_IPV4OPTION_MATCH_TIMESTAMP))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --ts with --ts");
+		if (invert) {
+			info->options |= IPT_IPV4OPTION_DONT_MATCH_TIMESTAMP;
+			*flags |= IPT_IPV4OPTION_DONT_MATCH_TIMESTAMP;
+		}
+		else {
+			info->options |= IPT_IPV4OPTION_MATCH_TIMESTAMP;
+			*flags |= IPT_IPV4OPTION_MATCH_TIMESTAMP;
+		}
+		break;
+
+		/* router-alert  */
+	case '6':
+		if ((!invert) && (*flags & IPT_IPV4OPTION_MATCH_ROUTER_ALERT))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --ra twice");	
+		if (invert && (*flags & IPT_IPV4OPTION_DONT_MATCH_ROUTER_ALERT))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --rr twice");
+		if ((!invert) && (*flags & IPT_IPV4OPTION_DONT_MATCH_ROUTER_ALERT))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --ra with ! --ra");
+		if (invert && (*flags & IPT_IPV4OPTION_MATCH_ROUTER_ALERT))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --ra with --ra");
+		if (invert) {
+			info->options |= IPT_IPV4OPTION_DONT_MATCH_ROUTER_ALERT;
+			*flags |= IPT_IPV4OPTION_DONT_MATCH_ROUTER_ALERT;
+		}
+		else {
+			info->options |= IPT_IPV4OPTION_MATCH_ROUTER_ALERT;
+			*flags |= IPT_IPV4OPTION_MATCH_ROUTER_ALERT;
+		}
+		break;
+
+		/* any option */
+	case '7' :
+		if ((!invert) && (*flags & IPT_IPV4OPTION_MATCH_ANY_OPT))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --any-opt twice");
+		if (invert && (*flags & IPT_IPV4OPTION_MATCH_ANY_OPT))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --any-opt with --any-opt");
+		if (invert && (*flags & IPT_IPV4OPTION_DONT_MATCH_ROUTER_ALERT))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --any-opt twice");
+		if ((!invert) &&
+		    ((*flags & IPT_IPV4OPTION_DONT_MATCH_SRR)       ||
+		     (*flags & IPT_IPV4OPTION_DONT_MATCH_RR)        ||
+		     (*flags & IPT_IPV4OPTION_DONT_MATCH_TIMESTAMP) ||
+		     (*flags & IPT_IPV4OPTION_DONT_MATCH_ROUTER_ALERT)))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --any-opt with any other negative ipv4options match");
+		if (invert &&
+		    ((*flags & IPT_IPV4OPTION_MATCH_LSRR)      ||
+		     (*flags & IPT_IPV4OPTION_MATCH_SSRR)      ||
+		     (*flags & IPT_IPV4OPTION_MATCH_RR)        ||
+		     (*flags & IPT_IPV4OPTION_MATCH_TIMESTAMP) ||
+		     (*flags & IPT_IPV4OPTION_MATCH_ROUTER_ALERT)))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --any-opt with any other positive ipv4options match");
+		if (invert) {
+			info->options |= IPT_IPV4OPTION_DONT_MATCH_ANY_OPT;
+			*flags |= IPT_IPV4OPTION_DONT_MATCH_ANY_OPT;	
+		}
+		else {
+			info->options |= IPT_IPV4OPTION_MATCH_ANY_OPT;
+			*flags |= IPT_IPV4OPTION_MATCH_ANY_OPT;
+		}
+		break;
+
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+static void
+final_check(unsigned int flags)
+{
+	if (flags == 0)
+		exit_error(PARAMETER_PROBLEM,
+			   "ipv4options match: you must specify some parameters. See iptables -m ipv4options --help for help.'");
+}
+
+/* Prints out the matchinfo. */
+static void
+#ifdef _XTABLES_H
+print(const void *ip,
+      const struct xt_entry_match *match,
+#else
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+#endif
+      int numeric)
+{
+	struct ipt_ipv4options_info *info = ((struct ipt_ipv4options_info *)match->data);
+
+	printf(" IPV4OPTS");
+	if (info->options & IPT_IPV4OPTION_MATCH_SSRR)
+		printf(" SSRR");
+	else if (info->options & IPT_IPV4OPTION_MATCH_LSRR)
+		printf(" LSRR");
+	else if (info->options & IPT_IPV4OPTION_DONT_MATCH_SRR)
+		printf(" !SRR");
+	if (info->options & IPT_IPV4OPTION_MATCH_RR)
+		printf(" RR");
+	else if (info->options & IPT_IPV4OPTION_DONT_MATCH_RR)
+		printf(" !RR");
+	if (info->options & IPT_IPV4OPTION_MATCH_TIMESTAMP)
+		printf(" TS");
+	else if (info->options & IPT_IPV4OPTION_DONT_MATCH_TIMESTAMP)
+		printf(" !TS");
+	if (info->options & IPT_IPV4OPTION_MATCH_ROUTER_ALERT)
+		printf(" RA");
+	else if (info->options & IPT_IPV4OPTION_DONT_MATCH_ROUTER_ALERT)
+		printf(" !RA");
+	if (info->options & IPT_IPV4OPTION_MATCH_ANY_OPT)
+		printf(" ANYOPT ");
+	else if (info->options & IPT_IPV4OPTION_DONT_MATCH_ANY_OPT)
+		printf(" NOOPT");
+
+	printf(" ");
+}
+
+/* Saves the data in parsable form to stdout. */
+static void
+#ifdef _XTABLES_H
+save(const void *ip,
+     const struct xt_entry_match *match)
+#else
+save(const struct ipt_ip *ip,
+     const struct ipt_entry_match *match)
+#endif
+{
+	struct ipt_ipv4options_info *info = ((struct ipt_ipv4options_info *)match->data);
+
+	if (info->options & IPT_IPV4OPTION_MATCH_SSRR)
+		printf(" --ssrr");
+	else if (info->options & IPT_IPV4OPTION_MATCH_LSRR)
+		printf(" --lsrr");
+	else if (info->options & IPT_IPV4OPTION_DONT_MATCH_SRR)
+		printf(" --no-srr");
+	if (info->options & IPT_IPV4OPTION_MATCH_RR)
+		printf(" --rr");
+	else if (info->options & IPT_IPV4OPTION_DONT_MATCH_RR)
+		printf(" ! --rr");
+	if (info->options & IPT_IPV4OPTION_MATCH_TIMESTAMP)
+		printf(" --ts");
+	else if (info->options & IPT_IPV4OPTION_DONT_MATCH_TIMESTAMP)
+		printf(" ! --ts");
+	if (info->options & IPT_IPV4OPTION_MATCH_ROUTER_ALERT)
+		printf(" --ra");
+	else if (info->options & IPT_IPV4OPTION_DONT_MATCH_ROUTER_ALERT)
+		printf(" ! --ra");
+	if (info->options & IPT_IPV4OPTION_MATCH_ANY_OPT)
+		printf(" --any-opt");
+	if (info->options & IPT_IPV4OPTION_DONT_MATCH_ANY_OPT)
+		printf(" ! --any-opt");
+
+	printf(" ");
+}
+
+static struct xtables_match ipv4options_struct = { 
+	.next		= NULL,
+	.name		= "ipv4options",
+	.version	= XTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_ipv4options_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_ipv4options_info)),
+	.help		= &help,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	xtables_register_match(&ipv4options_struct);
+}
--- iptables/extensions/libipt_ipv4options.man
+++ iptables/extensions/libipt_ipv4options.man
@@ -0,0 +1,32 @@
+Match on IPv4 header options like source routing, record route,
+timestamp and router-alert.
+.TP
+.B "--ssrr"
+To match packets with the flag strict source routing.
+.TP
+.B "--lsrr"
+To match packets with the flag loose source routing.
+.TP
+.B "--no-srr"
+To match packets with no flag for source routing.
+.TP
+.B "\fR[\fB!\fR]\fB --rr"
+To match packets with the RR flag.
+.TP
+.B "\fR[\fB!\fR]\fB --ts"
+To match packets with the TS flag.
+.TP
+.B "\fR[\fB!\fR]\fB --ra"
+To match packets with the router-alert option.
+.TP
+.B "\fR[\fB!\fR]\fB --any-opt"
+To match a packet with at least one IP option, or no IP option
+at all if ! is chosen.
+.TP
+Examples:
+.TP
+$ iptables -A input -m ipv4options --rr -j DROP
+will drop packets with the record-route flag.
+.TP
+$ iptables -A input -m ipv4options --ts -j DROP
+will drop packets with the timestamp flag.
--- iptables/extensions/libipt_IPV4OPTSSTRIP.c
+++ iptables/extensions/libipt_IPV4OPTSSTRIP.c
@@ -0,0 +1,74 @@
+/* Shared library add-on to iptables for IPV4OPTSSTRIP
+ * This modules strip all the IP options.
+ *
+ * (C) 2001 by Fabrice MARIE <fabrice@netfilter.org>
+ * This program is distributed under the terms of GNU GPL v2, 1991
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+
+static void help(void) 
+{
+	printf("IPV4OPTSSTRIP v%s target takes no option !! Make sure you use it in the mangle table.\n",
+	       IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ 0 }
+};
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      struct ipt_entry_target **target)
+{
+	return 0;
+}
+
+static void
+final_check(unsigned int flags)
+{
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_target *target,
+      int numeric)
+{
+	/* nothing to print, we don't take option... */
+}
+
+/* Saves the stuff in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_target *target)
+{
+	/* nothing to print, we don't take option... */
+}
+
+static struct iptables_target IPV4OPTSSTRIP = { 
+	.next		= NULL,
+	.name		= "IPV4OPTSSTRIP",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(0),
+	.userspacesize	= IPT_ALIGN(0),
+	.help		= &help,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_target(&IPV4OPTSSTRIP);
+}
--- iptables/extensions/libipt_IPV4OPTSSTRIP.man
+++ iptables/extensions/libipt_IPV4OPTSSTRIP.man
@@ -0,0 +1,5 @@
+Strip all the IP options from a packet.
+
+The target doesn't take any option, and therefore is extremly easy to use :
+
+# iptables -t mangle -A PREROUTING -j IPV4OPTSSTRIP
--- iptables/extensions/libipt_layer7.c
+++ iptables/extensions/libipt_layer7.c
@@ -0,0 +1,404 @@
+/* 
+   Shared library add-on to iptables to add layer 7 matching support. 
+  
+   By Matthew Strait <quadong@users.sf.net>, Oct 2003.
+
+   http://l7-filter.sf.net 
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version
+   2 of the License, or (at your option) any later version.
+   http://www.gnu.org/licenses/gpl.txt
+
+   Based on libipt_string.c (C) 2000 Emmanuel Roger <winfield@freegates.be>
+*/
+
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+#include <dirent.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_layer7.h>
+
+#define MAX_FN_LEN 256
+
+static char l7dir[MAX_FN_LEN] = "\0";
+
+/* Function which prints out usage message. */
+static void help(void)
+{
+	printf(
+	"LAYER7 match v%s options:\n"
+	"--l7dir <directory>  : Look for patterns here instead of /etc/l7-protocols/\n"
+	"                       (--l7dir must be specified before --l7proto if used!)\n"
+	"--l7proto [!] <name> : Match the protocol defined in /etc/l7-protocols/name.pat\n"
+	"--l7pkt              : Skip connection tracking and match individual packets\n",
+
+	IPTABLES_VERSION);
+	fputc('\n', stdout);
+}
+
+static struct option opts[] = {
+	{ .name = "l7proto", .has_arg = 1, .flag = 0, .val = '1' },
+	{ .name = "l7dir",   .has_arg = 1, .flag = 0, .val = '2' },
+	{ .name = "l7pkt",   .has_arg = 0, .flag = 0, .val = '3' },
+	{ .name = 0 }
+};
+
+/* reads filename, puts protocol info into layer7_protocol_info, number of protocols to numprotos */
+int parse_protocol_file(char * filename, const unsigned char * protoname, struct ipt_layer7_info *info)
+{
+	FILE * f;
+	char * line = NULL;
+	size_t len = 0;
+
+	enum { protocol, pattern, done } datatype = protocol;
+
+	f = fopen(filename, "r");
+
+	if(!f)
+		return 0;
+
+	while(getline(&line, &len, f) != -1)
+	{
+		if(strlen(line) < 2 || line[0] == '#')
+			continue;
+
+		/* strip the pesky newline... */
+		if(line[strlen(line) - 1] == '\n')
+			line[strlen(line) - 1] = '\0';
+
+		if(datatype == protocol)
+		{
+			/* Ignore everything on the line beginning with the 
+			first space or tab . For instance, this allows the 
+			protocol line in http.pat to be "http " (or 
+			"http I am so cool") instead of just "http". */
+			if(strchr(line, ' ')){
+				char * space = strchr(line, ' ');
+				space[0] = '\0';
+			}
+			if(strchr(line, '\t')){
+				char * space = strchr(line, '\t');
+				space[0] = '\0';
+			}
+
+			/* sanity check.  First non-comment non-blank 
+			line must be the same as the file name. */
+			if(strcmp(line, protoname))
+				exit_error(OTHER_PROBLEM, 
+					"Protocol name (%s) doesn't match file name (%s).  Bailing out\n",
+					line, filename);
+
+			if(strlen(line) >= MAX_PROTOCOL_LEN)
+				 exit_error(PARAMETER_PROBLEM, 
+					"Protocol name in %s too long!", filename);
+			strncpy(info->protocol, line, MAX_PROTOCOL_LEN);
+
+			datatype = pattern; 
+		}
+		else if(datatype == pattern)
+		{
+			if(strlen(line) >= MAX_PATTERN_LEN)
+				 exit_error(PARAMETER_PROBLEM, "Pattern in %s too long!", filename);
+			strncpy(info->pattern, line, MAX_PATTERN_LEN);
+			
+			datatype = done;			
+			break;
+		}
+		else
+			exit_error(OTHER_PROBLEM, "Internal error");
+	}
+
+	if(datatype != done)
+		exit_error(OTHER_PROBLEM, "Failed to get all needed data from %s", filename);
+
+	if(line) free(line);
+	fclose(f);
+
+	return 1;
+
+/*
+	fprintf(stderr, "protocol: %s\npattern: %s\n\n", 
+			info->protocol,
+			info->pattern);
+*/
+}
+
+static int hex2dec(char c)
+{
+        switch (c)
+        {
+                case '0' ... '9':
+                        return c - '0';
+                case 'a' ... 'f':
+                        return c - 'a' + 10;
+                case 'A' ... 'F':
+                        return c - 'A' + 10;
+                default:
+                        exit_error(OTHER_PROBLEM, "hex2dec: bad value!\n");
+                        return 0;
+        }
+}
+
+/* takes a string with \xHH escapes and returns one with the characters 
+they stand for */
+static char * pre_process(char * s)
+{
+	char * result = malloc(strlen(s) + 1);
+	int sindex = 0, rindex = 0;
+        while( sindex < strlen(s) )
+        {
+            if( sindex + 3 < strlen(s) &&
+                s[sindex] == '\\' && s[sindex+1] == 'x' && 
+                isxdigit(s[sindex + 2]) && isxdigit(s[sindex + 3]) ) 
+                {
+                        /* carefully remember to call tolower here... */
+                        result[rindex] = tolower( hex2dec(s[sindex + 2])*16 +
+                                                  hex2dec(s[sindex + 3] ) );
+
+			switch ( result[rindex] )
+			{
+			case 0x24:
+			case 0x28:
+			case 0x29:
+			case 0x2a:
+			case 0x2b:
+			case 0x2e:
+			case 0x3f:
+			case 0x5b:
+			case 0x5c:
+			case 0x5d:
+			case 0x5e:
+			case 0x7c:
+				fprintf(stderr, 
+					"Warning: layer7 regexp contains a control character, %c, in hex (\\x%c%c).\n"
+					"I recommend that you write this as %c or \\%c, depending on what you meant.\n",
+					result[rindex], s[sindex + 2], s[sindex + 3], result[rindex], result[rindex]);
+				break;
+			case 0x00:
+				fprintf(stderr, 
+					"Warning: null (\\x00) in layer7 regexp.  A null terminates the regexp string!\n");
+				break;
+			default:
+				break;
+			}
+
+
+                        sindex += 3; /* 4 total */
+                }
+                else
+                        result[rindex] = tolower(s[sindex]);
+
+		sindex++; 
+		rindex++;
+        }
+	result[rindex] = '\0';
+
+	return result;
+}
+
+#define MAX_SUBDIRS 128
+char ** readl7dir(char * dirname)
+{
+        DIR             * scratchdir;
+        struct dirent   ** namelist;
+	char ** subdirs = malloc(MAX_SUBDIRS * sizeof(char *));
+
+        int n, d = 1;
+	subdirs[0] = "";
+
+        n = scandir(dirname, &namelist, 0, alphasort);
+
+	if (n < 0)
+	{
+            perror("scandir");
+	    exit_error(OTHER_PROBLEM, "Couldn't open %s\n", dirname);
+	}
+        else 
+	{
+            	while(n--) 
+		{
+			char fulldirname[MAX_FN_LEN];
+
+			snprintf(fulldirname, MAX_FN_LEN, "%s/%s", dirname, namelist[n]->d_name);
+
+                	if((scratchdir = opendir(fulldirname)) != NULL)
+			{
+				closedir(scratchdir);
+
+				if(!strcmp(namelist[n]->d_name, ".") || 
+				   !strcmp(namelist[n]->d_name, ".."))
+					/* do nothing */ ;
+				else
+				{
+					subdirs[d] = malloc(strlen(namelist[n]->d_name) + 1);
+					strcpy(subdirs[d], namelist[n]->d_name);
+					d++;
+					if(d >= MAX_SUBDIRS - 1)
+					{
+						fprintf(stderr, 
+						  "Too many subdirectories, skipping the rest!\n");
+						break;
+					}
+				}
+			}
+                	free(namelist[n]);
+            	}
+            	free(namelist);
+        }
+	
+	subdirs[d] = NULL;
+
+	return subdirs;
+}
+
+static void
+parse_layer7_protocol(const unsigned char *s, struct ipt_layer7_info *info)
+{
+	char filename[MAX_FN_LEN];
+	char * dir = NULL;
+	char ** subdirs;
+	int n = 0, done = 0;
+
+	if(strlen(l7dir) > 0)
+		dir = l7dir;
+	else
+		dir = "/etc/l7-protocols";
+
+	subdirs = readl7dir(dir);
+
+	while(subdirs[n] != NULL)
+	{
+		int c = snprintf(filename, MAX_FN_LEN, "%s/%s/%s.pat", dir, subdirs[n], s);
+
+		//fprintf(stderr, "Trying to find pattern in %s ... ", filename);
+
+		if(c > MAX_FN_LEN)
+		{
+			exit_error(OTHER_PROBLEM, 
+				"Filename beginning with %s is too long!\n", filename);
+		}
+
+		/* read in the pattern from the file */
+		if(parse_protocol_file(filename, s, info))
+		{
+			//fprintf(stderr, "found\n");
+			done = 1;
+			break;
+		}
+		
+		//fprintf(stderr, "not found\n");
+
+		n++;
+	}
+
+	if(!done)
+		exit_error(OTHER_PROBLEM, 
+			"Couldn't find a pattern definition file for %s.\n", s);
+
+	/* process \xHH escapes and tolower everything. (our regex lib has no
+	case insensitivity option.) */
+	strncpy(info->pattern, pre_process(info->pattern), MAX_PATTERN_LEN);
+}
+
+/* Function which parses command options; returns true if it ate an option */
+static int parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry, unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_layer7_info *layer7info = 
+		(struct ipt_layer7_info *)(*match)->data;
+
+	switch (c) {
+	case '1':
+		check_inverse(optarg, &invert, &optind, 0);
+		parse_layer7_protocol(argv[optind-1], layer7info);
+		if (invert)
+			layer7info->invert = 1;
+		*flags = 1;
+		break;
+
+	case '2':
+		/* not going to use this, but maybe we need to strip a ! anyway (?) */
+		check_inverse(optarg, &invert, &optind, 0);
+
+		if(strlen(argv[optind-1]) >= MAX_FN_LEN)
+			exit_error(PARAMETER_PROBLEM, "directory name too long\n");
+
+		strncpy(l7dir, argv[optind-1], MAX_FN_LEN);
+
+		*flags = 1;
+		break;
+
+	case '3':
+		layer7info->pkt = 1;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+/* Final check; must have specified --l7proto */
+static void final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM,
+			   "LAYER7 match: You must specify `--l7proto'");
+}
+
+static void print_protocol(char s[], int invert, int numeric)
+{
+	fputs("l7proto ", stdout);
+	if (invert) fputc('!', stdout);
+	printf("%s ", s);
+}
+
+/* Prints out the matchinfo. */
+static void print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	printf("LAYER7 ");
+
+	print_protocol(((struct ipt_layer7_info *)match->data)->protocol,
+		  ((struct ipt_layer7_info *)match->data)->invert, numeric);
+
+	if (((struct ipt_layer7_info *)match->data)->pkt)
+		printf("l7pkt ");
+}
+/* Saves the union ipt_matchinfo in parsable form to stdout. */
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+        const struct ipt_layer7_info *info =
+            (const struct ipt_layer7_info*) match->data;
+
+        printf("--l7proto %s%s ", (info->invert)   ? "! ": "", info->protocol);
+}
+
+static struct iptables_match layer7 = { 
+    .name          = "layer7",
+    .version       = IPTABLES_VERSION,
+    .size          = IPT_ALIGN(sizeof(struct ipt_layer7_info)),
+    .userspacesize = IPT_ALIGN(sizeof(struct ipt_layer7_info)),
+    .help          = &help,
+    .parse         = &parse,
+    .final_check   = &final_check,
+    .print         = &print,
+    .save          = &save,
+    .extra_opts    = opts
+};
+
+void _init(void)
+{
+	register_match(&layer7);
+}
--- iptables/extensions/libipt_layer7.man
+++ iptables/extensions/libipt_layer7.man
@@ -0,0 +1,14 @@
+This module matches packets based on the application layer data of 
+their connections.  It uses regular expression matching to compare 
+the application layer data to regular expressions found it the layer7 
+configuration files.  This is an experimental module which can be found at 
+http://l7-filter.sf.net.  It takes two options.
+.TP
+.BI "--l7proto " "\fIprotocol\fP"
+Match the specified protocol.  The protocol name must match a file 
+name in /etc/l7-protocols/ or one of its first-level child directories.
+.TP
+.BI "--l7dir " "\fIdirectory\fP"
+Use \fIdirectory\fP instead of /etc/l7-protocols/.  This option must be 
+specified before --l7proto.
+
--- iptables/extensions/libipt_macsave.c
+++ iptables/extensions/libipt_macsave.c
@@ -0,0 +1,111 @@
+/*
+
+	macsave match (experimental)
+	Copyright (C) 2006 Jonathan Zarate
+
+	Licensed under GNU GPL v2 or later.
+
+*/
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_macsave.h>
+
+
+static void help(void)
+{
+	printf(
+		"macsave match (experimental) v0.01\n"
+		"Copyright (C) 2006 Jonathan Zarate\n"
+		"Options:\n"
+		"[!] --mac <mac address>\n");
+}
+
+static void init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	*nfcache |= NFC_UNKNOWN;
+}
+
+static struct option opts[] = {
+	{ .name = "mac",  .has_arg = 1, .flag = 0, .val = '1' },
+	{ .name = 0 }
+};
+
+static int parse(int c, char **argv, int invert, unsigned int *flags,
+				 const struct ipt_entry *entry, unsigned int *nfcache,
+				 struct ipt_entry_match **match)
+{
+	struct ipt_macsave_match_info *info;
+	char *mac;
+	long n;
+	int i;
+
+	if (c != '1') return 0;
+
+	if (*flags) exit_error(PARAMETER_PROBLEM, "Multiple MACs are not supported");
+	*flags = 1;
+
+	info = (struct ipt_macsave_match_info *)(*match)->data;
+
+	check_inverse(optarg, &invert, &optind, 0);
+	if (invert) info->invert = 1;
+
+	mac = argv[optind - 1];
+	i = 0;
+	while (*mac) {
+		n = strtol(mac, &mac, 16);
+		if ((n < 0) || (n > 255)) break;
+		info->mac[i++] = n;
+		if (i == 6) break;
+		if ((*mac != ':') && (*mac != '-')) exit_error(PARAMETER_PROBLEM, "Invalid MAC address");
+		++mac;
+	}
+	if ((i != 6) || (*mac != 0)) exit_error(PARAMETER_PROBLEM, "Invalid MAC address");
+	return 1;
+}
+
+static void final_check(unsigned int flags)
+{
+	if (flags != 1) exit_error(PARAMETER_PROBLEM, "--mac expected");
+}
+
+static void print_match(const struct ipt_macsave_match_info *info)
+{
+	printf("--mac %02X:%02X:%02X:%02X:%02X:%02X ", 
+		info->mac[0], info->mac[1], info->mac[2],
+		info->mac[3], info->mac[4], info->mac[5]);
+}
+
+static void print(const struct ipt_ip *ip, const struct ipt_entry_match *match, int numeric)
+{
+	printf("macsave ");
+	print_match((const struct ipt_macsave_match_info *)match->data);
+}
+
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	print_match((const struct ipt_macsave_match_info *)match->data);
+}
+
+
+static struct iptables_match macsave_match = {
+	.name          = "macsave",
+	.version       = IPTABLES_VERSION,
+	.size          = IPT_ALIGN(sizeof(struct ipt_macsave_match_info)),
+	.userspacesize = IPT_ALIGN(sizeof(struct ipt_macsave_match_info)),
+	.help          = &help,
+	.init          = &init,
+	.parse         = &parse,
+	.final_check   = &final_check,
+	.print         = &print,
+	.save          = &save,
+	.extra_opts    = opts
+};
+
+void _init(void)
+{
+	register_match(&macsave_match);
+}
--- iptables/extensions/libipt_MACSAVE.c
+++ iptables/extensions/libipt_MACSAVE.c
@@ -0,0 +1,59 @@
+/*
+
+	MACSAVE target (experimental)
+	Copyright (C) 2006 Jonathan Zarate
+
+	Licensed under GNU GPL v2 or later.
+
+*/
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_MACSAVE.h>
+
+static void help(void)
+{
+	printf(
+		"MACSAVE target (experimental) v0.01\n"
+		"Copyright (C) 2006 Jonathan Zarate\n"
+		"Options: none\n");
+}
+
+static void init(struct ipt_entry_target *t, unsigned int *nfcache)
+{
+}
+
+static struct option opts[] = { { 0 } };
+
+static int parse(int c, char **argv, int invert, unsigned int *flags,
+				 const struct ipt_entry *entry, struct ipt_entry_target **target)
+{
+	return 0;
+}
+
+static void final_check(unsigned int flags)
+{
+}
+
+static struct iptables_target macsave_target
+= {	.next = NULL,
+	.name = "MACSAVE",
+	.version = IPTABLES_VERSION,
+	.size = IPT_ALIGN(sizeof(struct ipt_MACSAVE_target_info)),
+	.userspacesize = IPT_ALIGN(sizeof(struct ipt_MACSAVE_target_info)),
+	.help = &help,
+	.init = &init,
+	.parse = &parse,
+	.final_check = &final_check,
+	.print = NULL,
+	.save = NULL,
+	.extra_opts = opts
+};
+
+void _init(void)
+{
+	register_target(&macsave_target);
+}
--- iptables/extensions/libipt_mport.c
+++ iptables/extensions/libipt_mport.c
@@ -0,0 +1,287 @@
+/* Shared library add-on to iptables to add multiple TCP port support. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_mport.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"mport v%s options:\n"
+" --source-ports port[,port:port,port...]\n"
+" --sports ...\n"
+"				match source port(s)\n"
+" --destination-ports port[,port:port,port...]\n"
+" --dports ...\n"
+"				match destination port(s)\n"
+" --ports port[,port:port,port]\n"
+"				match both source and destination port(s)\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "source-ports", 1, 0, '1' },
+	{ "sports", 1, 0, '1' }, /* synonym */
+	{ "destination-ports", 1, 0, '2' },
+	{ "dports", 1, 0, '2' }, /* synonym */
+	{ "ports", 1, 0, '3' },
+	{0}
+};
+
+static void
+parse_multi_ports(const char *portstring, struct ipt_mport *minfo,
+                  const char *proto)
+{
+	char *buffer, *cp, *next, *range;
+	unsigned int i;
+        u_int16_t m;
+
+	buffer = strdup(portstring);
+	if (!buffer) exit_error(OTHER_PROBLEM, "strdup failed");
+
+        minfo->pflags = 0;
+
+	for (cp=buffer, i=0, m=1; cp && i<IPT_MULTI_PORTS; cp=next,i++,m<<=1)
+	{
+		next=strchr(cp, ',');
+		if (next) *next++='\0';
+                range = strchr(cp, ':');
+                if (range) {
+                        if (i == IPT_MULTI_PORTS-1)
+                                exit_error(PARAMETER_PROBLEM,
+                                           "too many ports specified");
+                        *range++ = '\0';
+                }
+		minfo->ports[i] = parse_port(cp, proto);
+                if (range) {
+                        minfo->pflags |= m;
+                        minfo->ports[++i] = parse_port(range, proto);
+                        if (minfo->ports[i-1] >= minfo->ports[i])
+                                exit_error(PARAMETER_PROBLEM,
+                                           "invalid portrange specified");
+                        m <<= 1;
+                }
+	}
+	if (cp) exit_error(PARAMETER_PROBLEM, "too many ports specified");
+        if (i == IPT_MULTI_PORTS-1)
+                minfo->ports[i] = minfo->ports[i-1];
+        else if (i < IPT_MULTI_PORTS-1) {
+                minfo->ports[i] = ~0;
+                minfo->pflags |= 1<<i;
+        }
+	free(buffer);
+}
+
+/* Initialize the match. */
+static void
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+}
+
+static const char *
+check_proto(const struct ipt_entry *entry)
+{
+	if (entry->ip.proto == IPPROTO_TCP)
+		return "tcp";
+	else if (entry->ip.proto == IPPROTO_UDP)
+		return "udp";
+	else if (!entry->ip.proto)
+		exit_error(PARAMETER_PROBLEM,
+			   "multiport needs `-p tcp' or `-p udp'");
+	else
+		exit_error(PARAMETER_PROBLEM,
+			   "multiport only works with TCP or UDP");
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	const char *proto;
+	struct ipt_mport *minfo
+		= (struct ipt_mport *)(*match)->data;
+
+	switch (c) {
+	case '1':
+		check_inverse(argv[optind-1], &invert, &optind, 0);
+		proto = check_proto(entry);
+		parse_multi_ports(argv[optind-1], minfo, proto);
+		minfo->flags = IPT_MPORT_SOURCE;
+		break;
+
+	case '2':
+		check_inverse(argv[optind-1], &invert, &optind, 0);
+		proto = check_proto(entry);
+		parse_multi_ports(argv[optind-1], minfo, proto);
+		minfo->flags = IPT_MPORT_DESTINATION;
+		break;
+
+	case '3':
+		check_inverse(argv[optind-1], &invert, &optind, 0);
+		proto = check_proto(entry);
+		parse_multi_ports(argv[optind-1], minfo, proto);
+		minfo->flags = IPT_MPORT_EITHER;
+		break;
+
+	default:
+		return 0;
+	}
+
+	if (invert)
+		exit_error(PARAMETER_PROBLEM,
+			   "multiport does not support invert");
+
+	if (*flags)
+		exit_error(PARAMETER_PROBLEM,
+			   "multiport can only have one option");
+	*flags = 1;
+	return 1;
+}
+
+/* Final check; must specify something. */
+static void
+final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM, "mport expects an option");
+}
+
+static char *
+port_to_service(int port, u_int8_t proto)
+{
+	struct servent *service;
+
+	if ((service = getservbyport(htons(port),
+				     proto == IPPROTO_TCP ? "tcp" : "udp")))
+		return service->s_name;
+
+	return NULL;
+}
+
+static void
+print_port(u_int16_t port, u_int8_t protocol, int numeric)
+{
+	char *service;
+
+	if (numeric || (service = port_to_service(port, protocol)) == NULL)
+		printf("%u", port);
+	else
+		printf("%s", service);
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	const struct ipt_mport *minfo
+		= (const struct ipt_mport *)match->data;
+	unsigned int i;
+        u_int16_t pflags = minfo->pflags;
+
+	printf("mport ");
+
+	switch (minfo->flags) {
+	case IPT_MPORT_SOURCE:
+		printf("sports ");
+		break;
+
+	case IPT_MPORT_DESTINATION:
+		printf("dports ");
+		break;
+
+	case IPT_MPORT_EITHER:
+		printf("ports ");
+		break;
+
+	default:
+		printf("ERROR ");
+		break;
+	}
+
+	for (i=0; i < IPT_MULTI_PORTS; i++) {
+                if (pflags & (1<<i)
+                    && minfo->ports[i] == 65535)
+                        break;
+                if (i == IPT_MULTI_PORTS-1
+                    && minfo->ports[i-1] == minfo->ports[i])
+                        break;
+		printf("%s", i ? "," : "");
+		print_port(minfo->ports[i], ip->proto, numeric);
+                if (pflags & (1<<i)) {
+                        printf(":");
+                        print_port(minfo->ports[++i], ip->proto, numeric);
+                }
+	}
+	printf(" ");
+}
+
+/* Saves the union ipt_matchinfo in parsable form to stdout. */
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	const struct ipt_mport *minfo
+		= (const struct ipt_mport *)match->data;
+	unsigned int i;
+        u_int16_t pflags = minfo->pflags;
+
+	switch (minfo->flags) {
+	case IPT_MPORT_SOURCE:
+		printf("--sports ");
+		break;
+
+	case IPT_MPORT_DESTINATION:
+		printf("--dports ");
+		break;
+
+	case IPT_MPORT_EITHER:
+		printf("--ports ");
+		break;
+	}
+
+	for (i=0; i < IPT_MULTI_PORTS; i++) {
+                if (pflags & (1<<i)
+                    && minfo->ports[i] == 65535)
+                        break;
+                if (i == IPT_MULTI_PORTS-1
+                    && minfo->ports[i-1] == minfo->ports[i])
+                        break;
+		printf("%s", i ? "," : "");
+		print_port(minfo->ports[i], ip->proto, 1);
+                if (pflags & (1<<i)) {
+                        printf(":");
+                        print_port(minfo->ports[++i], ip->proto, 1);
+                }
+	}
+	printf(" ");
+}
+
+static struct iptables_match mport = { 
+	.next		= NULL,
+	.name		= "mport",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_mport)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_mport)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void
+_init(void)
+{
+	register_match(&mport);
+}
--- iptables/extensions/libipt_mport.man
+++ iptables/extensions/libipt_mport.man
@@ -0,0 +1,19 @@
+This module matches a set of source or destination ports.  Up to 15
+ports can be specified.  It can only be used in conjunction with
+.B "-p tcp"
+or
+.BR "-p udp" .
+.TP
+.BR "--source-ports " "\fIport\fP[,\fIport\fP[,\fIport\fP...]]"
+Match if the source port is one of the given ports.  The flag
+.B --sports
+is a convenient alias for this option.
+.TP
+.BR "--destination-ports " "\fIport\fP[,\fIport\fP[,\fIport\fP...]]"
+Match if the destination port is one of the given ports.  The flag
+.B --dports
+is a convenient alias for this option.
+.TP
+.BR "--ports " "\fIport\fP[,\fIport\fP[,\fIport\fP...]]"
+Match if the both the source and destination ports are equal to each
+other and to one of the given ports.
--- iptables/extensions/libipt_NETLINK.c
+++ iptables/extensions/libipt_NETLINK.c
@@ -0,0 +1,157 @@
+/* Provides a NETLINK target, identical to that of the ipchains -o flag */
+/* AUTHOR: Gianni Tedesco <gianni@ecsc.co.uk> */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <syslog.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_NETLINK.h>
+
+static void help(void)
+{
+	printf("NETLINK v%s options:\n"
+		" --nldrop		Drop the packet too\n"
+		" --nlmark <number>	Mark the packet\n"
+		" --nlsize <bytes>	Limit packet size\n",
+	       IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{"nldrop", 0, 0, 'd'},
+	{"nlmark", 1, 0, 'm'},
+	{"nlsize", 1, 0, 's'},
+	{0}
+};
+
+static void init(struct ipt_entry_target *t, unsigned int *nfcache)
+{
+	struct ipt_nldata *nld = (struct ipt_nldata *) t->data;
+	
+	nld->flags=0;
+	
+}
+
+/* Parse command options */
+static int parse(int c, char **argv, int invert, unsigned int *flags,
+		 const struct ipt_entry *entry,
+		 struct ipt_entry_target **target)
+{
+	struct ipt_nldata *nld=(struct ipt_nldata *)(*target)->data;
+
+	switch (c) {
+		case 'd':
+			if (MASK(*flags, USE_DROP))
+				exit_error(PARAMETER_PROBLEM,
+				"Can't specify --nldrop twice");
+
+			if ( check_inverse(optarg, &invert, NULL, 0) ) {
+				MASK_UNSET(nld->flags, USE_DROP);
+			} else {
+				MASK_SET(nld->flags, USE_DROP);
+			}
+
+			MASK_SET(*flags, USE_DROP);			
+
+			break;
+		case 'm':
+			if (MASK(*flags, USE_MARK))
+				exit_error(PARAMETER_PROBLEM,
+				"Can't specify --nlmark twice");
+
+			if (check_inverse(optarg, &invert, NULL, 0)) {
+				MASK_UNSET(nld->flags, USE_MARK);
+			}else{
+				MASK_SET(nld->flags, USE_MARK);
+				nld->mark=atoi(optarg);
+			}
+
+			MASK_SET(*flags, USE_MARK);
+			break;
+		case 's':
+			if (MASK(*flags, USE_SIZE))
+				exit_error(PARAMETER_PROBLEM,
+				"Can't specify --nlsize twice");
+
+			if ( atoi(optarg) <= 0 )
+				exit_error(PARAMETER_PROBLEM,
+				"--nlsize must be larger than zero");
+			
+
+			if (check_inverse(optarg, &invert, NULL, 0)) {
+				MASK_UNSET(nld->flags, USE_SIZE);
+			}else{
+				MASK_SET(nld->flags, USE_SIZE);
+				nld->size=atoi(optarg);
+			}
+			MASK_SET(*flags, USE_SIZE);
+			break;
+
+		default:
+			return 0;
+	}
+	return 1;
+}
+
+static void final_check(unsigned int flags)
+{
+	/* ?? */
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void save(const struct ipt_ip *ip,
+		 const struct ipt_entry_target *target)
+{
+	const struct ipt_nldata *nld
+	    = (const struct ipt_nldata *) target->data;
+
+	if ( MASK(nld->flags, USE_DROP) )
+		printf("--nldrop ");
+
+	if ( MASK(nld->flags, USE_MARK) )
+		printf("--nlmark %i ", nld->mark);
+
+	if ( MASK(nld->flags, USE_SIZE) )
+		printf("--nlsize %i ", nld->size);		
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_target *target, int numeric)
+{
+	const struct ipt_nldata *nld
+	    = (const struct ipt_nldata *) target->data;
+
+	if ( MASK(nld->flags, USE_DROP) )
+		printf("nldrop ");
+
+	if ( MASK(nld->flags, USE_MARK) )
+		printf("nlmark %i ", nld->mark);
+
+	if ( MASK(nld->flags, USE_SIZE) )
+		printf("nlsize %i ", nld->size);
+}
+
+static struct iptables_target netlink = {
+	.next		= NULL,
+	.name		= "NETLINK",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_nldata)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_nldata)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_target(&netlink);
+}
+
--- iptables/extensions/libipt_nth.c
+++ iptables/extensions/libipt_nth.c
@@ -0,0 +1,230 @@
+/* 
+   Shared library add-on to iptables to add match support for every Nth packet
+   
+   This file is distributed under the terms of the GNU General Public
+   License (GPL). Copies of the GPL can be obtained from:
+   ftp://prep.ai.mit.edu/pub/gnu/GPL
+
+   2001-07-17 Fabrice MARIE <fabrice@netfilter.org> : initial development.
+   2001-09-20 Richard Wagner (rwagner@cloudnet.com)
+        * added support for multiple counters
+        * added support for matching on individual packets
+          in the counter cycle
+*/
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <syslog.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_nth.h>
+
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"nth v%s options:\n"
+"   --every     Nth              Match every Nth packet\n"
+"  [--counter   num ]            Use counter 0-%u (default:0)\n"
+"  [--start     num ]            Initialize the counter at the number 'num'\n"
+"                                instead of 0. Must be between 0 and Nth-1\n"
+"  [--packet    num ]            Match on 'num' packet. Must be between 0\n"
+"                                and Nth-1.\n\n"
+"                                If --packet is used for a counter than\n"
+"                                there must be Nth number of --packet\n"
+"                                rules, covering all values between 0 and\n"
+"                                Nth-1 inclusively.\n",
+IPTABLES_VERSION, IPT_NTH_NUM_COUNTERS-1);
+}
+
+static struct option opts[] = {
+	{ "every", 1, 0, '1' },
+	{ "start", 1, 0, '2' },
+        { "counter", 1, 0, '3' },
+        { "packet", 1, 0, '4' },
+	{ 0 }
+};
+
+#define IPT_NTH_OPT_EVERY	0x01
+#define IPT_NTH_OPT_NOT_EVERY	0x02
+#define IPT_NTH_OPT_START	0x04
+#define IPT_NTH_OPT_COUNTER     0x08
+#define IPT_NTH_OPT_PACKET      0x10
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_nth_info *nthinfo = (struct ipt_nth_info *)(*match)->data;
+	unsigned int num;
+
+	switch (c) {
+	case '1':
+		/* check for common mistakes... */
+		if ((!invert) && (*flags & IPT_NTH_OPT_EVERY))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --every twice");
+		if (invert && (*flags & IPT_NTH_OPT_NOT_EVERY))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --every twice");
+		if ((!invert) && (*flags & IPT_NTH_OPT_NOT_EVERY))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --every with ! --every");
+		if (invert && (*flags & IPT_NTH_OPT_EVERY))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --every with --every");
+
+		/* Remember, this function will interpret a leading 0 to be 
+		   Octal, a leading 0x to be hexdecimal... */
+                if (string_to_number(optarg, 2, 100, &num) == -1 || num < 2)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --every `%s', must be between 2 and 100", optarg);
+
+		/* assign the values */
+		nthinfo->every = num-1;
+		nthinfo->startat = 0;
+                nthinfo->packet = 0xFF;
+                if(!(*flags & IPT_NTH_OPT_EVERY))
+                {
+                        nthinfo->counter = 0;
+                }
+		if (invert)
+		{
+			*flags |= IPT_NTH_OPT_NOT_EVERY;
+			nthinfo->not = 1;
+		}
+		else
+		{
+			*flags |= IPT_NTH_OPT_EVERY;
+			nthinfo->not = 0;
+		}
+		break;
+	case '2':
+		/* check for common mistakes... */
+		if (!((*flags & IPT_NTH_OPT_EVERY) ||
+		      (*flags & IPT_NTH_OPT_NOT_EVERY)))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --start before --every");
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify with ! --start");
+		if (*flags & IPT_NTH_OPT_START)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --start twice");
+		if (string_to_number(optarg, 0, nthinfo->every, &num) == -1)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --start `%s', must between 0 and %u", optarg, nthinfo->every);
+		*flags |= IPT_NTH_OPT_START;
+		nthinfo->startat = num;
+		break;
+        case '3':
+                /* check for common mistakes... */
+                if (invert)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify with ! --counter");
+                if (*flags & IPT_NTH_OPT_COUNTER)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --counter twice");
+                if (string_to_number(optarg, 0, IPT_NTH_NUM_COUNTERS-1, &num) == -1)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --counter `%s', must between 0 and %u", optarg, IPT_NTH_NUM_COUNTERS-1);
+                /* assign the values */
+                *flags |= IPT_NTH_OPT_COUNTER;
+                nthinfo->counter = num;
+                break;
+        case '4':
+                /* check for common mistakes... */
+                if (!((*flags & IPT_NTH_OPT_EVERY) ||
+                      (*flags & IPT_NTH_OPT_NOT_EVERY)))
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --packet before --every");
+                if ((*flags & IPT_NTH_OPT_NOT_EVERY))
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --packet with ! --every");
+                if (invert)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify with ! --packet");
+                if (*flags & IPT_NTH_OPT_PACKET)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --packet twice");
+                if (string_to_number(optarg, 0, nthinfo->every, &num) == -1)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --packet `%s', must between 0 and %u", optarg, nthinfo->every);
+                *flags |= IPT_NTH_OPT_PACKET;
+                nthinfo->packet = num;
+                break;
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+/* Final check; nothing. */
+static void final_check(unsigned int flags)
+{
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	const struct ipt_nth_info *nthinfo
+		= (const struct ipt_nth_info *)match->data;
+
+	if (nthinfo->not == 1)
+		printf(" !");
+	printf("every %uth ", (nthinfo->every +1));
+	if (nthinfo->counter != 0) 
+		printf("counter #%u ", (nthinfo->counter));
+        if (nthinfo->packet != 0xFF)
+                printf("packet #%u ", nthinfo->packet);
+	if (nthinfo->startat != 0)
+		printf("start at %u ", nthinfo->startat);
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	const struct ipt_nth_info *nthinfo
+		= (const struct ipt_nth_info *)match->data;
+
+	if (nthinfo->not == 1)
+		printf("! ");
+	printf("--every %u ", (nthinfo->every +1));
+	printf("--counter %u ", (nthinfo->counter));
+	if (nthinfo->startat != 0)
+		printf("--start %u ", nthinfo->startat );
+        if (nthinfo->packet != 0xFF)
+                printf("--packet %u ", nthinfo->packet );
+}
+
+static struct iptables_match nth = { 
+	.next		= NULL,
+	.name		= "nth",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_nth_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_nth_info)),
+	.help		= &help,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_match(&nth);
+}
--- iptables/extensions/libipt_nth.man
+++ iptables/extensions/libipt_nth.man
@@ -0,0 +1,14 @@
+This module matches every `n'th packet
+.TP
+.BI "--every " "value"
+Match every `value' packet
+.TP
+.BI "[" "--counter " "num" "]"
+Use internal counter number `num'.  Default is `0'.
+.TP
+.BI "[" "--start " "num" "]"
+Initialize the counter at the number `num' insetad of `0'.  Most between `0'
+and `value'-1.
+.TP
+.BI "[" "--packet " "num" "]"
+Match on `num' packet.  Most be between `0' and `value'-1.
--- iptables/extensions/libipt_osf.c
+++ iptables/extensions/libipt_osf.c
@@ -0,0 +1,165 @@
+/*
+ * libipt_osf.c
+ *
+ * Copyright (c) 2003 Evgeniy Polyakov <johnpol@2ka.mipt.ru>
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+/*
+ * iptables interface for OS fingerprint matching module.
+ */
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_osf.h>
+
+static void help(void)
+{
+	printf("OS fingerprint match options:\n"
+		"--genre [!] string	Match a OS genre by passive fingerprinting.\n"
+		"--smart		Use some smart extensions to determine OS (do not use TTL).\n"
+		"--log level		Log all(or only first) determined genres even if "
+					"they do not match desired one. "
+					"Level may be 0(all) or 1(only first entry).\n"
+		"--netlink		Log through netlink(NETLINK_NFLOG).\n",
+		"--connector		Log through kernel connector [in 2.6.12-mm+].\n"
+		);
+}
+
+
+static struct option opts[] = {
+	{ .name = "genre",	.has_arg = 1, .flag = 0, .val = '1' },
+	{ .name = "smart",	.has_arg = 0, .flag = 0, .val = '2' },
+	{ .name = "log",	.has_arg = 1, .flag = 0, .val = '3' },
+	{ .name = "netlink",	.has_arg = 0, .flag = 0, .val = '4' },
+	{ .name = "connector",	.has_arg = 0, .flag = 0, .val = '5' },
+	{ .name = 0 }
+};
+
+static void parse_string(const unsigned char *s, struct ipt_osf_info *info)
+{
+	if (strlen(s) < MAXGENRELEN) 
+		strcpy(info->genre, s);
+	else 
+		exit_error(PARAMETER_PROBLEM, "Genre string too long `%s' [%d], max=%d", 
+				s, strlen(s), MAXGENRELEN);
+}
+
+static int parse(int c, char **argv, int invert, unsigned int *flags,
+      			const struct ipt_entry *entry,
+      			unsigned int *nfcache,
+      			struct ipt_entry_match **match)
+{
+	struct ipt_osf_info *info = (struct ipt_osf_info *)(*match)->data;
+	
+	switch(c) 
+	{
+		case '1': /* --genre */
+			if (*flags & IPT_OSF_GENRE)
+				exit_error(PARAMETER_PROBLEM, "Can't specify multiple genre parameter");
+			check_inverse(optarg, &invert, &optind, 0);
+			parse_string(argv[optind-1], info);
+			if (invert)
+				info->invert = 1;
+			info->len=strlen((char *)info->genre);
+			*flags |= IPT_OSF_GENRE;
+			break;
+		case '2': /* --smart */
+			if (*flags & IPT_OSF_SMART)
+				exit_error(PARAMETER_PROBLEM, "Can't specify multiple smart parameter");
+			*flags |= IPT_OSF_SMART;
+			info->flags |= IPT_OSF_SMART;
+			break;
+		case '3': /* --log */
+			if (*flags & IPT_OSF_LOG)
+				exit_error(PARAMETER_PROBLEM, "Can't specify multiple log parameter");
+			*flags |= IPT_OSF_LOG;
+			info->loglevel = atoi(argv[optind-1]);
+			info->flags |= IPT_OSF_LOG;
+			break;
+		case '4': /* --netlink */
+			if (*flags & IPT_OSF_NETLINK)
+				exit_error(PARAMETER_PROBLEM, "Can't specify multiple netlink parameter");
+			*flags |= IPT_OSF_NETLINK;
+			info->flags |= IPT_OSF_NETLINK;
+			break;
+		case '5': /* --connector */
+			if (*flags & IPT_OSF_CONNECTOR)
+				exit_error(PARAMETER_PROBLEM, "Can't specify multiple connector parameter");
+			*flags |= IPT_OSF_CONNECTOR;
+			info->flags |= IPT_OSF_CONNECTOR;
+			break;
+		default:
+			return 0;
+	}
+
+	return 1;
+}
+
+static void final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM, "OS fingerprint match: You must specify `--genre'");
+}
+
+static void print(const struct ipt_ip *ip, const struct ipt_entry_match *match, int numeric)
+{
+	const struct ipt_osf_info *info = (const struct ipt_osf_info*) match->data;
+
+	printf("OS fingerprint match %s%s ", (info->invert) ? "!" : "", info->genre);
+}
+
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	const struct ipt_osf_info *info = (const struct ipt_osf_info*) match->data;
+
+	printf("--genre %s%s ", (info->invert) ? "! ": "", info->genre);
+       if (info->flags & IPT_OSF_SMART)
+               printf("--smart ");
+       if (info->flags & IPT_OSF_LOG)
+               printf("--log %d ", info->loglevel);
+       if (info->flags & IPT_OSF_NETLINK)
+               printf("--netlink ");
+       if (info->flags & IPT_OSF_CONNECTOR)
+               printf("--connector ");
+}
+
+
+static struct iptables_match osf_match = {
+    .name          = "osf",
+    .version       = IPTABLES_VERSION,
+    .size          = IPT_ALIGN(sizeof(struct ipt_osf_info)),
+    .userspacesize = IPT_ALIGN(sizeof(struct ipt_osf_info)),
+    .help          = &help,
+    .parse         = &parse,
+    .final_check   = &final_check,
+    .print         = &print,
+    .save          = &save,
+    .extra_opts    = opts
+};
+
+
+void _init(void)
+{
+	register_match(&osf_match);
+}
--- iptables/extensions/libipt_osf.man
+++ iptables/extensions/libipt_osf.man
@@ -0,0 +1,47 @@
+The idea of passive OS fingerprint matching exists for quite a long time,
+but was created as extension fo OpenBSD pf only some weeks ago.
+Original idea was lurked in some OpenBSD mailing list (thanks
+grange@open...) and than adopted for Linux netfilter in form of this code.
+
+Original fingerprint table was created by Michal Zalewski <lcamtuf@coredump.cx>.
+
+This module compares some data(WS, MSS, options and it's order, ttl,
+df and others) from first SYN packet (actually from packets with SYN
+bit set) with dynamically loaded OS fingerprints.
+.TP
+.B "--log 1/0" 
+If present, OSF will log determined genres even if they don't match
+desired one.	
+0 - log all determined entries, 
+1 - only first one.
+
+In syslog you find something like this:
+.IP
+ipt_osf: Windows [2000:SP3:Windows XP Pro SP1, 2000 SP3]: 11.22.33.55:4024 -> 11.22.33.44:139
+.IP
+ipt_osf: Unknown: 16384:106:1:48:020405B401010402 44.33.22.11:1239 -> 11.22.33.44:80
+.TP
+.B "--smart"
+if present, OSF will use some smartness to determine remote OS.
+OSF will use initial TTL only if source of connection is in our local network.
+.TP
+.B "--netlink"
+If present, OSF will log all events also through netlink NETLINK_NFLOG groupt 1.
+.TP
+.BI "--genre " "[!] string"
+Match a OS genre by passive fingerprinting
+.P
+Example:
+
+#iptables -I INPUT -j ACCEPT -p tcp -m osf --genre Linux --log 1 --smart
+
+NOTE: -p tcp is obviously required as it is a TCP match.
+
+Fingerprints can be loaded and read through /proc/sys/net/ipv4/osf file.
+One can flush all fingerprints with following command:
+.IP
+echo -en FLUSH > /proc/sys/net/ipv4/osf
+.P
+Only one fingerprint per open/write/close.
+
+Fingerprints can be downloaded from http://www.openbsd.org/cgi-bin/cvsweb/src/etc/pf.os
--- iptables/extensions/libipt_psd.c
+++ iptables/extensions/libipt_psd.c
@@ -0,0 +1,194 @@
+/* 
+  Shared library add-on to iptables to add PSD support 
+   
+  Copyright (C) 2000,2001 astaro AG
+
+  This file is distributed under the terms of the GNU General Public
+  License (GPL). Copies of the GPL can be obtained from:
+     ftp://prep.ai.mit.edu/pub/gnu/GPL
+
+  2000-05-04 Markus Hennig <hennig@astaro.de> : initial
+  2000-08-18 Dennis Koslowski <koslowski@astaro.de> : first release
+  2000-12-01 Dennis Koslowski <koslowski@astaro.de> : UDP scans detection added
+  2001-02-04 Jan Rekorajski <baggins@pld.org.pl> : converted from target to match
+  2003-03-02 Harald Welte <laforge@netfilter.org>: fix 'storage' bug
+*/
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <syslog.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_psd.h>
+
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"psd v%s options:\n"
+" --psd-weight-threshold threshhold  Portscan detection weight threshold\n\n"
+" --psd-delay-threshold  delay       Portscan detection delay threshold\n\n"
+" --psd-lo-ports-weight  lo          Privileged ports weight\n\n"
+" --psd-hi-ports-weight  hi          High ports weight\n\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "psd-weight-threshold", 1, 0, '1' },
+	{ "psd-delay-threshold", 1, 0, '2' },
+	{ "psd-lo-ports-weight", 1, 0, '3' },
+	{ "psd-hi-ports-weight", 1, 0, '4' },
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	struct ipt_psd_info *psdinfo = (struct ipt_psd_info *)m->data;
+
+	psdinfo->weight_threshold = SCAN_WEIGHT_THRESHOLD;  
+	psdinfo->delay_threshold = SCAN_DELAY_THRESHOLD;
+	psdinfo->lo_ports_weight = PORT_WEIGHT_PRIV;
+	psdinfo->hi_ports_weight = PORT_WEIGHT_HIGH;
+}
+
+
+typedef struct _code {
+	char	*c_name;
+	int	c_val;
+} CODE;
+
+
+
+#define IPT_PSD_OPT_CTRESH 0x01
+#define IPT_PSD_OPT_DTRESH 0x02
+#define IPT_PSD_OPT_LPWEIGHT 0x04
+#define IPT_PSD_OPT_HPWEIGHT 0x08
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_psd_info *psdinfo = (struct ipt_psd_info *)(*match)->data;
+	unsigned int num;
+	
+	switch (c) {
+	/* PSD-weight-threshold */
+	case '1':
+		if (*flags & IPT_PSD_OPT_CTRESH)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --psd-weight-threshold "
+				   "twice");
+                if (string_to_number(optarg, 0, 10000, &num) == -1)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --psd-weight-threshold `%s'", optarg);
+		psdinfo->weight_threshold = num;
+		*flags |= IPT_PSD_OPT_CTRESH;
+		break;
+
+	/* PSD-delay-threshold */
+	case '2':
+		if (*flags & IPT_PSD_OPT_DTRESH)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --psd-delay-threshold twice");
+                if (string_to_number(optarg, 0, 10000, &num) == -1)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --psd-delay-threshold `%s'", optarg);
+		psdinfo->delay_threshold = num;
+		*flags |= IPT_PSD_OPT_DTRESH;
+		break;
+
+	/* PSD-lo-ports-weight */
+	case '3':
+		if (*flags & IPT_PSD_OPT_LPWEIGHT)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --psd-lo-ports-weight twice");
+                if (string_to_number(optarg, 0, 10000, &num) == -1)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --psd-lo-ports-weight `%s'", optarg);
+		psdinfo->lo_ports_weight = num;
+		*flags |= IPT_PSD_OPT_LPWEIGHT;
+		break;
+
+	/* PSD-hi-ports-weight */
+	case '4':
+		if (*flags & IPT_PSD_OPT_HPWEIGHT)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --psd-hi-ports-weight twice");
+                if (string_to_number(optarg, 0, 10000, &num) == -1)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --psd-hi-ports-weight `%s'", optarg);
+		psdinfo->hi_ports_weight = num;
+		*flags |= IPT_PSD_OPT_HPWEIGHT;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+/* Final check; nothing. */
+static void final_check(unsigned int flags)
+{
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	const struct ipt_psd_info *psdinfo
+		= (const struct ipt_psd_info *)match->data;
+
+	printf("psd ");
+	printf("weight-threshold: %u ", psdinfo->weight_threshold);
+	printf("delay-threshold: %u ", psdinfo->delay_threshold);
+	printf("lo-ports-weight: %u ", psdinfo->lo_ports_weight);
+	printf("hi-ports-weight: %u ", psdinfo->hi_ports_weight);
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	const struct ipt_psd_info *psdinfo
+		= (const struct ipt_psd_info *)match->data;
+
+	printf("--psd-weight-threshold %u ", psdinfo->weight_threshold);
+	printf("--psd-delay-threshold %u ", psdinfo->delay_threshold);
+	printf("--psd-lo-ports-weight %u ", psdinfo->lo_ports_weight);
+	printf("--psd-hi-ports-weight %u ", psdinfo->hi_ports_weight);
+}
+
+static struct iptables_match psd = { 
+	.next		= NULL,
+	.name		= "psd",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_psd_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_psd_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_match(&psd);
+}
--- iptables/extensions/libipt_psd.man
+++ iptables/extensions/libipt_psd.man
@@ -0,0 +1,18 @@
+Attempt to detect TCP and UDP port scans. This match was derived from
+Solar Designer's scanlogd.
+.TP
+.BI "--psd-weight-threshold " "threshold"
+Total weight of the latest TCP/UDP packets with different
+destination ports coming from the same host to be treated as port
+scan sequence.
+.TP
+.BI "--psd-delay-threshold " "delay"
+Delay (in hundredths of second) for the packets with different
+destination ports coming from the same host to be treated as
+possible port scan subsequence.
+.TP
+.BI "--psd-lo-ports-weight " "weight"
+Weight of the packet with privileged (<=1024) destination port.
+.TP
+.BI "--psd-hi-ports-weight " "weight"
+Weight of the packet with non-priviliged destination port.
--- iptables/extensions/libipt_random.c
+++ iptables/extensions/libipt_random.c
@@ -0,0 +1,150 @@
+/* 
+   Shared library add-on to iptables to add match support for random match.
+   
+   This file is distributed under the terms of the GNU General Public
+   License (GPL). Copies of the GPL can be obtained from:
+   ftp://prep.ai.mit.edu/pub/gnu/GPL
+
+   2001-10-14 Fabrice MARIE <fabrice@netfilter.org> : initial development.
+*/
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <syslog.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_random.h>
+
+/**
+ * The kernel random routing returns numbers between 0 and 255.
+ * To ease the task of the user in choosing the probability
+ * of matching, we want him to be able to use percentages.
+ * Therefore we have to accept numbers in percentage here,
+ * turn them into number between 0 and 255 for the kernel module,
+ * and turn them back to percentages when we print/save
+ * the rule.
+ */
+
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"random v%s options:\n"
+"  [--average      percent ]    The probability in percentage of the match\n"
+"                               If ommited, a probability of 50%% percent is set.\n"
+"                               Percentage must be within : 1 <= percent <= 99.\n\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "average", 1, 0, '1' },
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	struct ipt_rand_info *randinfo = (struct ipt_rand_info *)(m)->data;
+
+	/* We assign the average to be 50 which is our default value */
+	/* 50 * 2.55 = 128 */
+	randinfo->average = 128;
+}
+
+#define IPT_RAND_OPT_AVERAGE	0x01
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_rand_info *randinfo = (struct ipt_rand_info *)(*match)->data;
+	unsigned int num;
+
+	switch (c) {
+	case '1':
+		/* check for common mistakes... */
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --average");
+		if (*flags & IPT_RAND_OPT_AVERAGE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --average twice");
+
+		/* Remember, this function will interpret a leading 0 to be 
+		   Octal, a leading 0x to be hexdecimal... */
+                if (string_to_number(optarg, 1, 99, &num) == -1 || num < 1)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad --average `%s', must be between 1 and 99", optarg);
+
+		/* assign the values */
+		randinfo->average = (int)(num * 2.55);
+		*flags |= IPT_RAND_OPT_AVERAGE;
+		break;
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+/* Final check; nothing. */
+static void final_check(unsigned int flags)
+{
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	const struct ipt_rand_info *randinfo
+		= (const struct ipt_rand_info *)match->data;
+	div_t result = div((randinfo->average*100), 255);
+	if (result.rem > 127)  /* round up... */
+		++result.quot;
+
+	printf(" random %u%% ", result.quot);
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	const struct ipt_rand_info *randinfo
+		= (const struct ipt_rand_info *)match->data;
+	div_t result = div((randinfo->average *100), 255);
+	if (result.rem > 127)  /* round up... */
+		++result.quot;
+
+	printf("--average %u ", result.quot);
+}
+
+struct iptables_match rand_match = { 
+	.next		= NULL,
+	.name		= "random",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_rand_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_rand_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_match(&rand_match);
+}
--- iptables/extensions/libipt_random.man
+++ iptables/extensions/libipt_random.man
@@ -0,0 +1,4 @@
+This module randomly matches a certain percentage of all packets.
+.TP
+.BI "--average " "percent"
+Matches the given percentage.  If omitted, a probability of 50% is set. 
--- iptables/extensions/libipt_record_rpc.c
+++ iptables/extensions/libipt_record_rpc.c
@@ -0,0 +1,65 @@
+/* Shared library add-on to iptables for rpc match */
+#include <stdio.h>
+#include <getopt.h>
+#include <iptables.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"record_rpc v%s takes no options\n"
+"\n", IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{0}
+};
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	return 0;
+}
+
+/* Final check; must have specified --mac. */
+static void final_check(unsigned int flags)
+{
+}
+
+/* Prints out the union ipt_matchinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+}
+
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+}
+
+static
+struct iptables_match record_rpc = { 
+	.next		= NULL,
+	.name 		= "record_rpc",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(0),
+	.userspacesize	= IPT_ALIGN(0),
+	.help		= &help,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_match(&record_rpc);
+}
--- iptables/extensions/libipt_ROUTE.c
+++ iptables/extensions/libipt_ROUTE.c
@@ -0,0 +1,291 @@
+/* Shared library add-on to iptables to add ROUTE target support.
+ * Author : Cedric de Launois, <delaunois@info.ucl.ac.be>
+ * v 1.11 2004/11/23
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <net/if.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_ROUTE.h>
+
+#ifndef XTABLES_VERSION
+#define XTABLES_VERSION IPTABLES_VERSION
+#endif
+
+#ifdef IPT_LIB_DIR
+#define xtables_target iptables_target
+#define xtables_register_target register_target
+#endif
+
+/* compile IPT_ROUTE_TEE support even if kernel headers are unpatched */
+#ifndef IPT_ROUTE_TEE
+#define IPT_ROUTE_TEE		0x02
+#endif
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"ROUTE target v%s options:\n"
+"    --oif   \tifname \t\tRoute packet through `ifname' network interface\n"
+"    --iif   \tifname \t\tChange packet's incoming interface to `ifname'\n"
+"    --gw    \tip     \t\tRoute packet via this gateway `ip'\n"
+"    --continue\t     \t\tRoute packet and continue traversing the\n"
+"            \t       \t\trules. Not valid with --iif or --tee.\n"
+"    --tee\t  \t\tDuplicate packet, route the duplicate,\n"
+"            \t       \t\tcontinue traversing with original packet.\n"
+"            \t       \t\tNot valid with --iif or --continue.\n"
+"\n",
+"1.11");
+}
+
+static struct option opts[] = {
+	{ "oif", 1, 0, '1' },
+	{ "iif", 1, 0, '2' },
+	{ "gw", 1, 0, '3' },
+	{ "continue", 0, 0, '4' },
+	{ "tee", 0, 0, '5' },
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+#ifdef _XTABLES_H
+init(struct xt_entry_target *t)
+#else
+init(struct ipt_entry_target *t, unsigned int *nfcache)
+#endif
+{
+	struct ipt_route_target_info *route_info = 
+		(struct ipt_route_target_info*)t->data;
+
+	route_info->oif[0] = '\0';
+	route_info->iif[0] = '\0';
+	route_info->gw = 0;
+	route_info->flags = 0;
+}
+
+
+#define IPT_ROUTE_OPT_OIF      0x01
+#define IPT_ROUTE_OPT_IIF      0x02
+#define IPT_ROUTE_OPT_GW       0x04
+#define IPT_ROUTE_OPT_CONTINUE 0x08
+#define IPT_ROUTE_OPT_TEE      0x10
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+#ifdef _XTABLES_H
+      const void *entry, struct xt_entry_target **target)
+#else
+      const struct ipt_entry *entry, struct ipt_entry_target **target)
+#endif
+{
+	struct ipt_route_target_info *route_info = 
+		(struct ipt_route_target_info*)(*target)->data;
+
+	switch (c) {
+	case '1':
+		if (*flags & IPT_ROUTE_OPT_OIF)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --oif twice");
+
+		if (*flags & IPT_ROUTE_OPT_IIF)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't use --oif and --iif together");
+
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --oif");
+
+		if (strlen(optarg) > sizeof(route_info->oif) - 1)
+			exit_error(PARAMETER_PROBLEM,
+				   "Maximum interface name length %u",
+				   sizeof(route_info->oif) - 1);
+
+		strcpy(route_info->oif, optarg);
+		*flags |= IPT_ROUTE_OPT_OIF;
+		break;
+
+	case '2':
+		if (*flags & IPT_ROUTE_OPT_IIF)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --iif twice");
+
+		if (*flags & IPT_ROUTE_OPT_OIF)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't use --iif and --oif together");
+
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --iif");
+
+		if (strlen(optarg) > sizeof(route_info->iif) - 1)
+			exit_error(PARAMETER_PROBLEM,
+				   "Maximum interface name length %u",
+				   sizeof(route_info->iif) - 1);
+
+		strcpy(route_info->iif, optarg);
+		*flags |= IPT_ROUTE_OPT_IIF;
+		break;
+
+	case '3':
+		if (*flags & IPT_ROUTE_OPT_GW)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --gw twice");
+
+		if (check_inverse(optarg, &invert, NULL, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --gw");
+
+		if (!inet_aton(optarg, (struct in_addr*)&route_info->gw)) {
+			exit_error(PARAMETER_PROBLEM,
+				   "Invalid IP address %s",
+				   optarg);
+		}
+
+		*flags |= IPT_ROUTE_OPT_GW;
+		break;
+
+	case '4':
+		if (*flags & IPT_ROUTE_OPT_CONTINUE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --continue twice");
+		if (*flags & IPT_ROUTE_OPT_TEE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --continue AND --tee");
+
+		route_info->flags |= IPT_ROUTE_CONTINUE;
+		*flags |= IPT_ROUTE_OPT_CONTINUE;
+
+		break;
+
+	case '5':
+		if (*flags & IPT_ROUTE_OPT_TEE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --tee twice");
+		if (*flags & IPT_ROUTE_OPT_CONTINUE)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --tee AND --continue");
+
+		route_info->flags |= IPT_ROUTE_TEE;
+		*flags |= IPT_ROUTE_OPT_TEE;
+
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+
+static void
+final_check(unsigned int flags)
+{
+	if (!flags)
+		exit_error(PARAMETER_PROBLEM,
+		           "ROUTE target: oif, iif or gw option required");
+
+	if ((flags & (IPT_ROUTE_OPT_CONTINUE|IPT_ROUTE_OPT_TEE)) && (flags & IPT_ROUTE_OPT_IIF))
+		exit_error(PARAMETER_PROBLEM,
+			   "ROUTE target: can't continue traversing the rules with iif option");
+}
+
+
+/* Prints out the targinfo. */
+static void
+#ifdef _XTABLES_H
+print(const void *ip,
+      const struct xt_entry_target *target,
+#else
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_target *target,
+#endif
+      int numeric)
+{
+	const struct ipt_route_target_info *route_info
+		= (const struct ipt_route_target_info *)target->data;
+
+	printf(" ROUTE");
+
+	if (route_info->oif[0])
+		printf(" oif:%s", route_info->oif);
+
+	if (route_info->iif[0])
+		printf(" iif:%s", route_info->iif);
+
+	if (route_info->gw) {
+		struct in_addr gw = { route_info->gw };
+		printf(" gw:%s", inet_ntoa(gw));
+	}
+
+	if (route_info->flags & IPT_ROUTE_CONTINUE)
+		printf(" continue");
+
+	if (route_info->flags & IPT_ROUTE_TEE)
+		printf(" tee");
+
+}
+
+static void
+#ifdef _XTABLES_H
+save(const void *ip,
+     const struct xt_entry_target *target)
+#else
+save(const struct ipt_ip *ip,
+     const struct ipt_entry_target *target)
+#endif
+{
+	const struct ipt_route_target_info *route_info
+		= (const struct ipt_route_target_info *)target->data;
+
+	if (route_info->oif[0])
+		printf("--oif %s ", route_info->oif);
+
+	if (route_info->iif[0])
+		printf("--iif %s ", route_info->iif);
+
+	if (route_info->gw) {
+		struct in_addr gw = { route_info->gw };
+		printf(" --gw %s ", inet_ntoa(gw));
+	}
+
+	if (route_info->flags & IPT_ROUTE_CONTINUE)
+		printf(" --continue");
+
+	if (route_info->flags & IPT_ROUTE_TEE)
+		printf(" --tee");
+}
+
+
+static struct xtables_target route = { 
+	.next		= NULL,
+	.name		= "ROUTE",
+	.version	= XTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_route_target_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_route_target_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	xtables_register_target(&route);
+}
--- iptables/extensions/libipt_ROUTE.man
+++ iptables/extensions/libipt_ROUTE.man
@@ -0,0 +1,18 @@
+This is used to explicitly override the core network stack's routing decision.
+.B mangle
+table.
+.TP
+.BI "--oif " "ifname"
+Route the packet through `ifname' network interface
+.TP
+.BI "--iif " "ifname"
+Change the packet's incoming interface to `ifname'
+.TP
+.BI "--gw " "IP_address"
+Route the packet via this gateway
+.TP
+.BI "--continue "
+Behave like a non-terminating target and continue traversing the rules.  Not valid in combination with `--iif' or `--tee'
+.TP
+.BI "--tee "
+Make a copy of the packet, and route that copy to the given destination. For the original, uncopied packet, behave like a non-terminating target and continue traversing the rules.  Not valid in combination with `--iif' or `--continue'
--- iptables/extensions/libipt_rpc.c
+++ iptables/extensions/libipt_rpc.c
@@ -0,0 +1,373 @@
+/* RPC extension for IP connection matching, Version 2.2
+ * (C) 2000 by Marcelo Barbosa Lima <marcelo.lima@dcc.unicamp.br>
+ *	- original rpc tracking module
+ *	- "recent" connection handling for kernel 2.3+ netfilter
+ *
+ * (C) 2001 by Rusty Russell <rusty@rustcorp.com.au>
+ *	- upgraded conntrack modules to oldnat api - kernel 2.4.0+
+ *
+ * (C) 2002,2003 by Ian (Larry) Latter <Ian.Latter@mq.edu.au>
+ *	- upgraded conntrack modules to newnat api - kernel 2.4.20+
+ *	- extended matching to support filtering on procedures
+ *
+ * libipt_rpc.c,v 2.2 2003/01/12 18:30:00
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ **
+ *	Userspace library syntax:
+ *	--rpc [--rpcs procedure1,procedure2,...procedure128] [--static]
+ *
+ *	Procedures can be supplied in either numeric or named formats.
+ *	Without --rpcs, this module will behave as the old record-rpc.
+ **
+ *	Note to all:
+ *
+ *	RPCs should not be exposed to the internet - ask the Pentagon;
+ *
+ *	  "The unidentified crackers pleaded guilty in July to charges
+ *	   of juvenile delinquency stemming from a string of Pentagon
+ *	   network intrusions in February.
+ *
+ *	   The youths, going by the names TooShort and Makaveli, used
+ *	   a common server security hole to break in, according to
+ *	   Dane Jasper, owner of the California Internet service
+ *	   provider, Sonic. They used the hole, known as the 'statd'
+ *	   exploit, to attempt more than 800 break-ins, Jasper said."
+ *
+ *	From: Wired News; "Pentagon Kids Kicked Off Grid" - Nov 6, 1998
+ *	URL:  http://www.wired.com/news/politics/0,1283,16098,00.html
+ **
+ */
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <rpc/rpc.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_rpc.h>
+#include <time.h>
+
+
+const int IPT_RPC_RPCS = 1;
+const int IPT_RPC_STRC = 2;
+
+const int IPT_RPC_INT_LBL = 1;
+const int IPT_RPC_INT_NUM = 2;
+const int IPT_RPC_INT_BTH = 3;
+
+const int IPT_RPC_CHAR_LEN = 11;
+const int IPT_RPC_MAX_ENTS = 128;
+
+const char preerr[11] = "RPC match:";
+
+
+static int k_itoa(char *string, int number)
+{
+	int maxoctet = IPT_RPC_CHAR_LEN - 1;
+	int store[IPT_RPC_CHAR_LEN];
+	int counter;
+
+
+        for (counter=0 ; maxoctet != 0 && number != 0; counter++, maxoctet--) {
+		store[counter] = number / 10;
+		store[counter] = number - ( store[counter] * 10 );
+		number = number / 10;
+        }
+
+        for ( ; counter != 0; counter--, string++)
+		*string = store[counter - 1] + 48;
+
+	*string = 0;
+
+	return(0);
+}
+
+
+static int k_atoi(char *string)
+{
+	unsigned int result = 0;
+	int maxoctet = IPT_RPC_CHAR_LEN;
+
+
+        for ( ; *string != 0 && maxoctet != 0; maxoctet--, string++) {
+                if (*string < 0)
+                        return(0);
+                if (*string == 0)
+                        break;
+                if (*string < 48 || *string > 57) {
+                        return(0);
+                }
+                result = result * 10 + ( *string - 48 );
+        }
+
+	return(result);
+}
+
+
+static void print_rpcs(char *c_procs, int i_procs, int labels)
+{
+	int   proc_ctr;
+	char *proc_ptr;
+	unsigned int proc_num;
+	struct rpcent *rpcent;
+
+
+	for (proc_ctr=0; proc_ctr <= i_procs; proc_ctr++) {
+
+		if ( proc_ctr != 0 )
+			printf(",");
+
+		proc_ptr = c_procs;
+		proc_ptr += proc_ctr * IPT_RPC_CHAR_LEN;
+		proc_num = k_atoi(proc_ptr);
+
+		/* labels(1) == no labels, only numbers
+		 * labels(2) == no numbers, only labels
+		 * labels(3) == both labels and numbers
+		 */
+
+		if (labels == IPT_RPC_INT_LBL || labels == IPT_RPC_INT_BTH ) {
+			if ( (rpcent = getrpcbynumber(proc_num)) == NULL )
+				printf("unknown");
+			else
+				printf("%s", rpcent->r_name);
+		}
+
+		if (labels == IPT_RPC_INT_BTH )
+			printf("(");
+
+		if (labels == IPT_RPC_INT_NUM || labels == IPT_RPC_INT_BTH )
+			printf("%i", proc_num);
+
+		if (labels == IPT_RPC_INT_BTH )
+			printf(")");
+
+	}
+
+}
+
+
+static void help(void) 
+{
+	printf(
+		"RPC v%s options:\n"
+		"  --rpcs list,of,procedures"
+		"\ta list of rpc program numbers to apply\n"
+		"\t\t\t\tie. 100003,mountd,rquotad (numeric or\n"
+		"\t\t\t\tname form; see /etc/rpc).\n"
+		"  --strict"
+		"\t\t\ta flag to force the drop of packets\n"
+		"\t\t\t\tnot containing \"get\" portmapper requests.\n",
+		IPTABLES_VERSION);
+}
+
+
+static struct option opts[] = {
+	{ "rpcs", 1, 0, '1'},
+	{ "strict", 0, 0, '2'},
+	{0}
+};
+
+
+static void init(struct ipt_entry_match *match, unsigned int *nfcache)
+{
+	struct ipt_rpc_info *rpcinfo = ((struct ipt_rpc_info *)match->data);
+
+
+
+	/* initialise those funky user vars */
+	rpcinfo->i_procs = -1;
+	rpcinfo->strict  =  0;
+	memset((char *)rpcinfo->c_procs, 0, sizeof(rpcinfo->c_procs));
+}
+
+
+static void parse_rpcs_string(char *string, struct ipt_entry_match **match)
+{
+	char err1[64] = "%s invalid --rpcs option-set: `%s' (at character %i)";
+	char err2[64] = "%s unable to resolve rpc name entry: `%s'";
+	char err3[64] = "%s maximum number of --rpc options (%i) exceeded";
+	char buf[256];
+	char *dup = buf;
+	int idup = 0;
+	int term = 0;
+	char *src, *dst;
+	char *c_procs;
+	struct rpcent *rpcent_ptr;
+	struct ipt_rpc_info *rpcinfo = (struct ipt_rpc_info *)(*match)->data;
+
+
+	memset(buf, 0, sizeof(buf));
+
+	for (src=string, dst=buf; term != 1 ; src++, dst++) {
+
+		if ( *src != ',' && *src != '\0' ) {
+			if ( ( *src >= 65 && *src <= 90 ) || ( *src >= 97 && *src <= 122) ) {
+				*dst = *src;
+				idup = 1;
+
+			} else if ( *src >= 48 && *src <= 57 ) {
+				*dst = *src;
+
+			} else {
+				exit_error(PARAMETER_PROBLEM, err1, preerr,
+					   string, src - string + 1);
+
+			}
+
+		} else {
+			*dst = '\0';
+			if ( idup == 1 ) {
+				if ( (rpcent_ptr = getrpcbyname(dup)) == NULL )
+					exit_error(PARAMETER_PROBLEM, err2,
+						   preerr, dup);
+				idup = rpcent_ptr->r_number;
+			} else {
+				idup = k_atoi(dup);
+			}
+
+			rpcinfo->i_procs++;
+			if ( rpcinfo->i_procs > IPT_RPC_MAX_ENTS )
+				exit_error(PARAMETER_PROBLEM, err3, preerr,
+					   IPT_RPC_MAX_ENTS);
+				
+			c_procs  = (char *)rpcinfo->c_procs;
+			c_procs += rpcinfo->i_procs * IPT_RPC_CHAR_LEN;
+			
+			memset(buf, 0, sizeof(buf));
+			k_itoa((char *)dup, idup);
+
+			strcpy(c_procs, dup);
+	
+			if ( *src == '\0')
+				term = 1;
+
+			idup = 0;
+			memset(buf, 0, sizeof(buf));
+			dst = (char *)buf - 1;
+		}
+	}
+
+	return;
+}
+
+
+static int parse(int c, char **argv, int invert, unsigned int *flags,
+		const struct ipt_entry *entry,
+		unsigned int *nfcache,
+		struct ipt_entry_match **match)
+{
+	struct ipt_rpc_info *rpcinfo = (struct ipt_rpc_info *)(*match)->data;
+
+
+	switch (c)
+	{
+	case '1':
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+                                   "%s unexpected '!' with --rpcs\n", preerr);
+		if (*flags & IPT_RPC_RPCS)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "%s repeated use of --rpcs\n", preerr);
+		parse_rpcs_string(optarg, match);
+
+		*flags |= IPT_RPC_RPCS;
+		break;
+
+	case '2':
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+                                   "%s unexpected '!' with --strict\n", preerr);
+		if (*flags & IPT_RPC_STRC)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "%s repeated use of --strict\n", preerr);
+		rpcinfo->strict = 1;
+		*flags |= IPT_RPC_STRC;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+
+}
+
+
+static void final_check(unsigned int flags)
+{
+	if (flags != (flags | IPT_RPC_RPCS)) {
+		printf("%s option \"--rpcs\" was not used ... reverting ", preerr);
+		printf("to old \"record-rpc\" functionality ..\n");
+	}
+}
+
+
+static void print(const struct ipt_ip *ip,
+		const struct ipt_entry_match *match,
+		int numeric)
+{
+	struct ipt_rpc_info *rpcinfo = ((struct ipt_rpc_info *)match->data);
+
+
+	printf("RPCs");
+	if(rpcinfo->strict == 1)
+		printf("[strict]");
+
+	printf(": ");
+
+	if(rpcinfo->i_procs == -1) {
+		printf("any(*)");
+
+	} else {
+		print_rpcs((char *)&rpcinfo->c_procs, rpcinfo->i_procs, IPT_RPC_INT_BTH);
+	}
+	printf(" ");
+
+}
+
+
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	struct ipt_rpc_info *rpcinfo = ((struct ipt_rpc_info *)match->data);
+
+
+	if(rpcinfo->i_procs > -1) {
+		printf("--rpcs ");
+		print_rpcs((char *)&rpcinfo->c_procs, rpcinfo->i_procs, IPT_RPC_INT_NUM);
+		printf(" ");
+	}
+
+	if(rpcinfo->strict == 1)
+		printf("--strict ");
+
+}
+
+
+static struct iptables_match rpcstruct = { 
+	.next		= NULL,
+	.name		= "rpc",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_rpc_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_rpc_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+
+void _init(void)
+{
+	register_match(&rpcstruct);
+}
+
--- iptables/extensions/libipt_TARPIT.c
+++ iptables/extensions/libipt_TARPIT.c
@@ -0,0 +1,83 @@
+/* Shared library add-on to iptables for TARPIT support */
+#include <stdio.h>
+#include <getopt.h>
+#include <iptables.h>
+
+#ifndef XTABLES_VERSION
+#define XTABLES_VERSION IPTABLES_VERSION
+#endif
+
+#ifdef IPT_LIB_DIR
+#define xtables_target iptables_target
+#define xtables_register_target register_target
+#endif
+
+static void
+help(void)
+{
+	fputs(
+"TARPIT takes no options\n"
+"\n", stdout);
+}
+
+static struct option opts[] = {
+	{ 0 }
+};
+
+
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+#ifdef _XTABLES_H
+      const void *entry, struct xt_entry_target **target)
+#else
+      const struct ipt_entry *entry, struct ipt_entry_target **target)
+#endif
+{
+	return 0;
+}
+
+static void final_check(unsigned int flags)
+{
+}
+
+static void
+#ifdef _XTABLES_H
+print(const void *ip,
+      const struct xt_entry_target *target,
+#else
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_target *target,
+#endif
+      int numeric)
+{
+}
+
+static void
+#ifdef _XTABLES_H
+save(const void *ip,
+     const struct xt_entry_target *target)
+#else
+save(const struct ipt_ip *ip,
+     const struct ipt_entry_target *target)
+#endif
+{
+}
+
+static struct xtables_target tarpit = {
+	.next		= NULL,
+	.name		= "TARPIT",
+	.version	= XTABLES_VERSION,
+	.size		= IPT_ALIGN(0),
+	.userspacesize	= IPT_ALIGN(0),
+	.help		= &help,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	xtables_register_target(&tarpit);
+}
--- iptables/extensions/libipt_TARPIT.man
+++ iptables/extensions/libipt_TARPIT.man
@@ -0,0 +1,34 @@
+Captures and holds incoming TCP connections using no local
+per-connection resources. Connections are accepted, but immediately
+switched to the persist state (0 byte window), in which the remote
+side stops sending data and asks to continue every 60-240 seconds.
+Attempts to close the connection are ignored, forcing the remote side
+to time out the connection in 12-24 minutes.
+
+This offers similar functionality to LaBrea
+<http://www.hackbusters.net/LaBrea/> but doesn't require dedicated
+hardware or IPs. Any TCP port that you would normally DROP or REJECT
+can instead become a tarpit.
+
+To tarpit connections to TCP port 80 destined for the current machine:
+.IP
+iptables -A INPUT -p tcp -m tcp --dport 80 -j TARPIT
+.P
+To significantly slow down Code Red/Nimda-style scans of unused address
+space, forward unused ip addresses to a Linux box not acting as a router
+(e.g. "ip route 10.0.0.0 255.0.0.0 ip.of.linux.box" on a Cisco), enable IP
+forwarding on the Linux box, and add:
+.IP
+iptables -A FORWARD -p tcp -j TARPIT
+.IP
+iptables -A FORWARD -j DROP
+.TP
+NOTE:
+If you use the conntrack module while you are using TARPIT, you should
+also use the NOTRACK target, or the kernel will unnecessarily allocate
+resources for each TARPITted connection. To TARPIT incoming
+connections to the standard IRC port while using conntrack, you could:
+.IP
+iptables -t raw -A PREROUTING -p tcp --dport 6667 -j NOTRACK
+.IP
+iptables -A INPUT -p tcp --dport 6667 -j TARPIT
--- iptables/extensions/libipt_TCPLAG.c
+++ iptables/extensions/libipt_TCPLAG.c
@@ -0,0 +1,215 @@
+/* libipt_TCPLAG.c -- module for iptables to interface with TCPLAG target
+ * Copyright (C) 2002 Telford Tendys <telford@triode.net.au>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * Shared library add-on to iptables for TCPLAG target control
+ *
+ * This allows installation and removal of the TCPLAG target
+ * Note that there is a lot more commentary in this file than
+ * the average libipt target (i.e. more than none) but these
+ * are just my deductions based on examination of the source
+ * and 
+ */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <syslog.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_TCPLAG.h>
+
+/*
+ * This merely dumps out text for the user
+ * (saves keeping the manpage up to date)
+ */
+static void help( void )
+{
+	printf( "TCPLAG options:\n"
+			" --log-level=n    Set the syslog level to n (integer 0 to 7)\n\n"
+			" --log-prefix=xx  Prefix log messages with xx\n" );
+}
+
+/*
+ * See "man getopt_long" for an explanation of this structure
+ *
+ * If one of our options DOES happen to come up then we get
+ * a callback into parse(), our vals must not overlap with any
+ * normal iptables short options (I think) because there is only
+ * one actual options handler and it can't tell whose options it
+ * is really looking at unless they are all distinct.
+ *
+ * These are exactly the same as the LOG target options
+ * and have the same purpose.
+ */
+static const struct option opts[] =
+{
+	{ "log-level",     1, 0, '!' },
+	{ "log-prefix",    1, 0, '#' },
+	{ 0 }
+};
+
+/*
+ * This gives us a chance to install some initial values in
+ * our own private data structure (which is at t->data).
+ * Probably we could fiddle with t->tflags too but there is
+ * no great advantage in doing so.
+ */
+static void init( struct ipt_entry_target *t, unsigned int *nfcache )
+{
+	struct ipt_tcplag *el = (struct ipt_tcplag *)t->data;
+	memset( el, 0, sizeof( struct ipt_tcplag ));
+	el->level = 4; /* Default to warning level */
+	strcpy( el->prefix, "TCPLAG:" ); /* Give a reasonable default prefix */
+}
+
+/*
+ * It doesn't take much thought to see how little thought has gone into
+ * this particular API. However, to add to that I'd just like to say that
+ * it can be made to work and small miracles are still miracles.
+ *
+ * The input parameters are as follows:
+ * 
+ *  c      --  the 'val' from opts[] above, could possibly be something
+ *             we cannot recognise in which case return(0).
+ *             If we do recognise it then return(1).
+ *
+ *  argv   --  in case we want to take parameters from the command line,
+ *             not sure how to safely ensure that the parameter that
+ *             we want to take will really exist, presumably getopt_long()
+ *             will have already checked such things (what about optional
+ *             parameters huh?).
+ *
+ *  invert --  if the option parameter had '!' in front of it, usually this
+ *             would inversion of the matching sense but I don't think it
+ *             is useful in the case of targets.
+ *
+ *  flags  --  always (*target)->tflags for those who feel it is better
+ *             to access this field indirectly <shrug> starts of
+ *             zero for a fresh target, gets fed into final_check().
+ *
+ *  entry  --  apparently useless
+ *
+ *  target --  the record that holds data about this target,
+ *             most importantly, our private data is (*target)->data
+ *             (this has already been malloced for us).
+ */
+static int parse( int c, char **argv, int invert, unsigned int *flags,
+				  const struct ipt_entry *entry, struct ipt_entry_target **target )
+{
+	struct ipt_tcplag *el = (struct ipt_tcplag *)( *target )->data;
+/*
+ * Yeah, we could complain about options being issued twice but
+ * is it really worth the trouble? Will it make the world a better place?
+ */
+	switch( c )
+	{
+/*
+ * I really can't be bothered with the syslog naming convention,
+ * it isn't terribly useful anyhow.
+ */
+		case '!':
+			el->level = strtol( optarg, 0, 10 );
+			return( 1 );
+/*
+ * 15 chars should be plenty
+ */
+		case '#':
+			strncpy( el->prefix, optarg, 15 );
+			el->prefix[ 14 ] = 0; /* Force termination */
+			return( 1 );
+	}
+	return( 0 );
+}
+
+/*
+ * This gets given the (*target)->tflags value from
+ * the parse() above and it gets called after all the
+ * parsing of options is completed. Thus if one option
+ * requires another option you can test the flags and
+ * decide whether everything is in order.
+ *
+ * If there is a problem then do something like:
+ *		exit_error( PARAMETER_PROBLEM, "foobar parameters detected in TCPLAG target");
+ *
+ * In this case, no errors are possible
+ */
+static void final_check( unsigned int flags ) { }
+/*
+ * This print is for the purpose of user-readable display
+ * such as what "iptables -L" would give. The notes in
+ * iptables.h say that target could possibly be a null pointer
+ * but coding of the various libipt_XX.c modules suggests
+ * that it is safe to presume target is correctly initialised.
+ */
+static void print(const struct ipt_ip *ip, const struct ipt_entry_target *target, int numeric)
+{
+	const struct ipt_tcplag *el = (const struct ipt_tcplag *)target->data;
+	printf("TCPLAG <%d>", el->level );
+	if( el->prefix[ 0 ])
+	{
+		printf( "%s", el->prefix );
+	}
+}
+
+/*
+ * As above but command-line style printout
+ * (machine-readable for restoring table)
+ */
+static void save( const struct ipt_ip *ip, const struct ipt_entry_target *target )
+{
+	const struct ipt_tcplag *el = (const struct ipt_tcplag *)target->data;
+	printf("TCPLAG --log-level=%d", el->level );
+	if( el->prefix[ 0 ])
+	{
+/*
+ * FIXME: Should have smarter quoting
+ */
+		printf( " --log-prefix='%s'", el->prefix );
+	}
+}
+
+/*
+ * The version must match the iptables version exactly
+ * which is a big pain, could use `iptables -V` in makefile
+ * but we can't guarantee compatibility with all iptables
+ * so we are stuck with only supporting one particular version.
+ */
+static struct iptables_target targ =
+{
+next:	          0,
+name:             "TCPLAG",
+version:          IPTABLES_VERSION,
+size:             IPT_ALIGN( sizeof( struct ipt_tcplag )),
+userspacesize:    IPT_ALIGN( sizeof( struct ipt_tcplag )),
+help:             &help,
+init:             &init,
+parse:            &parse,
+final_check:      &final_check,
+print:            &print,
+save:             &save,
+extra_opts:       opts
+};
+
+/*
+ * Always nervous trusting _init() but oh well that is the standard
+ * so have to go ahead and use it. This registers your target into
+ * the list of available targets so that your options become available.
+ */
+void _init( void ) { register_target( &targ ); }
--- iptables/extensions/libipt_time.c
+++ iptables/extensions/libipt_time.c
@@ -0,0 +1,549 @@
+/* Shared library add-on to iptables to add TIME matching support. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stddef.h> /* for 'offsetof' */
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_time.h>
+#include <time.h>
+
+static int globaldays;
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"TIME v%s options:\n"
+" [ --timestart value ] [ --timestop value] [ --days listofdays ] [ --datestart value ] [ --datestop value ]\n"
+"          timestart value : HH:MM (default 00:00)\n"
+"          timestop  value : HH:MM (default 23:59)\n"
+"                            Note: daylight savings time changes are not tracked\n"
+"          listofdays value: a list of days to apply\n"
+"                            from Mon,Tue,Wed,Thu,Fri,Sat,Sun\n"
+"                            Coma speparated, no space, case sensitive.\n"
+"                            Defaults to all days.\n"
+"          datestart value : YYYY[:MM[:DD[:hh[:mm[:ss]]]]]\n"
+"                            If any of month, day, hour, minute or second is\n"
+"                            not specified, then defaults to their smallest\n"
+"                            1900 <= YYYY < 2037\n"
+"                               1 <= MM <= 12\n"
+"                               1 <= DD <= 31\n"
+"                               0 <= hh <= 23\n"
+"                               0 <= mm <= 59\n"
+"                               0 <= ss <= 59\n"
+"          datestop  value : YYYY[:MM[:DD[:hh[:mm[:ss]]]]]\n"
+"                            If the whole option is ommited, default to never stop\n"
+"                            If any of month, day, hour, minute or second is\n"
+"                            not specified, then default to their smallest\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "timestart", 1, 0, '1' },
+	{ "timestop", 1, 0, '2' },
+	{ "days", 1, 0, '3'},
+	{ "datestart", 1, 0, '4' },
+	{ "datestop", 1, 0, '5' },
+	{0}
+};
+
+/* Initialize the match. */
+static void
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	struct ipt_time_info *info = (struct ipt_time_info *)m->data;
+	globaldays = 0;
+        /* By default, we match on everyday */
+	info->days_match = 127;
+	/* By default, we match on every hour:min of the day */
+	info->time_start = 0;
+	info->time_stop  = 1439;  /* (23*60+59 = 1439 */
+	/* By default, we don't have any date-begin or date-end boundaries */
+	info->date_start = 0;
+	info->date_stop  = LONG_MAX;
+}
+
+/**
+ * param: part1, a pointer on a string 2 chars maximum long string, that will contain the hours.
+ * param: part2, a pointer on a string 2 chars maximum long string, that will contain the minutes.
+ * param: str_2_parse, the string to parse.
+ * return: 1 if ok, 0 if error.
+ */
+static int
+split_time(char **part1, char **part2, const char *str_2_parse)
+{
+	unsigned short int i,j=0;
+	char *rpart1 = *part1;
+	char *rpart2 = *part2;
+	unsigned char found_column = 0;
+
+	/* Check the length of the string */
+	if (strlen(str_2_parse) > 5)
+		return 0;
+	/* parse the first part until the ':' */
+	for (i=0; i<2; i++)
+	{
+		if (str_2_parse[i] == ':')
+			found_column = 1;
+		else
+			rpart1[i] = str_2_parse[i];
+	}
+	if (!found_column)
+		i++;
+	j=i;
+	/* parse the second part */
+	for (; i<strlen(str_2_parse); i++)
+	{
+		rpart2[i-j] = str_2_parse[i];
+	}
+	/* if we are here, format should be ok. */
+	return 1;
+}
+
+static int
+parse_number(char *str, int num_min, int num_max, int *number)
+{
+	/* if the number starts with 0, replace it with a space else
+	string_to_number() will interpret it as octal !! */
+	if (strlen(str) == 0)
+		return 0;
+
+	if ((str[0] == '0') && (str[1] != '\0'))
+		str[0] = ' ';
+
+	return string_to_number(str, num_min, num_max, number);
+}
+
+static void
+parse_time_string(int *hour, int *minute, const char *time)
+{
+	char *hours;
+	char *minutes;
+	hours = (char *)malloc(3);
+	minutes = (char *)malloc(3);
+	memset(hours, 0, 3);
+	memset(minutes, 0, 3);
+
+	if (split_time((char **)&hours, (char **)&minutes, time) == 1)
+	{
+		*hour = 0;
+		*minute = 0;
+		if ((parse_number((char *)hours, 0, 23, hour) != -1) &&
+		    (parse_number((char *)minutes, 0, 59, minute) != -1))
+		{
+			free(hours);
+			free(minutes);
+			return;
+		}
+	}
+
+	free(hours);
+	free(minutes);
+
+	/* If we are here, there was a problem ..*/
+	exit_error(PARAMETER_PROBLEM,
+		   "invalid time `%s' specified, should be HH:MM format", time);
+}
+
+/* return 1->ok, return 0->error */
+static int
+parse_day(int *days, int from, int to, const char *string)
+{
+	char *dayread;
+	char *days_str[7] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
+	unsigned short int days_of_week[7] = {64, 32, 16, 8, 4, 2, 1};
+	unsigned int i;
+
+	dayread = (char *)malloc(4);
+	bzero(dayread, 4);
+	if ((to-from) != 3) {
+		free(dayread);
+		return 0;
+	}
+	for (i=from; i<to; i++)
+		dayread[i-from] = string[i];
+	for (i=0; i<7; i++)
+		if (strcmp(dayread, days_str[i]) == 0)
+		{
+			*days |= days_of_week[i];
+			free(dayread);
+			return 1;
+		}
+	/* if we are here, we didn't read a valid day */
+	free(dayread);
+	return 0;
+}
+
+static void
+parse_days_string(int *days, const char *daystring)
+{
+	int len;
+	int i=0;
+	char *err = "invalid days `%s' specified, should be Sun,Mon,Tue... format";
+
+	len = strlen(daystring);
+	if (len < 3)
+		exit_error(PARAMETER_PROBLEM, err, daystring);	
+	while(i<len)
+	{
+		if (parse_day(days, i, i+3, daystring) == 0)
+			exit_error(PARAMETER_PROBLEM, err, daystring);
+		i += 4;
+	}
+}
+
+static int
+parse_date_field(const char *str_to_parse, int str_to_parse_s, int start_pos,
+                 char *dest, int *next_pos)
+{
+	unsigned char found_value = 0;
+	unsigned char found_column = 0;
+	int i;
+
+	for (i=0; i<2; i++)
+	{
+		if ((i+start_pos) >= str_to_parse_s) /* don't exit boundaries of the string..  */
+			break;
+		if (str_to_parse[i+start_pos] == ':')
+			found_column = 1;
+		else
+		{
+			found_value = 1;
+			dest[i] = str_to_parse[i+start_pos];
+		}
+	}
+	if (found_value == 0)
+		return 0;
+	*next_pos = i + start_pos;
+	if (found_column == 0)
+		++(*next_pos);
+	return 1;
+}
+
+static int
+split_date(char *year, char *month,  char *day,
+           char *hour, char *minute, char *second,
+           const char *str_to_parse)
+{
+        int i;
+        unsigned char found_column = 0;
+	int str_to_parse_s = strlen(str_to_parse);
+
+        /* Check the length of the string */
+        if ((str_to_parse_s > 19) ||  /* YYYY:MM:DD:HH:MM:SS */
+            (str_to_parse_s < 4))     /* YYYY*/
+                return 0;
+
+	/* Clear the buffers */
+        memset(year, 0, 4);
+	memset(month, 0, 2);
+	memset(day, 0, 2);
+	memset(hour, 0, 2);
+	memset(minute, 0, 2);
+	memset(second, 0, 2);
+
+	/* parse the year YYYY */
+	found_column = 0;
+	for (i=0; i<5; i++)
+	{
+		if (i >= str_to_parse_s)
+			break;
+		if (str_to_parse[i] == ':')
+		{
+			found_column = 1;
+			break;
+		}
+		else
+			year[i] = str_to_parse[i];
+	}
+	if (found_column == 1)
+		++i;
+
+	/* parse the month if it exists */
+	if (! parse_date_field(str_to_parse, str_to_parse_s, i, month, &i))
+		return 1;
+
+	if (! parse_date_field(str_to_parse, str_to_parse_s, i, day, &i))
+		return 1;
+
+	if (! parse_date_field(str_to_parse, str_to_parse_s, i, hour, &i))
+		return 1;
+
+	if (! parse_date_field(str_to_parse, str_to_parse_s, i, minute, &i))
+		return 1;
+
+	parse_date_field(str_to_parse, str_to_parse_s, i, second, &i);
+
+        /* if we are here, format should be ok. */
+        return 1;
+}
+
+static time_t
+parse_date_string(const char *str_to_parse)
+{
+	char year[5];
+	char month[3];
+	char day[3];
+	char hour[3];
+	char minute[3];
+	char second[3];
+	struct tm t;
+	time_t temp_time;
+
+	memset(year, 0, 5);
+	memset(month, 0, 3);
+	memset(day, 0, 3);
+	memset(hour, 0, 3);
+	memset(minute, 0, 3);
+	memset(second, 0, 3);
+
+        if (split_date(year, month, day, hour, minute, second, str_to_parse) == 1)
+        {
+		memset((void *)&t, 0, sizeof(struct tm));
+		t.tm_isdst = -1;
+		t.tm_mday = 1;
+		if (!((parse_number(year, 1900, 2037, &(t.tm_year)) == -1) ||
+		      (parse_number(month, 1, 12, &(t.tm_mon)) == -1) ||
+		      (parse_number(day, 1, 31, &(t.tm_mday)) == -1) ||
+		      (parse_number(hour, 0, 9999, &(t.tm_hour)) == -1) ||
+		      (parse_number(minute, 0, 59, &(t.tm_min)) == -1) ||
+		      (parse_number(second, 0, 59, &(t.tm_sec)) == -1)))
+		{
+			t.tm_year -= 1900;
+			--(t.tm_mon);
+			temp_time = mktime(&t);
+			if (temp_time != -1)
+				return temp_time;
+		}
+	}
+	exit_error(PARAMETER_PROBLEM,
+		   "invalid date `%s' specified, should be YYYY[:MM[:DD[:hh[:mm[:ss]]]]] format", str_to_parse);
+}
+
+#define IPT_TIME_START 0x01
+#define IPT_TIME_STOP  0x02
+#define IPT_TIME_DAYS  0x04
+#define IPT_DATE_START 0x08
+#define IPT_DATE_STOP  0x10
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_time_info *timeinfo = (struct ipt_time_info *)(*match)->data;
+	int hours, minutes;
+	time_t temp_date;
+
+	switch (c)
+	{
+		/* timestart */
+	case '1':
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+                                   "unexpected '!' with --timestart");
+		if (*flags & IPT_TIME_START)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --timestart twice");
+		parse_time_string(&hours, &minutes, optarg);
+		timeinfo->time_start = (hours * 60) + minutes;
+		*flags |= IPT_TIME_START;
+		break;
+		/* timestop */
+	case '2':
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+                                   "unexpected '!' with --timestop");
+		if (*flags & IPT_TIME_STOP)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --timestop twice");
+		parse_time_string(&hours, &minutes, optarg);
+		timeinfo->time_stop = (hours * 60) + minutes;
+		*flags |= IPT_TIME_STOP;
+		break;
+
+		/* days */
+	case '3':
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+                                   "unexpected '!' with --days");
+		if (*flags & IPT_TIME_DAYS)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --days twice");
+		parse_days_string(&globaldays, optarg);
+		timeinfo->days_match = globaldays;
+		*flags |= IPT_TIME_DAYS;
+		break;
+
+		/* datestart */
+	case '4':
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+                                   "unexpected '!' with --datestart");
+		if (*flags & IPT_DATE_START)
+			exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --datestart twice");
+		temp_date = parse_date_string(optarg);
+		timeinfo->date_start = temp_date;
+		*flags |= IPT_DATE_START;
+		break;
+
+		/* datestop*/
+	case '5':
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+                                   "unexpected '!' with --datestop");
+		if (*flags & IPT_DATE_STOP)
+			exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --datestop twice");
+		temp_date = parse_date_string(optarg);
+		timeinfo->date_stop = temp_date;
+		*flags |= IPT_DATE_STOP;
+		break;
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+/* Final check */
+static void
+final_check(unsigned int flags)
+{
+	/* Nothing to do */
+}
+
+
+static void
+print_days(int daynum)
+{
+	char *days[7] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
+	unsigned short int days_of_week[7] = {64, 32, 16, 8, 4, 2, 1};
+	unsigned short int i, nbdays=0;
+
+	for (i=0; i<7; i++) {
+		if ((days_of_week[i] & daynum) == days_of_week[i])
+		{
+			if (nbdays>0)
+				printf(",%s", days[i]);
+			else
+				printf("%s", days[i]);
+			++nbdays;
+		}
+	}
+	printf(" ");
+}
+
+static void
+divide_time(int fulltime, int *hours, int *minutes)
+{
+	*hours = fulltime / 60;
+	*minutes = fulltime % 60;
+}
+
+static void
+print_date(time_t date, char *command)
+{
+	struct tm *t;
+
+	/* If it's default value, don't print..*/
+	if (((date == 0) || (date == LONG_MAX)) && (command != NULL))
+		return;
+	t = localtime(&date);
+	if (command != NULL)
+		printf("%s %d:%d:%d:%d:%d:%d ", command, (t->tm_year + 1900), (t->tm_mon + 1),
+			t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec);
+        else
+        	printf("%d-%d-%d %d:%d:%d ", (t->tm_year + 1900), (t->tm_mon + 1),
+			t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec);
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	struct ipt_time_info *time = ((struct ipt_time_info *)match->data);
+	int hour_start, hour_stop, minute_start, minute_stop;
+
+	divide_time(time->time_start, &hour_start, &minute_start);
+	divide_time(time->time_stop, &hour_stop, &minute_stop);
+	printf("TIME ");
+	if (time->time_start != 0)
+		printf("from %d:%d ", hour_start, minute_start);
+	if (time->time_stop != 1439) /* 23*60+59 = 1439 */
+		printf("to %d:%d ", hour_stop, minute_stop);
+	printf("on ");
+	if (time->days_match == 127)
+		printf("all days ");
+	else
+		print_days(time->days_match);
+	if (time->date_start != 0)
+	{
+		printf("starting from ");
+		print_date(time->date_start, NULL);
+	}
+	if (time->date_stop != LONG_MAX)
+	{
+		printf("until date ");
+		print_date(time->date_stop, NULL);
+	}
+}
+
+/* Saves the data in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	struct ipt_time_info *time = ((struct ipt_time_info *)match->data);
+	int hour_start, hour_stop, minute_start, minute_stop;
+
+	divide_time(time->time_start, &hour_start, &minute_start);
+	divide_time(time->time_stop, &hour_stop, &minute_stop);
+	if (time->time_start != 0)
+		printf("--timestart %.2d:%.2d ",
+		        hour_start, minute_start);
+	
+	if (time->time_stop != 1439) /* 23*60+59 = 1439 */
+		printf("--timestop %.2d:%.2d ",
+		        hour_stop, minute_stop);
+	
+	if (time->days_match != 127)
+	{
+		printf("--days ");
+		print_days(time->days_match);
+		printf(" ");
+	}
+	print_date(time->date_start, "--datestart");
+	print_date(time->date_stop, "--datestop");
+}
+
+/* have to use offsetof() instead of IPT_ALIGN(), since kerneltime must not
+ * be compared when user deletes rule with '-D' */
+static
+struct iptables_match timestruct = {
+	.next		= NULL,
+	.name		= "time",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_time_info)),
+	.userspacesize	= offsetof(struct ipt_time_info, kerneltime),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_match(&timestruct);
+}
--- iptables/extensions/libipt_time.man
+++ iptables/extensions/libipt_time.man
@@ -0,0 +1,16 @@
+This matches if the packet arrival time/date is within a given range. All options are facultative.
+.TP
+.BI " --timestart " "value"
+Match only if it is after `value' (Inclusive, format: HH:MM ; default 00:00).
+.TP
+.BI "--timestop  " "value"
+Match only if it is before `value' (Inclusive, format: HH:MM ; default 23:59).
+.TP
+.BI "--days " "listofdays"
+Match only if today is one of the given days. (format: Mon,Tue,Wed,Thu,Fri,Sat,Sun ; default everyday)
+.TP
+.BI "--datestart " "date"
+Match only if it is after `date' (Inclusive, format: YYYY[:MM[:DD[:hh[:mm[:ss]]]]] ; h,m,s start from 0 ; default to 1970)
+.TP
+.BI "--datestop " "date"
+Match only if it is before `date' (Inclusive, format: YYYY[:MM[:DD[:hh[:mm[:ss]]]]] ; h,m,s start from 0 ; default to 2037)
--- iptables/extensions/libipt_TRACE.c
+++ iptables/extensions/libipt_TRACE.c
@@ -0,0 +1,63 @@
+/* Shared library add-on to iptables to add TRACE target support. */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"TRACE target v%s takes no options\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ipt_entry_target *t, unsigned int *nfcache)
+{
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      struct ipt_entry_target **target)
+{
+	return 0;
+}
+
+static void
+final_check(unsigned int flags)
+{
+}
+
+static
+struct iptables_target trace
+= {	.next = NULL,
+	.name = "TRACE",
+	.version = IPTABLES_VERSION,
+	.size = IPT_ALIGN(0),
+	.userspacesize = IPT_ALIGN(0),
+	.help = &help,
+	.init = &init,
+	.parse = &parse,
+	.final_check = &final_check,
+	.print = NULL, /* print */
+	.save = NULL, /* save */
+	.extra_opts = opts
+};
+
+void _init(void)
+{
+	register_target(&trace);
+}
--- iptables/extensions/libipt_TRACE.man
+++ iptables/extensions/libipt_TRACE.man
@@ -0,0 +1,3 @@
+This target has no options.  It just turns on 
+.B packet tracing
+for all packets that match this rule.
--- iptables/extensions/libipt_TRIGGER.c
+++ iptables/extensions/libipt_TRIGGER.c
@@ -0,0 +1,215 @@
+/* Port-triggering target. 
+ *
+ * Copyright (C) 2003, CyberTAN Corporation
+ * All Rights Reserved.
+ */
+
+/* Shared library add-on to iptables to add port-trigger support. */
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ip_nat_rule.h>
+#include <linux/netfilter_ipv4/ipt_TRIGGER.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"TRIGGER v%s options:\n"
+" --trigger-type (dnat|in|out)\n"
+"				Trigger type\n"
+" --trigger-proto proto\n"
+"				Trigger protocol\n"
+" --trigger-match port[-port]\n"
+"				Trigger destination port range\n"
+" --trigger-relate port[-port]\n"
+"				Port range to map related destination port range to.\n\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "trigger-type", 1, 0, '1' },
+	{ "trigger-proto", 1, 0, '2' },
+	{ "trigger-match", 1, 0, '3' },
+	{ "trigger-relate", 1, 0, '4' },
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ipt_entry_target *t, unsigned int *nfcache)
+{
+	/* Can't cache this */
+	*nfcache |= NFC_UNKNOWN;
+}
+
+/* Parses ports */
+static void
+parse_ports(const char *arg, u_int16_t *ports)
+{
+	const char *dash;
+	int port;
+
+	port = atoi(arg);
+	if (port == 0 || port > 65535)
+		exit_error(PARAMETER_PROBLEM, "Port range `%s' invalid\n", arg);
+
+	dash = strchr(arg, '-');
+	if (!dash)
+		ports[0] = ports[1] = port;
+	else {
+		int maxport;
+
+		maxport = atoi(dash + 1);
+		if (maxport == 0 || maxport > 65535)
+			exit_error(PARAMETER_PROBLEM,
+				   "Port range `%s' invalid\n", dash+1);
+		if (maxport < port)
+			exit_error(PARAMETER_PROBLEM,
+				   "Port range `%s' invalid\n", arg);
+		ports[0] = port;
+		ports[1] = maxport;
+	}
+}
+
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      struct ipt_entry_target **target)
+{
+	struct ipt_trigger_info *info = (struct ipt_trigger_info *)(*target)->data;
+
+	switch (c) {
+	case '1':
+		if (!strcasecmp(optarg, "dnat"))
+			info->type = IPT_TRIGGER_DNAT;
+		else if (!strcasecmp(optarg, "in"))
+			info->type = IPT_TRIGGER_IN;
+		else if (!strcasecmp(optarg, "out"))
+			info->type = IPT_TRIGGER_OUT;
+		else
+			exit_error(PARAMETER_PROBLEM,
+				   "unknown type `%s' specified", optarg);
+		return 1;
+
+	case '2':
+		if (!strcasecmp(optarg, "tcp"))
+			info->proto = IPPROTO_TCP;
+		else if (!strcasecmp(optarg, "udp"))
+			info->proto = IPPROTO_UDP;
+		else if (!strcasecmp(optarg, "all"))
+			info->proto = 0;
+		else
+			exit_error(PARAMETER_PROBLEM,
+				   "unknown protocol `%s' specified", optarg);
+		return 1;
+
+	case '3':
+		if (check_inverse(optarg, &invert, &optind, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --trigger-match");
+
+		parse_ports(optarg, info->ports.mport);
+		return 1;
+
+	case '4':
+		if (check_inverse(optarg, &invert, &optind, 0))
+			exit_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --trigger-relate");
+
+		parse_ports(optarg, info->ports.rport);
+		*flags |= IP_NAT_RANGE_PROTO_SPECIFIED;
+		return 1;
+
+	default:
+		return 0;
+	}
+}
+
+/* Final check; don't care. */
+static void final_check(unsigned int flags)
+{
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_target *target,
+      int numeric)
+{
+	struct ipt_trigger_info *info = (struct ipt_trigger_info *)target->data;
+
+	printf("TRIGGER ");
+	if (info->type == IPT_TRIGGER_DNAT)
+		printf("type:dnat ");
+	else if (info->type == IPT_TRIGGER_IN)
+		printf("type:in ");
+	else if (info->type == IPT_TRIGGER_OUT)
+		printf("type:out ");
+
+	if (info->proto == IPPROTO_TCP)
+		printf("tcp ");
+	else if (info->proto == IPPROTO_UDP)
+		printf("udp ");
+
+	printf("match:%hu", info->ports.mport[0]);
+	if (info->ports.mport[1] > info->ports.mport[0])
+		printf("-%hu", info->ports.mport[1]);
+	printf(" ");
+
+	printf("relate:%hu", info->ports.rport[0]);
+	if (info->ports.rport[1] > info->ports.rport[0])
+		printf("-%hu", info->ports.rport[1]);
+	printf(" ");
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_target *target)
+{
+	struct ipt_trigger_info *info = (struct ipt_trigger_info *)target->data;
+
+	printf(" --trigger-type");
+	if (info->type == IPT_TRIGGER_DNAT)
+		printf(" dnat");
+	else if (info->type == IPT_TRIGGER_IN)
+		printf(" in");
+	else if (info->type == IPT_TRIGGER_OUT)
+		printf(" out");
+	printf(" --trigger-proto");
+	if (info->proto == IPPROTO_TCP)
+		printf(" tcp");
+	else if (info->proto == IPPROTO_UDP)
+		printf(" udp");
+	printf(" --trigger-match %hu-%hu", info->ports.mport[0], info->ports.mport[1]);
+	printf(" --trigger-relate %hu-%hu", info->ports.rport[0], info->ports.rport[1]);
+}
+
+static struct iptables_target trigger = {
+	.next		= NULL, 
+	.name		= "TRIGGER",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_trigger_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_trigger_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts 
+};
+
+void _init(void)
+{
+	register_target(&trigger);
+}
--- iptables/extensions/libipt_u32.c
+++ iptables/extensions/libipt_u32.c
@@ -0,0 +1,264 @@
+/* Shared library add-on to iptables to add u32 matching,
+ * generalized matching on values found at packet offsets
+ *
+ * Detailed doc is in the kernel module source
+ * net/ipv4/netfilter/ipt_u32.c
+ *
+ * (C) 2002 by Don Cohen <don-netf@isis.cs3-inc.com>
+ * Released under the terms of GNU GPL v2
+ */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_u32.h>
+#include <errno.h>
+#include <ctype.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf( "u32 v%s options:\n"
+		" --u32 tests\n"
+		" tests := location = value | tests && location = value\n"
+		" value := range | value , range\n"
+		" range := number | number : number\n"
+		" location := number | location operator number\n"
+		" operator := & | << | >> | @\n"
+		,IPTABLES_VERSION);
+}
+
+/* defined in /usr/include/getopt.h maybe in man getopt */
+static struct option opts[] = {
+	{ "u32", 1, 0, '1' },
+	{ 0 }
+};
+
+/* shared printing code */
+static void print_u32(struct ipt_u32 *data)
+{
+	unsigned int testind;
+
+	for (testind=0; testind < data->ntests; testind++) {
+		if (testind) printf("&&");
+		{
+			unsigned int i;
+
+			printf("0x%x", data->tests[testind].location[0].number);
+			for (i = 1; i < data->tests[testind].nnums; i++) {
+				switch (data->tests[testind].location[i].nextop) {
+				case IPT_U32_AND: printf("&"); break;
+				case IPT_U32_LEFTSH: printf("<<"); break;
+				case IPT_U32_RIGHTSH: printf(">>"); break;
+				case IPT_U32_AT: printf("@"); break;
+				}
+				printf("0x%x", data->tests[testind].location[i].number);
+			}
+			printf("=");
+			for (i = 0; i < data->tests[testind].nvalues; i++) {
+				if (i) printf(",");
+				if (data->tests[testind].value[i].min
+				    == data->tests[testind].value[i].max)
+					printf("0x%x", data->tests[testind].value[i].min);
+				else printf("0x%x:0x%x", data->tests[testind].value[i].min,
+					    data->tests[testind].value[i].max);
+			}
+		}
+	}
+	printf(" ");
+}
+
+/* string_to_number is not quite what we need here ... */
+u_int32_t parse_number(char **s, int pos)
+{
+	u_int32_t number;
+	char *end;
+	errno = 0;
+
+	number = strtoul(*s, &end, 0);
+	if (end == *s)
+		exit_error(PARAMETER_PROBLEM, 
+			   "u32: at char %d expected number", pos);
+	if (errno)
+		exit_error(PARAMETER_PROBLEM, 
+			   "u32: at char %d error reading number", pos);
+	*s = end;
+	return number;
+}
+
+/* Function which parses command options; returns true if it ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_u32 *data = (struct ipt_u32 *)(*match)->data;
+	char *arg = argv[optind-1]; /* the argument string */
+	char *start = arg;
+	int state=0, testind=0, locind=0, valind=0;
+
+	if (c != '1') return 0;
+	/* states: 0 = looking for numbers and operations, 1 = looking for ranges */
+	while (1) { /* read next operand/number or range */
+		while (isspace(*arg)) 
+			arg++;  /* skip white space */
+		if (! *arg) { /* end of argument found */
+			if (state == 0)
+				exit_error(PARAMETER_PROBLEM, 
+					   "u32: input ended in location spec");
+			if (valind == 0)
+				exit_error(PARAMETER_PROBLEM, 
+					   "u32: test ended with no value spec");
+			data->tests[testind].nnums = locind;
+			data->tests[testind].nvalues = valind;
+			testind++;
+			data->ntests=testind;
+			if (testind > U32MAXSIZE)
+				exit_error(PARAMETER_PROBLEM, 
+					   "u32: at char %d too many &&'s",
+					   arg-start);
+			/* debugging 
+			   print_u32(data);printf("\n");
+			   exit_error(PARAMETER_PROBLEM, "debugging output done"); */
+			return 1;
+		}
+		if (state == 0) {
+			/* reading location: read a number if nothing read yet,
+			   otherwise either op number or = to end location spec */	 
+			if (*arg == '=') {
+				if (locind == 0)
+					exit_error(PARAMETER_PROBLEM,
+						   "u32: at char %d location spec missing", arg-start);
+				else {
+					arg++; 
+					state=1;
+				}
+			}
+			else {
+				if (locind) { /* need op before number */
+					if (*arg == '&') {
+						data->tests[testind].location[locind].nextop = IPT_U32_AND;
+					}
+					else if (*arg == '<') {
+						arg++;
+						if (*arg != '<')
+							exit_error(PARAMETER_PROBLEM,
+								   "u32: at char %d a second < expected", arg-start);
+						data->tests[testind].location[locind].nextop = IPT_U32_LEFTSH;
+					}
+					else if (*arg == '>') {
+						arg++;
+						if (*arg != '>')
+							exit_error(PARAMETER_PROBLEM,
+								   "u32: at char %d a second > expected", arg-start);
+						data->tests[testind].location[locind].nextop = IPT_U32_RIGHTSH;
+					}
+					else if (*arg == '@') {
+						data->tests[testind].location[locind].nextop = IPT_U32_AT;
+					}
+					else exit_error(PARAMETER_PROBLEM,
+							"u32: at char %d operator expected", arg-start);
+					arg++;
+				}
+				/* now a number; string_to_number skips white space? */
+				data->tests[testind].location[locind].number =
+					parse_number(&arg, arg-start);
+				locind++;
+				if (locind > U32MAXSIZE)
+					exit_error(PARAMETER_PROBLEM,
+						   "u32: at char %d too many operators", arg-start);
+			}
+		}
+		else {
+			/* state 1 - reading values: read a range if nothing read yet,
+			   otherwise either ,range or && to end test spec */
+			if (*arg == '&') {
+				arg++;
+				if (*arg != '&')
+					exit_error(PARAMETER_PROBLEM,
+						   "u32: at char %d a second & expected", arg-start);
+				if (valind == 0)
+					exit_error(PARAMETER_PROBLEM,
+						   "u32: at char %d value spec missing", arg-start);
+				else {
+					data->tests[testind].nnums = locind;
+					data->tests[testind].nvalues = valind;
+					testind++;
+					if (testind > U32MAXSIZE)
+						exit_error(PARAMETER_PROBLEM,
+							   "u32: at char %d too many &&'s", arg-start);
+					arg++; state=0; locind=0; valind=0;
+				}
+			}
+			else { /* read value range */
+				if (valind) { /* need , before number */
+					if (*arg != ',')
+						exit_error(PARAMETER_PROBLEM,
+							   "u32: at char %d expected , or &&", arg-start);
+					arg++;
+				}
+				data->tests[testind].value[valind].min = parse_number(&arg, arg-start);
+				while (isspace(*arg)) 
+					arg++;  /* another place white space could be */
+				if (*arg==':') {
+					arg++;
+					data->tests[testind].value[valind].max
+						= parse_number(&arg, arg-start);
+				}
+				else data->tests[testind].value[valind].max
+					     = data->tests[testind].value[valind].min;
+				valind++;
+				if (valind > U32MAXSIZE)
+					exit_error(PARAMETER_PROBLEM,
+						   "u32: at char %d too many ,'s", arg-start);
+			}
+		}
+	}
+}
+
+/* Final check; must specify something. */
+static void
+final_check(unsigned int flags)
+{
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	printf("u32 ");
+	print_u32((struct ipt_u32 *)match->data);
+}
+
+/* Saves the union ipt_matchinfo in parsable form to stdout. */
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	printf("--u32 ");
+	print_u32((struct ipt_u32 *)match->data);
+}
+
+struct iptables_match u32 = {
+	.next		= NULL,
+	.name		= "u32",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_u32)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_u32)),
+	.help		= &help,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void
+_init(void)
+{
+	register_match(&u32);
+}
--- iptables/extensions/libipt_u32.man
+++ iptables/extensions/libipt_u32.man
@@ -0,0 +1,8 @@
+U32 allows you to extract quantities of up to 4 bytes from a packet,
+AND them with specified masks, shift them by specified amounts and
+test whether the results are in any of a set of specified ranges.
+The specification of what to extract is general enough to skip over
+headers with lengths stored in the packet, as in IP or TCP header
+lengths.
+
+Details and examples are in the kernel module source.
--- iptables/extensions/libipt_web.c
+++ iptables/extensions/libipt_web.c
@@ -0,0 +1,214 @@
+/*
+
+	web (experimental)
+	HTTP client match
+	Copyright (C) 2006 Jonathan Zarate
+
+	Licensed under GNU GPL v2 or later.
+
+*/
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_web.h>
+
+
+#undef IPTABLES_SAVE
+
+
+static void help(void)
+{
+	printf(
+		"web match v0.01 (experimental)\n"
+		"Copyright (C) 2006 Jonathan Zarate\n"
+		"Options:\n"
+		"[!] --http (default)   find an HTTP GET/POST request\n"
+		"[!] --host <text ...>  find in host line\n"
+		"[!] --req <text ...>   find in request\n"
+		"[!] --path <text ...>  find in request path\n"
+		"[!] --query <text ...> find in request query\n"
+		"[!] --hore <text ...>  find in host or request line\n"
+		" <text> can be:\n"
+		"  text    contains\n"
+		"  ^text   begins with\n"
+		"  text$   ends with\n"
+		"  ^text$  exact match\n");
+}
+
+static void init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	*nfcache |= NFC_UNKNOWN;
+}
+
+static struct option opts[] = {
+	{ .name = "http",  .has_arg = 0, .flag = 0, .val = '1' },
+	{ .name = "host",  .has_arg = 1, .flag = 0, .val = '2' },
+	{ .name = "req",   .has_arg = 1, .flag = 0, .val = '3' },
+	{ .name = "path",  .has_arg = 1, .flag = 0, .val = '4' },
+	{ .name = "query", .has_arg = 1, .flag = 0, .val = '5' },
+	{ .name = "hore",  .has_arg = 1, .flag = 0, .val = '6' },
+	{ .name = 0 }
+};
+
+static int parse(int c, char **argv, int invert, unsigned int *flags,
+				 const struct ipt_entry *entry, unsigned int *nfcache,
+				 struct ipt_entry_match **match)
+{
+	const char *s;
+	char *e, *p;
+	int n;
+	struct ipt_web_info *info;
+
+	if ((c < '1') || (c > '6')) return 0;
+
+	if (*flags) exit_error(PARAMETER_PROBLEM, "Multiple modes are not supported");
+	*flags = 1;
+
+	info = (struct ipt_web_info *)(*match)->data;
+	switch (c) {
+	case '2':
+		info->mode = IPT_WEB_HOST;
+		break;
+	case '3':
+		info->mode = IPT_WEB_RURI;
+		break;
+	case '4':
+		info->mode = IPT_WEB_PATH;
+		break;
+	case '5':
+		info->mode = IPT_WEB_QUERY;
+		break;
+	case '6':
+		info->mode = IPT_WEB_HORE;
+		break;
+	default:	// IPT_WEB_HTTP
+		return 1;
+	}
+
+	if (entry->ip.proto != IPPROTO_TCP) {
+		exit_error(PARAMETER_PROBLEM, "web match requires -p tcp");
+	}
+
+	check_inverse(optarg, &invert, &optind, 0);
+	if (invert) info->invert = 1;
+
+	// convert arg to text\0text\0\0
+	s = argv[optind - 1];
+
+	if ((p = malloc(strlen(s) + 2)) == NULL) {
+		exit_error(PARAMETER_PROBLEM, "Not enough memory");
+	}
+
+	e = p;
+	while (*s) {
+		while ((*s == ' ') || (*s == '\n') || (*s == '\t')) ++s;
+		if (*s == 0) break;
+		while ((*s != 0) && (*s != ' ') && (*s != '\n') && (*s != '\t')) {
+			*e++ = *s++;
+		}
+		*e++ = 0;
+	}
+	n = (e - p);
+
+#if 0
+	*e = 0;
+	e = p;
+	while (*e) {
+		printf("[%s]\n", e);
+		e += strlen(e) + 1;
+	}
+#endif
+
+	if (n <= 1) {
+		exit_error(PARAMETER_PROBLEM, "Text is too short");
+	}
+	if (n >= IPT_WEB_MAXTEXT) {
+		exit_error(PARAMETER_PROBLEM, "Text is too long");
+	}
+	memcpy(info->text, p, n);
+	memset(info->text + n, 0, IPT_WEB_MAXTEXT - n);		// term, need to clear rest for ipt rule cmp
+	free(p);
+	return 1;
+}
+
+static void final_check(unsigned int flags)
+{
+}
+
+static void print_match(const struct ipt_web_info *info)
+{
+	const char *text;
+
+	if (info->invert) printf("! ");
+
+	switch (info->mode) {
+	case IPT_WEB_HOST:
+		printf("--host");
+		break;
+	case IPT_WEB_RURI:
+		printf("--req");
+		break;
+	case IPT_WEB_PATH:
+		printf("--path");
+		break;
+	case IPT_WEB_QUERY:
+		printf("--query");
+		break;
+	case IPT_WEB_HORE:
+		printf("--hore");
+		break;
+	default:
+		printf("--http");
+		return;
+	}
+
+	text = info->text;
+	printf(" \"");
+	while (*text) {
+		while (*text) {
+			if (*text == '"') printf("\\\"");
+				else putc(*text, stdout);
+			++text;
+		}
+		++text;
+		if (*text == 0) break;
+		putc(' ', stdout);
+	}
+	printf("\" ");
+}
+
+static void print(const struct ipt_ip *ip, const struct ipt_entry_match *match, int numeric)
+{
+	printf("web ");
+	print_match((const struct ipt_web_info *)match->data);
+}
+
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+#ifdef IPTABLES_SAVE
+	print_match((const struct ipt_web_info *)match->data);
+#endif
+}
+
+
+static struct iptables_match web_match = {
+	.name          = "web",
+	.version       = IPTABLES_VERSION,
+	.size          = IPT_ALIGN(sizeof(struct ipt_web_info)),
+	.userspacesize = IPT_ALIGN(sizeof(struct ipt_web_info)),
+	.help          = &help,
+	.init          = &init,
+	.parse         = &parse,
+	.final_check   = &final_check,
+	.print         = &print,
+	.save          = &save,
+	.extra_opts    = opts
+};
+
+void _init(void)
+{
+	register_match(&web_match);
+}
--- iptables/extensions/libipt_webmon.c
+++ iptables/extensions/libipt_webmon.c
@@ -0,0 +1,323 @@
+/*  webmon --	An iptables extension to match URLs in HTTP requests 
+ *  		This module can match using string match or regular expressions
+ *  		Originally designed for use with Gargoyle router firmware (gargoyle-router.com)
+ *
+ *
+ *  Copyright  2008-2010 by Eric Bishop <eric@gargoyle-router.com>
+ * 
+ *  This file is free software: you may copy, redistribute and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation, either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *  This file is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <arpa/inet.h>
+
+/*
+ * in iptables 1.4.0 and higher, iptables.h includes xtables.h, which
+ * we can use to check whether we need to deal with the new requirements
+ * in pre-processor directives below
+ */
+#include <iptables.h>
+#ifdef CONFIG_BCMWL6
+#include <linux/netfilter/xt_webmon.h>
+#define ipt_webmon_info		xt_webmon_info
+#else
+#include <linux/netfilter_ipv4/ipt_webmon.h>
+#endif
+
+#ifdef _XTABLES_H
+	#define iptables_match		xtables_match
+#endif
+
+/* 
+ * XTABLES_VERSION_CODE is only defined in versions 1.4.1 and later, which
+ * also require the use of xtables_register_match
+ * 
+ * Version 1.4.0 uses register_match like previous versions
+ */
+#ifdef XTABLES_VERSION_CODE 
+	#define register_match          xtables_register_match
+#endif
+
+unsigned char* read_entire_file(FILE* in, unsigned long read_block_size, unsigned long *length);
+
+#define DEFAULT_MAX      300
+
+#define SEARCH_LOAD_FILE 100
+#define DOMAIN_LOAD_FILE 101
+#define CLEAR_SEARCH     102
+#define CLEAR_DOMAIN     103
+
+static char* domain_load_file = NULL;
+static char* search_load_file = NULL;
+static uint32_t global_max_domains  = DEFAULT_MAX;
+static uint32_t global_max_searches = DEFAULT_MAX;
+
+/* Function which prints out usage message. */
+static void help(void)
+{
+	printf(	"webmon options:\n");
+}
+
+static struct option opts[] = 
+{
+	{ .name = "max_domains",        .has_arg = 1, .flag = 0, .val = WEBMON_MAXDOMAIN },
+	{ .name = "max_searches",       .has_arg = 1, .flag = 0, .val = WEBMON_MAXSEARCH },
+	{ .name = "search_load_file",   .has_arg = 1, .flag = 0, .val = SEARCH_LOAD_FILE },
+	{ .name = "domain_load_file",   .has_arg = 1, .flag = 0, .val = DOMAIN_LOAD_FILE },
+	{ .name = "clear_search",       .has_arg = 0, .flag = 0, .val = CLEAR_SEARCH },
+	{ .name = "clear_domain",       .has_arg = 0, .flag = 0, .val = CLEAR_DOMAIN },
+
+	{ .name = 0 }
+};
+
+static void webmon_init(
+#ifdef _XTABLES_H
+	struct xt_entry_match *match
+#else
+	struct ipt_entry_match *match, unsigned int *nfcache
+#endif
+	)
+{
+	struct ipt_webmon_info *info = (struct ipt_webmon_info *)match->data;
+	info->max_domains=DEFAULT_MAX;
+	info->max_searches=DEFAULT_MAX;
+	info->ref_count = NULL;
+}
+
+
+/* Function which parses command options; returns true if it ate an option */
+static int parse(	int c, 
+			char **argv,
+			int invert,
+			unsigned int *flags,
+#ifdef _XTABLES_H
+			const void *entry,
+#else
+			const struct ipt_entry *entry,
+			unsigned int *nfcache,
+#endif			
+			struct ipt_entry_match **match
+			)
+{
+	struct ipt_webmon_info *info = (struct ipt_webmon_info *)(*match)->data;
+	int valid_arg = 1;
+	long max;
+	switch (c)
+	{
+		case WEBMON_MAXSEARCH:
+			if( sscanf(argv[optind-1], "%ld", &max) == 0)
+			{
+				info->max_searches = DEFAULT_MAX ;
+				valid_arg = 0;
+			}
+			else
+			{
+				info->max_searches = (uint32_t)max;
+				global_max_searches = info->max_searches;
+			}
+			break;
+		case WEBMON_MAXDOMAIN:
+			if( sscanf(argv[optind-1], "%ld", &max) == 0)
+			{
+				info->max_domains = DEFAULT_MAX ;
+				valid_arg = 0;
+			}
+			else
+			{
+				info->max_domains = (uint32_t)max;
+				global_max_domains = info->max_domains;
+			}
+			break;
+		case SEARCH_LOAD_FILE:
+			search_load_file = strdup(optarg);
+			break;
+		case DOMAIN_LOAD_FILE:
+			domain_load_file = strdup(optarg);
+			break;
+		case CLEAR_SEARCH:
+			search_load_file = strdup("/dev/null");
+			break;
+		case CLEAR_DOMAIN:
+			domain_load_file = strdup("/dev/null");
+			break;
+		default:
+			valid_arg = 0;
+	}
+	return valid_arg;
+
+}
+
+	
+static void print_webmon_args(	struct ipt_webmon_info* info )
+{
+	printf("--max_domains %ld ", (unsigned long int)info->max_domains);
+	printf("--max_searches %ld ", (unsigned long int)info->max_searches);
+}
+
+
+static void do_load(char* file, uint32_t max, unsigned char type)
+{
+	if(file != NULL)
+	{
+		unsigned char* data = NULL;
+		unsigned long data_length = 0;
+		if(strcmp(file, "/dev/null") == 0)
+		{
+			data = (unsigned char*)malloc(10);
+			if(data != NULL)
+			{
+				uint32_t* maxp = (uint32_t*)(data+1);
+				data_length = 3+sizeof(uint32_t);
+				data[0] = type;
+				*maxp = max;
+				data[ sizeof(uint32_t)+1 ] = ' ';
+				data[ sizeof(uint32_t)+1 ] = '\0';
+			}
+		}
+		else
+		{
+			FILE* in = fopen(file, "r");
+			if(in != NULL)
+			{
+				char* file_data = read_entire_file(in, 4096, &data_length);
+				fclose(in);
+				if(file_data != NULL)
+				{
+					data_length = strlen(file_data) + sizeof(uint32_t)+2;
+					data = (unsigned char*)malloc(data_length);
+					if(data != NULL)
+					{
+						uint32_t* maxp = (uint32_t*)(data+1);
+						data[0] = type;
+						*maxp = max;
+						sprintf( (data+1+sizeof(uint32_t)),  "%s", file_data);
+					}
+					free(file_data);
+				}
+			}
+		}
+
+		if(data != NULL && data_length > 0)
+		{
+			int sockfd = -1;
+			sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
+			if(sockfd >= 0)
+			{
+				setsockopt(sockfd, IPPROTO_IP, WEBMON_SET, data, data_length);
+			}
+		}
+		if(data != NULL)
+		{
+			free(data);
+		}
+	}
+}
+
+
+static void final_check(unsigned int flags)
+{
+	do_load(domain_load_file, global_max_domains,  WEBMON_DOMAIN);
+	do_load(search_load_file, global_max_searches, WEBMON_SEARCH);
+}
+
+/* Prints out the matchinfo. */
+#ifdef _XTABLES_H
+static void print(const void *ip, const struct xt_entry_match *match, int numeric)
+#else	
+static void print(const struct ipt_ip *ip, const struct ipt_entry_match *match, int numeric)
+#endif
+{
+	printf("WEBMON ");
+	struct ipt_webmon_info *info = (struct ipt_webmon_info *)match->data;
+
+	print_webmon_args(info);
+}
+
+/* Saves the union ipt_matchinfo in parsable form to stdout. */
+#ifdef _XTABLES_H
+static void save(const void *ip, const struct xt_entry_match *match)
+#else
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+#endif
+{
+	struct ipt_webmon_info *info = (struct ipt_webmon_info *)match->data;
+	print_webmon_args(info);
+}
+
+static struct iptables_match webmon = 
+{ 
+	.next		= NULL,
+ 	.name		= "webmon",
+	#ifdef XTABLES_VERSION_CODE
+		.version = XTABLES_VERSION,
+	#else
+		.version = IPTABLES_VERSION,
+	#endif
+	.size		= IPT_ALIGN(sizeof(struct ipt_webmon_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_webmon_info)),
+	.help		= &help,
+	.init           = &webmon_init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_match(&webmon);
+}
+
+
+unsigned char* read_entire_file(FILE* in, unsigned long read_block_size, unsigned long *length)
+{
+	int max_read_size = read_block_size;
+	unsigned char* read_string = (unsigned char*)malloc(max_read_size+1);
+	unsigned long bytes_read = 0;
+	int end_found = 0;
+	while(end_found == 0)
+	{
+		int nextch = '?';
+		while(nextch != EOF && bytes_read < max_read_size)
+		{
+			nextch = fgetc(in);
+			if(nextch != EOF)
+			{
+				read_string[bytes_read] = (unsigned char)nextch;
+				bytes_read++;
+			}
+		}
+		read_string[bytes_read] = '\0';
+		end_found = (nextch == EOF) ? 1 : 0;
+		if(end_found == 0)
+		{
+			unsigned char *new_str;
+			max_read_size = max_read_size + read_block_size;
+		       	new_str = (unsigned char*)malloc(max_read_size+1);
+			memcpy(new_str, read_string, bytes_read);
+			free(read_string);
+			read_string = new_str;
+		}
+	}
+	*length = bytes_read;
+	return read_string;
+}
+
--- iptables/extensions/libipt_webstr.c
+++ iptables/extensions/libipt_webstr.c
@@ -0,0 +1,180 @@
+/* Shared library add-on to iptables to add string matching support. 
+* 
+* Copyright (C) 2000 Emmanuel Roger  <winfield@freegates.be>
+*
+* ChangeLog
+*     27.01.2001: Gianni Tedesco <gianni@ecsc.co.uk>
+*             Changed --tos to --string in save(). Also
+*             updated to work with slightly modified
+*             ipt_string_info.
+*/
+
+/* Shared library add-on to iptables to add webstr matching support. 
+*
+* Copyright (C) 2003, CyberTAN Corporation
+* All Rights Reserved.
+*
+* Description:
+*   This is shared library, added to iptables, for web content inspection. 
+*   It was derived from 'string' matching support, declared as above.
+*
+*/
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_webstr.h>
+
+/* Function which prints out usage message. */
+static void help(void)
+{
+	printf(
+		"WEBSTR match v%s options:\n"
+		"[!] --host 'host<host'   Match one of the hostname in a URL.\n"
+		"[!] --url 'key<key'      Match one of the keyword in a URL.\n"
+		"[!] --content ##         Match Java, ActiveX, proxy. See code for details.\n\n",
+		IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "host", 1, 0, '1' },
+	{ "url", 1, 0, '2' },
+	{ "content", 1, 0, '3' },
+	{0}
+};
+
+/* Initialize the match. */
+static void init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	*nfcache |= NFC_UNKNOWN;
+}
+
+static void parse_string(const unsigned char *s, struct ipt_webstr_info *info)
+{	
+	if (strlen(s) < MAX_WEBSTR_STRING) strcpy(info->string, s);
+		else exit_error(PARAMETER_PROBLEM, "WEBSTR too long `%s'", s);
+}
+
+/* Function which parses command options; returns true if it ate an option */
+static int parse(
+	int c, char **argv, int invert, unsigned int *flags,
+	const struct ipt_entry *entry,
+	unsigned int *nfcache,
+	struct ipt_entry_match **match)
+{
+	struct ipt_webstr_info *stringinfo = (struct ipt_webstr_info *)(*match)->data;
+
+	switch (c) {
+	case '1':
+		stringinfo->type = IPT_WEBSTR_HOST;
+		break;
+	case '2':
+		stringinfo->type = IPT_WEBSTR_URL;
+		break;
+	case '3':
+		stringinfo->type = IPT_WEBSTR_CONTENT;
+		break;
+	default:
+		return 0;
+	}
+
+	check_inverse(optarg, &invert, &optind, 0);
+	parse_string(argv[optind - 1], stringinfo);
+	if (invert) stringinfo->invert = 1;
+	stringinfo->len = strlen((char *)&stringinfo->string);
+
+	*flags = 1;
+	return 1;
+}
+
+static void print_string(char string[], int invert, int numeric)
+{
+	if (invert) fputc('!', stdout);
+	printf("%s ", string);
+}
+
+/* Final check; must have specified --string. */
+static void final_check(unsigned int flags)
+{
+	if (!flags) exit_error(PARAMETER_PROBLEM, "WEBSTR match: You must specify `--webstr'");
+}
+
+/* Prints out the matchinfo. */
+static void print(const struct ipt_ip *ip, const struct ipt_entry_match *match, int numeric)
+{
+	struct ipt_webstr_info *stringinfo = (struct ipt_webstr_info *)match->data;
+
+	printf("WEBSTR match ");
+
+	
+	switch (stringinfo->type) {
+	case IPT_WEBSTR_HOST:
+		printf("host ");
+		break;
+
+	case IPT_WEBSTR_URL:
+		printf("url ");
+		break;
+
+	case IPT_WEBSTR_CONTENT:
+		printf("content ");
+		break;
+
+	default:
+		printf("ERROR ");
+		break;
+	}
+
+	print_string(((struct ipt_webstr_info *)match->data)->string,
+		((struct ipt_webstr_info *)match->data)->invert, numeric);
+}
+
+/* Saves the union ipt_matchinfo in parsable form to stdout. */
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	struct ipt_webstr_info *stringinfo = (struct ipt_webstr_info *)match->data;
+
+	switch (stringinfo->type) {
+	case IPT_WEBSTR_HOST:
+		printf(" --host ");
+		break;
+
+	case IPT_WEBSTR_URL:
+		printf(" --url ");
+		break;
+
+	case IPT_WEBSTR_CONTENT:
+		printf(" --content ");
+		break;
+
+	default:
+		printf(" ERROR ");
+		break;
+	}
+	print_string(((struct ipt_webstr_info *)match->data)->string,
+		((struct ipt_webstr_info *)match->data)->invert, 0);
+}
+
+static struct iptables_match webstr
+	= { NULL,
+		"webstr",
+		IPTABLES_VERSION,
+		IPT_ALIGN(sizeof(struct ipt_webstr_info)),
+		IPT_ALIGN(sizeof(struct ipt_webstr_info)),
+		&help,
+		&init,
+		&parse,
+		&final_check,
+		&print,
+		&save,
+		opts
+	};
+
+void _init(void)
+{
+	register_match(&webstr);
+}
--- iptables/extensions/libipt_XOR.c
+++ iptables/extensions/libipt_XOR.c
@@ -0,0 +1,114 @@
+/* Shared library add-on to iptables for the XOR target
+ * (C) 2000 by Tim Vandermeersch <Tim.Vandermeersch@pandora.be>
+ * Based on libipt_TTL.c
+ *
+ * Version 1.0
+ *
+ * This program is distributed under the terms of GNU GPL
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <iptables.h>
+
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_XOR.h>
+
+#define	IPT_KEY_SET		1
+#define IPT_BLOCKSIZE_SET	2
+
+static void init(struct ipt_entry_target *t, unsigned int *nfcache) 
+{
+}
+
+static void help(void) 
+{
+	printf(
+		"XOR target v%s options\n"
+		"  --key string	          Set key to \"string\"\n"
+		"  --block-size		  Set block size\n",
+		IPTABLES_VERSION);
+}
+
+static int parse(int c, char **argv, int invert, unsigned int *flags,
+		const struct ipt_entry *entry, 
+		struct ipt_entry_target **target)
+{
+	struct ipt_XOR_info *info = (struct ipt_XOR_info *) (*target)->data;
+	
+	if (!optarg)
+		exit_error(PARAMETER_PROBLEM, "XOR: too few arguments");
+	
+	if (check_inverse(optarg, &invert, NULL, 0))
+		exit_error(PARAMETER_PROBLEM, "XOR: unexpected '!'");
+
+	switch (c) {	
+		case '1':
+			strncpy(info->key, optarg, 30);
+			info->key[29] = '\0';
+			*flags |= IPT_KEY_SET;
+			break;
+		case '2':
+			info->block_size = atoi(optarg);
+			*flags |= IPT_BLOCKSIZE_SET;
+			break;
+		default:
+			return 0;
+	}
+	
+	return 1;
+}
+
+static void final_check(unsigned int flags)
+{
+	if (!(flags & IPT_KEY_SET))
+		exit_error(PARAMETER_PROBLEM, "XOR: You must specify a key");
+	if (!(flags & IPT_BLOCKSIZE_SET))
+		exit_error(PARAMETER_PROBLEM, "XOR: You must specify a block-size");
+}
+
+static void save (const struct ipt_ip *ip,
+		const struct ipt_entry_target *target)
+{
+	const struct ipt_XOR_info *info = (struct ipt_XOR_info *) target->data;
+
+	printf("--key %s ", info->key);
+	printf("--block-size %u ", info->block_size);
+}
+
+static void print (const struct ipt_ip *ip,
+	const struct ipt_entry_target *target, int numeric)
+{
+	const struct ipt_XOR_info *info = (struct ipt_XOR_info *) target->data;
+
+	printf("key: %s ", info->key);
+	printf("block-size: %u ", info->block_size);
+}
+
+static struct option opts[] = {
+	{ "key", 1, 0, '1' },
+	{ "block-size", 1, 0, '2' },
+	{ 0 }
+};
+
+static struct iptables_target XOR = {
+	.next		= NULL, 
+	.name		= "XOR",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_XOR_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_XOR_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts 
+};
+
+void _init(void)
+{
+	register_target(&XOR);
+}
--- iptables/extensions/libipt_XOR.man
+++ iptables/extensions/libipt_XOR.man
@@ -0,0 +1,7 @@
+Encrypt TCP and UDP traffic using a simple XOR encryption
+.TP
+.BI "--key " "string"
+Set key to "string"
+.TP
+.BI "--block-size"
+Set block size
--- iptables/extensions/Makefile
+++ iptables/extensions/Makefile
@@ -5,8 +5,25 @@
 # header files are present in the include/linux directory of this iptables
 # package (HW)
 #
-PF_EXT_SLIB:=ah addrtype comment connmark conntrack dscp ecn esp hashlimit helper icmp iprange length limit mac mark multiport owner physdev pkttype policy realm sctp standard state tcp tcpmss tos ttl udp unclean CLASSIFY CONNMARK DNAT DSCP ECN LOG MARK MASQUERADE MIRROR NETMAP NFQUEUE NOTRACK REDIRECT REJECT SAME SNAT TCPMSS TOS TTL ULOG
-PF6_EXT_SLIB:=connmark eui64 hl icmp6 length limit mac mark multiport owner physdev policy standard state tcp udp CONNMARK HL LOG NFQUEUE MARK TCPMSS
+#PF_EXT_SLIB:=ah addrtype comment connlimit connmark conntrack ecn esp hashlimit helper icmp iprange length limit mac mark multiport owner physdev pkttype policy realm rpc sctp standard state tcp tcpmss tos ttl udp unclean CLASSIFY CONNMARK DNAT DSCP ECN LOG MARK MASQUERADE MIRROR NETMAP NFQUEUE NOTRACK REDIRECT REJECT SAME SNAT TARPIT TCPMSS TOS TRACE TTL ULOG
+#PF6_EXT_SLIB:=connmark eui64 hl icmp6 length limit mac mark multiport owner physdev policy standard state tcp udp CONNMARK HL LOG NFQUEUE MARK TRACE
+
+PF_EXT_SLIB:=CLASSIFY CONNMARK DNAT DSCP LOG MARK MASQUERADE REDIRECT REJECT BCOUNT
+PF_EXT_SLIB+=ROUTE SNAT TCPMSS TOS TRIGGER TTL NETMAP
+PF_EXT_SLIB+=condition connlimit connmark geoip icmp iprange layer7
+PF_EXT_SLIB+=length limit mac mark multiport recent standard state quota
+PF_EXT_SLIB+=tcp tcpmss time tos u32 udp web dscp connbytes webmon string bcount conntrack
+PF_EXT_SLIB+=IMQ ipp2p
+PF_EXT_SLIB+=policy
+PF_EXT_SLIB+=hashlimit NFQUEUE NOTRACK
+PF_EXT_SLIB+=set
+PF_EXT_SLIB+=account
+
+ifeq ($(DO_IPV6), 1)
+PF6_EXT_SLIB:=connmark icmp6 length limit mac mark multiport standard state rt hl web string
+PF6_EXT_SLIB+=tcp udp CONNMARK LOG MARK IMQ TCPMSS REJECT
+PF6_EXT_SLIB+=connlimit hashlimit recent NFQUEUE ROUTE HL connbytes iprange webmon dscp
+endif
 
 ifeq ($(DO_SELINUX), 1)
 PF_EXT_SE_SLIB:=SECMARK CONNSECMARK
@@ -14,8 +31,8 @@ PF6_EXT_SE_SLIB:=SECMARK CONNSECMARK
 endif
 
 # Optionals
-PF_EXT_SLIB_OPTS:=$(foreach T,$(wildcard extensions/.*-test),$(shell KERNEL_DIR=$(KERNEL_DIR) $(T)))
-PF6_EXT_SLIB_OPTS:=$(foreach T,$(wildcard extensions/.*-test6),$(shell KERNEL_DIR=$(KERNEL_DIR) $(T)))
+#PF_EXT_SLIB_OPTS:=$(foreach T,$(wildcard extensions/.*-test),$(shell KERNEL_DIR=$(KERNEL_DIR) $(T)))
+#PF6_EXT_SLIB_OPTS:=$(foreach T,$(wildcard extensions/.*-test6),$(shell KERNEL_DIR=$(KERNEL_DIR) $(T)))
 
 PF_EXT_ALL_SLIB:=$(patsubst extensions/libipt_%.c, %, $(wildcard extensions/libipt_*.c))
 PF6_EXT_ALL_SLIB:=$(patsubst extensions/libip6t_%.c, %, $(wildcard extensions/libip6t_*.c))
@@ -44,7 +61,6 @@ PF_EXT_SLIB+=$(PF_EXT_SLIB_OPTS)
 PF6_EXT_SLIB+=$(PF6_EXT_SLIB_OPTS)
 
 OPTIONALS+=$(patsubst %,IPv4:%,$(PF_EXT_SLIB_OPTS))
-OPTIONALS+=$(patsubst %,IPv6:%,$(PF6_EXT_SLIB_OPTS))
 
 ifndef NO_SHARED_LIBS
 SHARED_LIBS+=$(foreach T,$(PF_EXT_SLIB),extensions/libipt_$(T).so)
@@ -53,6 +69,7 @@ EXTRA_INSTALLS+=$(foreach T, $(PF_EXT_SL
 EXTRA_INSTALLS+=$(foreach T, $(PF_EXT_SE_SLIB), $(DESTDIR)$(LIBDIR)/iptables/libipt_$(T).so)
 
 ifeq ($(DO_IPV6), 1)
+OPTIONALS+=$(patsubst %,IPv6:%,$(PF6_EXT_SLIB_OPTS))
 SHARED_LIBS+=$(foreach T,$(PF6_EXT_SLIB),extensions/libip6t_$(T).so)
 SHARED_SE_LIBS+=$(foreach T,$(PF6_EXT_SE_SLIB),extensions/libip6t_$(T).so)
 EXTRA_INSTALLS+=$(foreach T, $(PF6_EXT_SLIB), $(DESTDIR)$(LIBDIR)/iptables/libip6t_$(T).so)
--- iptables/extensions/x_libipt_quota.c
+++ iptables/extensions/x_libipt_quota.c
@@ -0,0 +1,107 @@
+/*
+ * Shared library add-on to iptables to add quota support
+ *
+ * Sam Johnston <samj@samj.net>
+ */
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <iptables.h>
+
+#include <linux/netfilter/xt_quota.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+
+static struct option opts[] = {
+        {"quota", 1, 0, '1'},
+        {0}
+};
+
+/* print usage */
+static void
+help(void)
+{
+        printf("quota options:\n"
+               " --quota quota			quota (bytes)\n" "\n");
+}
+
+/* print matchinfo */
+static void
+print(const struct ipt_ip *ip, const struct ipt_entry_match *match, int numeric)
+{
+        struct xt_quota_info *q = (struct xt_quota_info *) match->data;
+        printf("quota: %llu bytes", (unsigned long long) q->quota);
+}
+
+/* save matchinfo */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+        struct xt_quota_info *q = (struct xt_quota_info *) match->data;
+        printf("--quota %llu ", (unsigned long long) q->quota);
+}
+
+/* parse quota option */
+static int
+parse_quota(const char *s, u_int64_t * quota)
+{
+        *quota = strtoull(s, (char **) NULL, 10);
+
+#ifdef DEBUG_IPT_QUOTA
+        printf("Quota: %llu\n", *quota);
+#endif
+
+        if (*quota == -1)
+                exit_error(PARAMETER_PROBLEM, "quota invalid: '%s'\n", s);
+        else
+                return 1;
+}
+
+/* parse all options, returning true if we found any for us */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache, struct ipt_entry_match **match)
+{
+        struct xt_quota_info *info = (struct xt_quota_info *) (*match)->data;
+
+        switch (c) {
+        case '1':
+                if (check_inverse(optarg, &invert, NULL, 0))
+                        exit_error(PARAMETER_PROBLEM, "quota: unexpected '!'");
+                if (!parse_quota(optarg, &info->quota))
+                        exit_error(PARAMETER_PROBLEM,
+                                   "bad quota: '%s'", optarg);
+                break;
+
+        default:
+                return 0;
+        }
+        return 1;
+}
+
+/* no final check */
+static void
+final_check(unsigned int flags)
+{
+}
+
+struct iptables_match quota = { 
+	.next		= NULL,
+	.name		= "quota",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof (struct xt_quota_info)),
+	.userspacesize	= offsetof(struct xt_quota_info, quota),
+	.help		= &help,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void
+_init(void)
+{
+        register_match(&quota);
+}
--- iptables/extensions/x_libipt_quota.man
+++ iptables/extensions/x_libipt_quota.man
@@ -0,0 +1,7 @@
+Implements network quotas by decrementing a byte counter with each
+packet.
+.TP
+.BI "--quota " "bytes"
+The quota in bytes.
+.P
+KNOWN BUGS: this does not work on SMP systems.
--- iptables/extensions/.XOR-test
+++ iptables/extensions/.XOR-test
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/net/ipv4/netfilter/ipt_XOR.c ] && echo XOR
--- iptables/ip6tables-multi.c
+++ iptables/ip6tables-multi.c
@@ -0,0 +1,33 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <libgen.h>
+
+int ip6tables_main(int argc, char **argv);
+int ip6tables_save_main(int argc, char **argv);
+int ip6tables_restore_main(int argc, char **argv);
+
+int main(int argc, char **argv) {
+  char *progname;
+
+  if (argc == 0) {
+    fprintf(stderr, "no argv[0]?");
+    exit(1);
+  } else {
+    progname = basename(argv[0]);
+
+    if (!strcmp(progname, "ip6tables"))
+      return ip6tables_main(argc, argv);
+    
+#ifdef IPTABLES_SAVE
+    if (!strcmp(progname, "ip6tables-save"))
+      return ip6tables_save_main(argc, argv);
+#endif
+    
+    if (!strcmp(progname, "ip6tables-restore"))
+      return ip6tables_restore_main(argc, argv);
+    
+    fprintf(stderr, "ip6tables multi-purpose version: unknown applet name %s\n", progname);
+    exit(1);
+  }
+}
--- iptables/libipq/Makefile
+++ iptables/libipq/Makefile
@@ -2,6 +2,7 @@
 
 EXTRAS+=libipq/libipq.a
 #CFLAGS+=-DDEBUG_LIBIPTQ
+CFLAGS+=-fPIC
 
 DEVEL_MAN3+=libipq/ipq_create_handle.3 \
 	libipq/ipq_destroy_handle.3 \
--- iptables/libiptc/Makefile
+++ iptables/libiptc/Makefile
@@ -1,6 +1,11 @@
 #! /usr/bin/make
 
 EXTRAS+=libiptc/libiptc.a
+ifeq ($(DO_IPV6), 1)
+EXTRAS+=libiptc/libip6tc.a
+endif
+
+CFLAGS+=-fPIC
 
 # libiptc is not a public interface and therefore not installed
 # DEVEL_LIBS+=libiptc/libiptc.a
@@ -16,9 +21,11 @@ libiptc/libiptc.a: libiptc/libiptc.a(lib
 
 ifeq ($(DO_IPV6), 1)
 EXTRA_DEPENDS+= libiptc/libip6tc.d
-libiptc/libiptc.a: libiptc/libiptc.a(libiptc/libip6tc.o)
+libiptc/libip6tc.a: libiptc/libip6tc.a(libiptc/libip6tc.o)
 endif
 
-libiptc/libip4tc.d libiptc/libip6tc.d: %.d: %.c
+libiptc/libip4tc.d: %.d: %.c
 	@-$(CC) -M -MG $(CFLAGS) $< | sed -e 's@^.*\.o:@$*.d libiptc/libiptc.a($*.o):@' > $@
+libiptc/libip6tc.d: %.d: %.c
+	@-$(CC) -M -MG $(CFLAGS) $< | sed -e 's@^.*\.o:@$*.d libiptc/libip6tc.a($*.o):@' > $@
 endif
--- iptables/Makefile
+++ iptables/Makefile
@@ -1,9 +1,18 @@
 # uncomment this to get a fully statically linked version
 # NO_SHARED_LIBS = 1
 
+ifeq ($(TCONFIG_IPV6),y)
+DO_IPV6 = 1
+else
+DO_IPV6 = 0
+endif
+
 # uncomment this to disable IPv6 support
 # DO_IPV6 = 0
 
+DO_MULTI = 1
+DO_SAVE = 1
+
 ######################################################################
 # YOU SHOULD NOT NEED TO TOUCH ANYTHING BELOW THIS LINE
 ######################################################################
@@ -27,16 +36,18 @@ INCDIR:=$(PREFIX)/include
 RELEASE_DIR:=/tmp
 
 # Need libc6 for this.  FIXME: Should covert to autoconf.
+ifndef DO_IPV6
 ifeq ($(shell [ -f /usr/include/netinet/ip6.h ] && echo YES), YES)
 DO_IPV6:=1
 endif
+endif
 
 # Enable linking to libselinux via enviornment 'DO_SELINUX=1'
 ifndef DO_SELINUX
 DO_SELINUX=0
 endif
 
-COPT_FLAGS:=-O2
+#COPT_FLAGS:=-Os #-mips32
 CFLAGS:=$(COPT_FLAGS) -Wall -Wunused -I$(KERNEL_DIR)/include -Iinclude/ -DIPTABLES_VERSION=\"$(IPTABLES_VERSION)\" #-g -DDEBUG #-pg # -DIPTC_DEBUG
 
 ifdef NO_SHARED_LIBS
@@ -55,42 +66,44 @@ EXTRA_INSTALLS+=$(DESTDIR)$(BINDIR)/ipta
 ifeq ($(DO_IPV6), 1)
 EXTRAS+=ip6tables ip6tables.o ip6tables.8
 EXTRA_INSTALLS+=$(DESTDIR)$(BINDIR)/ip6tables $(DESTDIR)$(MANDIR)/man8/ip6tables.8
-EXTRAS_EXP+=ip6tables-save ip6tables-restore
-EXTRA_INSTALLS_EXP+=$(DESTDIR)$(BINDIR)/ip6tables-save $(DESTDIR)$(BINDIR)/ip6tables-restore # $(DESTDIR)$(MANDIR)/man8/iptables-restore.8 $(DESTDIR)$(MANDIR)/man8/iptables-save.8 $(DESTDIR)$(MANDIR)/man8/ip6tables-save.8 $(DESTDIR)$(MANDIR)/man8/ip6tables-restore.8
+ifneq ($(DO_MULTI), 1)
+EXTRAS_+=ip6tables-save ip6tables-restore
+endif
+EXTRA_INSTALLS+=$(DESTDIR)$(BINDIR)/ip6tables-save $(DESTDIR)$(BINDIR)/ip6tables-restore # $(DESTDIR)$(MANDIR)/man8/iptables-restore.8 $(DESTDIR)$(MANDIR)/man8/iptables-save.8 $(DESTDIR)$(MANDIR)/man8/ip6tables-save.8 $(DESTDIR)$(MANDIR)/man8/ip6tables-restore.8
 endif
 
 # Sparc64 hack
-ifeq ($(shell uname -m),sparc64)
-	POINTERTEST:=1
-	32bituser := $(shell echo -e "\#include <stdio.h>\n\#if !defined(__sparcv9) && !defined(__arch64__) && !defined(_LP64)\nuserspace_is_32bit\n\#endif" | $(CC) $(CFLAGS) -E - | grep userspace_is_32bit)
-	ifdef 32bituser
-		# The kernel is 64-bit, even though userspace is 32.
-		CFLAGS+=-DIPT_MIN_ALIGN=8 -DKERNEL_64_USERSPACE_32
-	else
-		EXT_LDFLAGS+=-Wl,-m,elf64_sparc
-	endif
-endif
+#	ifeq ($(shell uname -m),sparc64)
+#		POINTERTEST:=1
+#		32bituser := $(shell echo -e "\#include <stdio.h>\n\#if !defined(__sparcv9) && !defined(__arch64__) && !defined(_LP64)\nuserspace_is_32bit\n\#endif" | $(CC) $(CFLAGS) -E - | grep userspace_is_32bit)
+#		ifdef 32bituser
+#			# The kernel is 64-bit, even though userspace is 32.
+#			CFLAGS+=-DIPT_MIN_ALIGN=8 -DKERNEL_64_USERSPACE_32
+#		else
+#			EXT_LDFLAGS+=-Wl,-m,elf64_sparc
+#		endif
+#	endif
 
 # Alpha only has 64bit userspace and fails the test below
-ifeq ($(shell uname -m), alpha)
-	POINTERTEST:=1
-endif
+#	ifeq ($(shell uname -m), alpha)
+#		POINTERTEST:=1
+#	endif
 
 # Generic test if arch wasn't found above
-ifneq ($(POINTERTEST),1)
-	# Try to determine if kernel is 64bit and we are compiling for 32bit
-	ifeq ($(shell [ -d $(KERNEL_DIR)/include/asm ] && echo YES), YES)
-		64bitkernel := $(shell echo -e "\#include <asm/types.h>\n\#if BITS_PER_LONG == 64\nkernel_is_64bits\n\#endif" | $(CC) $(CFLAGS) -D__KERNEL__ -E - | grep kernel_is_64bits)
-		ifdef 64bitkernel
-			32bituser := $(shell echo -e "\#include <stdio.h>\n\#if !defined(__arch64__) && !defined(_LP64)\nuserspace_is_32bit\n\#endif" | $(CC) $(CFLAGS) -E - | grep userspace_is_32bit)
-			ifdef 32bituser
-				CFLAGS+=-DIPT_MIN_ALIGN=8 -DKERNEL_64_USERSPACE_32
-			endif
-		endif
-	else
-		CFLAGS+=-D_UNKNOWN_KERNEL_POINTER_SIZE
-	endif
-endif
+#	ifneq ($(POINTERTEST),1)
+#		# Try to determine if kernel is 64bit and we are compiling for 32bit
+#		ifeq ($(shell [ -d $(KERNEL_DIR)/include/asm ] && echo YES), YES)
+#			64bitkernel := $(shell echo -e "\#include <asm/types.h>\n\#if BITS_PER_LONG == 64\nkernel_is_64bits\n\#endif" | $(CC) $(CFLAGS) -D__KERNEL__ -E - | grep kernel_is_64bits)
+#			ifdef 64bitkernel
+#				32bituser := $(shell echo -e "\#include <stdio.h>\n\#if !defined(__arch64__) && !defined(_LP64)\nuserspace_is_32bit\n\#endif" | $(CC) $(CFLAGS) -E - | grep userspace_is_32bit)
+#				ifdef 32bituser
+#					CFLAGS+=-DIPT_MIN_ALIGN=8 -DKERNEL_64_USERSPACE_32
+#				endif
+#			endif
+#		else
+#			CFLAGS+=-D_UNKNOWN_KERNEL_POINTER_SIZE
+#		endif
+#	endif
 
 ifndef IPT_LIBDIR
 IPT_LIBDIR:=$(LIBDIR)/iptables
@@ -118,8 +131,11 @@ LDLIBS       += -lselinux
 endif
 endif
 
+STATIC6_LIBS += libiptc/libip6tc.a
+LDLIBS       += -L. -liptc
+
 .PHONY: default
-default: print-extensions all
+default: libiptc.so all
 
 .PHONY: print-extensions
 print-extensions:
@@ -128,19 +144,34 @@ print-extensions:
 iptables.o: iptables.c
 	$(CC) $(CFLAGS) -DIPT_LIB_DIR=\"$(IPT_LIBDIR)\" -c -o $@ $<
 
+libiptc.so: libiptc/libiptc.a
+	$(LD) -shared -o $@ --whole-archive -Llibiptc -liptc
+
+
 ifeq ($(DO_MULTI), 1)
-iptables: iptables-multi.c iptables-save.c iptables-restore.c iptables-xml.c iptables-standalone.c iptables.o $(STATIC_LIBS) libiptc/libiptc.a
+
+ifeq ($(DO_SAVE), 1)
+iptables: iptables-multi.c iptables-save.c iptables-restore.c iptables-standalone.c iptables.o $(STATIC_LIBS)
+	$(CC) $(CFLAGS) -DIPTABLES_MULTI -DIPTABLES_SAVE -DIPT_LIB_DIR=\"$(IPT_LIBDIR)\" $(LDFLAGS) -o $@ $^ $(LDLIBS)
+else
+iptables: iptables-multi.c iptables-restore.c iptables-standalone.c iptables.o $(STATIC_LIBS)
 	$(CC) $(CFLAGS) -DIPTABLES_MULTI -DIPT_LIB_DIR=\"$(IPT_LIBDIR)\" $(LDFLAGS) -o $@ $^ $(LDLIBS)
+endif
+
+#	iptables: iptables-multi.c iptables-save.c iptables-restore.c iptables-xml.c iptables-standalone.c iptables.o $(STATIC_LIBS)
+#		$(CC) $(CFLAGS) -DIPTABLES_MULTI -DIPT_LIB_DIR=\"$(IPT_LIBDIR)\" $(LDFLAGS) -o $@ $^ $(LDLIBS)
+
 else
-iptables: iptables-standalone.c iptables.o $(STATIC_LIBS) libiptc/libiptc.a
+iptables: iptables-standalone.c iptables.o $(STATIC_LIBS)
 	$(CC) $(CFLAGS) -DIPT_LIB_DIR=\"$(IPT_LIBDIR)\" $(LDFLAGS) -o $@ $^ $(LDLIBS)
 endif
 
+
 $(DESTDIR)$(BINDIR)/iptables: iptables
 	@[ -d $(DESTDIR)$(BINDIR) ] || mkdir -p $(DESTDIR)$(BINDIR)
 	cp $< $@
 
-iptables-save: iptables-save.c iptables.o $(STATIC_LIBS) libiptc/libiptc.a
+iptables-save: iptables-save.c iptables.o $(STATIC_LIBS)
 	$(CC) $(CFLAGS) -DIPT_LIB_DIR=\"$(IPT_LIBDIR)\" $(LDFLAGS) -o $@ $^ $(LDLIBS)
 
 ifeq ($(DO_MULTI), 1)
@@ -153,7 +184,7 @@ $(DESTDIR)$(BINDIR)/iptables-save: iptab
 	cp $< $@
 endif
 
-iptables-restore: iptables-restore.c iptables.o $(STATIC_LIBS) libiptc/libiptc.a
+iptables-restore: iptables-restore.c iptables.o $(STATIC_LIBS)
 	$(CC) $(CFLAGS) -DIPT_LIB_DIR=\"$(IPT_LIBDIR)\" $(LDFLAGS) -o $@ $^ $(LDLIBS)
 
 ifeq ($(DO_MULTI), 1)
@@ -166,7 +197,7 @@ $(DESTDIR)$(BINDIR)/iptables-restore: ip
 	cp $< $@
 endif
 
-iptables-xml: iptables-xml.c #iptables.o # $(STATIC_LIBS) libiptc/libiptc.a
+iptables-xml: iptables-xml.c #iptables.o # $(STATIC_LIBS)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ $(LDLIBS)
 
 ifeq ($(DO_MULTI), 1)
@@ -182,26 +213,48 @@ endif
 ip6tables.o: ip6tables.c
 	$(CC) $(CFLAGS) -DIP6T_LIB_DIR=\"$(IPT_LIBDIR)\" -c -o $@ $<
 
-ip6tables: ip6tables-standalone.c ip6tables.o $(STATIC6_LIBS) libiptc/libiptc.a
+ifeq ($(DO_MULTI), 1)
+ifeq ($(DO_SAVE), 1)
+ip6tables: ip6tables-multi.c ip6tables-save.c ip6tables-restore.c ip6tables-standalone.c ip6tables.o $(STATIC6_LIBS)
+	$(CC) $(CFLAGS) -DIPTABLES_MULTI -DIPTABLES_SAVE -DIP6T_LIB_DIR=\"$(IPT_LIBDIR)\" $(LDFLAGS) -o $@ $^ $(LDLIBS)
+else
+ip6tables: ip6tables-multi.c ip6tables-restore.c ip6tables-standalone.c ip6tables.o $(STATIC6_LIBS)
+	$(CC) $(CFLAGS) -DIPTABLES_MULTI -DIP6T_LIB_DIR=\"$(IPT_LIBDIR)\" $(LDFLAGS) -o $@ $^ $(LDLIBS)
+endif
+else
+ip6tables: ip6tables-standalone.c ip6tables.o $(STATIC6_LIBS)
 	$(CC) $(CFLAGS) -DIP6T_LIB_DIR=\"$(IPT_LIBDIR)\" $(LDFLAGS) -o $@ $^ $(LDLIBS)
+endif
 
 $(DESTDIR)$(BINDIR)/ip6tables: ip6tables
 	@[ -d $(DESTDIR)$(BINDIR) ] || mkdir -p $(DESTDIR)$(BINDIR)
 	cp $< $@
 
-ip6tables-save: ip6tables-save.c ip6tables.o $(STATIC6_LIBS) libiptc/libiptc.a
+ip6tables-save: ip6tables-save.c ip6tables.o $(STATIC6_LIBS)
 	$(CC) $(CFLAGS) -DIP6T_LIB_DIR=\"$(IPT_LIBDIR)\" $(LDFLAGS) -o $@ $^ $(LDLIBS)
 
+ifeq ($(DO_MULTI), 1)
+$(DESTDIR)$(BINDIR)/ip6tables-save: ip6tables
+	@[ -d $(DESTDIR)$(BINDIR) ] || mkdir -p $(DESTDIR)$(BINDIR)
+	ln -sf $< $@
+else
 $(DESTDIR)$(BINDIR)/ip6tables-save: ip6tables-save
 	@[ -d $(DESTDIR)$(BINDIR) ] || mkdir -p $(DESTDIR)$(BINDIR)
 	cp $< $@
+endif
 
-ip6tables-restore: ip6tables-restore.c ip6tables.o $(STATIC6_LIBS) libiptc/libiptc.a
+ip6tables-restore: ip6tables-restore.c ip6tables.o $(STATIC6_LIBS)
 	$(CC) $(CFLAGS) -DIP6T_LIB_DIR=\"$(IPT_LIBDIR)\" $(LDFLAGS) -o $@ $^ $(LDLIBS)
 
+ifeq ($(DO_MULTI), 1)
+$(DESTDIR)$(BINDIR)/ip6tables-restore: ip6tables
+	@[ -d $(DESTDIR)$(BINDIR) ] || mkdir -p $(DESTDIR)$(BINDIR)
+	ln -sf $< $@
+else
 $(DESTDIR)$(BINDIR)/ip6tables-restore: ip6tables-restore
 	@[ -d $(DESTDIR)$(BINDIR) ] || mkdir -p $(DESTDIR)$(BINDIR)
 	cp $< $@
+endif
 
 $(DESTDIR)$(MANDIR)/man8/%.8: %.8
 	@[ -d $(DESTDIR)$(MANDIR)/man8 ] || mkdir -p $(DESTDIR)$(MANDIR)/man8
